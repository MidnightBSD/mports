# HG changeset patch
# User andrew
# Date 1365739093 -3600
# Node ID e8ed86062291305172267be90dcec2acef7c15a8
# Parent  c7ddbf756d7f35d6e782eb91b86ce2938de44fb8
6501644: sync LayoutEngine *code* structure to match ICU
Reviewed-by: prr

diff --git a/make/sun/font/Makefile b/make/sun/font/Makefile
--- jdk/make/sun/font/Makefile
+++ jdk/make/sun/font/Makefile
@@ -209,3 +209,7 @@
 	    -I$(PLATFORM_SRC)/native/sun/java2d/d3d
 endif
 
+# Make the Layout Engine build standalone
+CPPFLAGS += -DLE_STANDALONE
+
+
diff --git a/src/share/native/sun/font/layout/AlternateSubstSubtables.cpp b/src/share/native/sun/font/layout/AlternateSubstSubtables.cpp
--- jdk/src/share/native/sun/font/layout/AlternateSubstSubtables.cpp
+++ jdk/src/share/native/sun/font/layout/AlternateSubstSubtables.cpp
@@ -37,6 +37,8 @@
 #include "GlyphIterator.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 le_uint32 AlternateSubstitutionSubtable::process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter) const
 {
     // NOTE: For now, we'll just pick the first alternative...
@@ -64,3 +66,5 @@
 
     return 0;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/AlternateSubstSubtables.h b/src/share/native/sun/font/layout/AlternateSubstSubtables.h
--- jdk/src/share/native/sun/font/layout/AlternateSubstSubtables.h
+++ jdk/src/share/native/sun/font/layout/AlternateSubstSubtables.h
@@ -32,12 +32,19 @@
 #ifndef __ALTERNATESUBSTITUTIONSUBTABLES_H
 #define __ALTERNATESUBSTITUTIONSUBTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEGlyphFilter.h"
 #include "OpenTypeTables.h"
 #include "GlyphSubstitutionTables.h"
 #include "GlyphIterator.h"
 
+U_NAMESPACE_BEGIN
+
 struct AlternateSetTable
 {
     le_uint16 glyphCount;
@@ -52,4 +59,5 @@
     le_uint32 process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter = NULL) const;
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/AnchorTables.cpp b/src/share/native/sun/font/layout/AnchorTables.cpp
--- jdk/src/share/native/sun/font/layout/AnchorTables.cpp
+++ jdk/src/share/native/sun/font/layout/AnchorTables.cpp
@@ -35,6 +35,8 @@
 #include "AnchorTables.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 void AnchorTable::getAnchor(LEGlyphID glyphID, const LEFontInstance *fontInstance,
                             LEPoint &anchor) const
 {
@@ -124,3 +126,6 @@
 
     fontInstance->pixelsToUnits(pixels, anchor);
 }
+
+U_NAMESPACE_END
+
diff --git a/src/share/native/sun/font/layout/AnchorTables.h b/src/share/native/sun/font/layout/AnchorTables.h
--- jdk/src/share/native/sun/font/layout/AnchorTables.h
+++ jdk/src/share/native/sun/font/layout/AnchorTables.h
@@ -32,10 +32,17 @@
 #ifndef __ANCHORTABLES_H
 #define __ANCHORTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEFontInstance.h"
 #include "OpenTypeTables.h"
 
+U_NAMESPACE_BEGIN
+
 struct AnchorTable
 {
     le_uint16  anchorFormat;
@@ -66,5 +73,7 @@
     void getAnchor(const LEFontInstance *fontInstance, LEPoint &anchor) const;
 };
 
+U_NAMESPACE_END
+#endif
 
-#endif
+
diff --git a/src/share/native/sun/font/layout/ArabicLayoutEngine.cpp b/src/share/native/sun/font/layout/ArabicLayoutEngine.cpp
--- jdk/src/share/native/sun/font/layout/ArabicLayoutEngine.cpp
+++ jdk/src/share/native/sun/font/layout/ArabicLayoutEngine.cpp
@@ -49,23 +49,25 @@
 #include "ArabicShaping.h"
 #include "CanonShaping.h"
 
+U_NAMESPACE_BEGIN
+
 le_bool CharSubstitutionFilter::accept(LEGlyphID glyph) const
 {
     return fFontInstance->canDisplay((LEUnicode) glyph);
 }
 
-ArabicOpenTypeLayoutEngine::ArabicOpenTypeLayoutEngine(
-    const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-    le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable)
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(ArabicOpenTypeLayoutEngine)
+
+ArabicOpenTypeLayoutEngine::ArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                        le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable)
     : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable)
 {
     fFeatureMap = ArabicShaping::getFeatureMap(fFeatureMapCount);
     fFeatureOrder = TRUE;
 }
 
-ArabicOpenTypeLayoutEngine::ArabicOpenTypeLayoutEngine(
-    const LEFontInstance *fontInstance,
-    le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags)
+ArabicOpenTypeLayoutEngine::ArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                                                       le_int32 typoFlags)
     : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags)
 {
     fFeatureMap = ArabicShaping::getFeatureMap(fFeatureMapCount);
@@ -86,9 +88,8 @@
 // Input: characters
 // Output: characters, char indices, tags
 // Returns: output character count
-le_int32 ArabicOpenTypeLayoutEngine::characterProcessing(const LEUnicode chars[],
-    le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
-    LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success)
+le_int32 ArabicOpenTypeLayoutEngine::characterProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+        LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
@@ -124,8 +125,8 @@
     return count;
 }
 
-void ArabicOpenTypeLayoutEngine::adjustGlyphPositions(const LEUnicode chars[], le_int32 offset,
-    le_int32 count, le_bool reverse, LEGlyphStorage &glyphStorage, LEErrorCode &success)
+void ArabicOpenTypeLayoutEngine::adjustGlyphPositions(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse,
+                                                      LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return;
@@ -137,24 +138,20 @@
     }
 
     if (fGPOSTable != NULL) {
-        OpenTypeLayoutEngine::adjustGlyphPositions(chars, offset, count,
-            reverse, glyphStorage, success);
+        OpenTypeLayoutEngine::adjustGlyphPositions(chars, offset, count, reverse, glyphStorage, success);
     } else if (fGDEFTable != NULL) {
         GDEFMarkFilter filter(fGDEFTable);
 
         adjustMarkGlyphs(glyphStorage, &filter, success);
     } else {
-        GlyphDefinitionTableHeader *gdefTable =
-            (GlyphDefinitionTableHeader *) CanonShaping::glyphDefinitionTable;
+        GlyphDefinitionTableHeader *gdefTable = (GlyphDefinitionTableHeader *) CanonShaping::glyphDefinitionTable;
         GDEFMarkFilter filter(gdefTable);
 
         adjustMarkGlyphs(&chars[offset], count, reverse, glyphStorage, &filter, success);
     }
 }
 
-UnicodeArabicOpenTypeLayoutEngine::UnicodeArabicOpenTypeLayoutEngine(
-    const LEFontInstance *fontInstance,
-    le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags)
+UnicodeArabicOpenTypeLayoutEngine::UnicodeArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags)
     : ArabicOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags | LE_CHAR_FILTER_FEATURE_FLAG)
 {
     fGSUBTable = (const GlyphSubstitutionTableHeader *) CanonShaping::glyphSubstitutionTable;
@@ -168,8 +165,7 @@
 }
 
 // "glyphs", "indices" -> glyphs, indices
-le_int32 UnicodeArabicOpenTypeLayoutEngine::glyphPostProcessing(
-    LEGlyphStorage &tempGlyphStorage, LEGlyphStorage &glyphStorage, LEErrorCode &success)
+le_int32 UnicodeArabicOpenTypeLayoutEngine::glyphPostProcessing(LEGlyphStorage &tempGlyphStorage, LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
@@ -192,17 +188,14 @@
 
     glyphStorage.adoptCharIndicesArray(tempGlyphStorage);
 
-    ArabicOpenTypeLayoutEngine::mapCharsToGlyphs(tempChars, 0, tempGlyphCount, FALSE,
-        TRUE, glyphStorage, success);
+    ArabicOpenTypeLayoutEngine::mapCharsToGlyphs(tempChars, 0, tempGlyphCount, FALSE, TRUE, glyphStorage, success);
 
     LE_DELETE_ARRAY(tempChars);
 
     return tempGlyphCount;
 }
 
-void UnicodeArabicOpenTypeLayoutEngine::mapCharsToGlyphs(const LEUnicode chars[],
-    le_int32 offset, le_int32 count, le_bool reverse, le_bool /*mirror*/,
-    LEGlyphStorage &glyphStorage, LEErrorCode &success)
+void UnicodeArabicOpenTypeLayoutEngine::mapCharsToGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse, le_bool /*mirror*/, LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return;
@@ -227,9 +220,8 @@
     }
 }
 
-void UnicodeArabicOpenTypeLayoutEngine::adjustGlyphPositions(const LEUnicode chars[],
-    le_int32 offset, le_int32 count, le_bool reverse,
-    LEGlyphStorage &glyphStorage, LEErrorCode &success)
+void UnicodeArabicOpenTypeLayoutEngine::adjustGlyphPositions(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse,
+                                                      LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return;
@@ -244,3 +236,6 @@
 
     adjustMarkGlyphs(&chars[offset], count, reverse, glyphStorage, &filter, success);
 }
+
+U_NAMESPACE_END
+
diff --git a/src/share/native/sun/font/layout/ArabicLayoutEngine.h b/src/share/native/sun/font/layout/ArabicLayoutEngine.h
--- jdk/src/share/native/sun/font/layout/ArabicLayoutEngine.h
+++ jdk/src/share/native/sun/font/layout/ArabicLayoutEngine.h
@@ -43,6 +43,8 @@
 #include "GlyphDefinitionTables.h"
 #include "GlyphPositioningTables.h"
 
+U_NAMESPACE_BEGIN
+
 /**
  * This class implements OpenType layout for Arabic fonts. It overrides
  * the characerProcessing method to assign the correct OpenType feature
@@ -71,8 +73,8 @@
      *
      * @internal
      */
-    ArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode,
-        le_int32 languageCode, le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable);
+    ArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                            le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable);
 
     /**
      * This constructor is used when the font requires a "canned" GSUB table which can't be known
@@ -87,8 +89,8 @@
      *
      * @internal
      */
-    ArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode,
-        le_int32 languageCode, le_int32 typoFlags);
+    ArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                               le_int32 typoFlags);
 
     /**
      * The destructor, virtual for correct polymorphic invocation.
@@ -97,6 +99,20 @@
      */
     virtual ~ArabicOpenTypeLayoutEngine();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 protected:
 
     /**
@@ -108,8 +124,7 @@
      * @param offset - the index of the first character to process
      * @param count - the number of characters to process
      * @param max - the number of characters in the input context
-     * @param rightToLeft - <code>TRUE</code> if the characters are in a
-     *     right to left directional run
+     * @param rightToLeft - <code>TRUE</code> if the characters are in a right to left directional run
      *
      * Output parameters:
      * @param outChars - the output character arrayt
@@ -121,9 +136,8 @@
      *
      * @internal
      */
-    virtual le_int32 characterProcessing(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_int32 max, le_bool rightToLeft,
-        LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual le_int32 characterProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+            LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     /**
      * This method applies the GPOS table if it is present, otherwise it ensures that all vowel
@@ -142,11 +156,9 @@
      *
      * @internal
      */
-    virtual void adjustGlyphPositions(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_bool reverse, LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual void adjustGlyphPositions(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
-    // static void adjustMarkGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count,
-    // le_bool rightToLeft, LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    // static void adjustMarkGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool rightToLeft, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
 };
 
@@ -178,8 +190,8 @@
      *
      * @internal
      */
-    UnicodeArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance,
-        le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags);
+    UnicodeArabicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                le_int32 typoFlags);
 
     /**
      * The destructor, virtual for correct polymorphic invocation.
@@ -208,8 +220,7 @@
      *
      * @internal
      */
-    virtual le_int32 glyphPostProcessing(LEGlyphStorage &tempGlyphStorage,
-        LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual le_int32 glyphPostProcessing(LEGlyphStorage &tempGlyphStorage, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     /**
      * This method copies the input characters into the output glyph index array,
@@ -227,8 +238,7 @@
      *
      * @internal
      */
-    virtual void mapCharsToGlyphs(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_bool reverse, le_bool mirror,
+    virtual void mapCharsToGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse, le_bool mirror,
         LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     /**
@@ -245,8 +255,9 @@
      *
      * @internal
      */
-    virtual void adjustGlyphPositions(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_bool reverse, LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual void adjustGlyphPositions(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/ArabicShaping.cpp b/src/share/native/sun/font/layout/ArabicShaping.cpp
--- jdk/src/share/native/sun/font/layout/ArabicShaping.cpp
+++ jdk/src/share/native/sun/font/layout/ArabicShaping.cpp
@@ -35,6 +35,8 @@
 #include "LEGlyphStorage.h"
 #include "ClassDefinitionTables.h"
 
+U_NAMESPACE_BEGIN
+
 // This table maps Unicode joining types to
 // ShapeTypes.
 const ArabicShaping::ShapeType ArabicShaping::shapeTypes[] =
@@ -102,9 +104,7 @@
 #define markFeatureMask 0x00040000UL
 #define mkmkFeatureMask 0x00020000UL
 
-#define ISOL_FEATURES (isolFeatureMask | ligaFeatureMask | msetFeatureMask | \
-    markFeatureMask | ccmpFeatureMask | rligFeatureMask | caltFeatureMask | \
-    dligFeatureMask | cswhFeatureMask | cursFeatureMask | kernFeatureMask | mkmkFeatureMask)
+#define ISOL_FEATURES (isolFeatureMask | ligaFeatureMask | msetFeatureMask | markFeatureMask | ccmpFeatureMask | rligFeatureMask | caltFeatureMask | dligFeatureMask | cswhFeatureMask | cursFeatureMask | kernFeatureMask | mkmkFeatureMask)
 
 #define SHAPE_MASK 0xF0000000UL
 
@@ -226,3 +226,5 @@
         adjustTags(erout, 2, glyphStorage);
     }
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/ArabicShaping.h b/src/share/native/sun/font/layout/ArabicShaping.h
--- jdk/src/share/native/sun/font/layout/ArabicShaping.h
+++ jdk/src/share/native/sun/font/layout/ArabicShaping.h
@@ -32,12 +32,19 @@
 #ifndef __ARABICSHAPING_H
 #define __ARABICSHAPING_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
-class ArabicShaping {
+class ArabicShaping /* not : public UObject because all methods are static */ {
 public:
     // Joining types
     enum JoiningTypes
@@ -74,8 +81,8 @@
 
     typedef le_int32 ShapeType;
 
-    static void shape(const LEUnicode *chars, le_int32 offset, le_int32 charCount,
-        le_int32 charMax, le_bool rightToLeft, LEGlyphStorage &glyphStorage);
+    static void shape(const LEUnicode *chars, le_int32 offset, le_int32 charCount, le_int32 charMax,
+                      le_bool rightToLeft, LEGlyphStorage &glyphStorage);
 
     static const FeatureMap *getFeatureMap(le_int32 &count);
 
@@ -88,8 +95,8 @@
     static const le_uint8 shapingTypeTable[];
     static const ShapeType shapeTypes[];
 
-    static void adjustTags(le_int32 outIndex, le_int32 shapeOffset,
-        LEGlyphStorage &glyphStorage);
+    static void adjustTags(le_int32 outIndex, le_int32 shapeOffset, LEGlyphStorage &glyphStorage);
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/AttachmentPosnSubtables.h b/src/share/native/sun/font/layout/AttachmentPosnSubtables.h
--- jdk/src/share/native/sun/font/layout/AttachmentPosnSubtables.h
+++ jdk/src/share/native/sun/font/layout/AttachmentPosnSubtables.h
@@ -32,12 +32,19 @@
 #ifndef __ATTACHMENTPOSITIONINGSUBTABLES_H
 #define __ATTACHMENTPOSITIONINGSUBTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 #include "GlyphPositioningTables.h"
 #include "ValueRecords.h"
 #include "GlyphIterator.h"
 
+U_NAMESPACE_BEGIN
+
 struct AttachmentPositioningSubtable : GlyphPositioningSubtable
 {
     Offset    baseCoverageTableOffset;
@@ -55,4 +62,6 @@
     return getGlyphCoverage(baseCoverageTableOffset, baseGlyphID);
 }
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/CanonData.cpp b/src/share/native/sun/font/layout/CanonData.cpp
--- jdk/src/share/native/sun/font/layout/CanonData.cpp
+++ jdk/src/share/native/sun/font/layout/CanonData.cpp
@@ -36,6 +36,8 @@
 #include "LETypes.h"
 #include "CanonShaping.h"
 
+U_NAMESPACE_BEGIN
+
 const le_uint8 CanonShaping::glyphSubstitutionTable[] = {
     0x00, 0x01, 0x00, 0x00, 0x00, 0x0A, 0x01, 0x58, 0x02, 0x86, 0x00, 0x12, 0x61, 0x72, 0x61, 0x62,
     0x00, 0x6E, 0x62, 0x65, 0x6E, 0x67, 0x00, 0x82, 0x63, 0x79, 0x72, 0x6C, 0x00, 0x8E, 0x64, 0x65,
@@ -3773,3 +3775,5 @@
     0x00, 0xDC, 0xD1, 0x85, 0xD1, 0x89, 0x00, 0xE6, 0xD1, 0x8A, 0xD1, 0x8B, 0x00, 0xDC, 0xD1, 0xAA,
     0xD1, 0xAD, 0x00, 0xE6, 0xD2, 0x42, 0xD2, 0x44, 0x00, 0xE6
 };
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/CanonShaping.cpp b/src/share/native/sun/font/layout/CanonShaping.cpp
--- jdk/src/share/native/sun/font/layout/CanonShaping.cpp
+++ jdk/src/share/native/sun/font/layout/CanonShaping.cpp
@@ -35,8 +35,9 @@
 #include "GlyphDefinitionTables.h"
 #include "ClassDefinitionTables.h"
 
-void CanonShaping::sortMarks(le_int32 *indices,
-    const le_int32 *combiningClasses, le_int32 index, le_int32 limit)
+U_NAMESPACE_BEGIN
+
+void CanonShaping::sortMarks(le_int32 *indices, const le_int32 *combiningClasses, le_int32 index, le_int32 limit)
 {
     for (le_int32 j = index + 1; j < limit; j += 1) {
         le_int32 i;
@@ -55,13 +56,11 @@
     }
 }
 
-void CanonShaping::reorderMarks(const LEUnicode *inChars, le_int32 charCount,
-    le_bool rightToLeft, LEUnicode *outChars, LEGlyphStorage &glyphStorage)
+void CanonShaping::reorderMarks(const LEUnicode *inChars, le_int32 charCount, le_bool rightToLeft,
+                                LEUnicode *outChars, LEGlyphStorage &glyphStorage)
 {
-    const GlyphDefinitionTableHeader *gdefTable =
-        (const GlyphDefinitionTableHeader *) glyphDefinitionTable;
-    const ClassDefinitionTable *classTable =
-        gdefTable->getMarkAttachClassDefinitionTable();
+    const GlyphDefinitionTableHeader *gdefTable = (const GlyphDefinitionTableHeader *) glyphDefinitionTable;
+    const ClassDefinitionTable *classTable = gdefTable->getMarkAttachClassDefinitionTable();
     le_int32 *combiningClasses = LE_NEW_ARRAY(le_int32, charCount);
     le_int32 *indices = LE_NEW_ARRAY(le_int32, charCount);
     LEErrorCode status = LE_NO_ERROR;
@@ -103,3 +102,5 @@
     LE_DELETE_ARRAY(indices);
     LE_DELETE_ARRAY(combiningClasses);
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/CanonShaping.h b/src/share/native/sun/font/layout/CanonShaping.h
--- jdk/src/share/native/sun/font/layout/CanonShaping.h
+++ jdk/src/share/native/sun/font/layout/CanonShaping.h
@@ -34,20 +34,22 @@
 
 #include "LETypes.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
-class CanonShaping
+class CanonShaping /* not : public UObject because all members are static */
 {
 public:
     static const le_uint8 glyphSubstitutionTable[];
     static const le_uint8 glyphDefinitionTable[];
 
-    static void reorderMarks(const LEUnicode *inChars, le_int32 charCount,
-        le_bool rightToLeft, LEUnicode *outChars, LEGlyphStorage &glyphStorage);
+    static void reorderMarks(const LEUnicode *inChars, le_int32 charCount, le_bool rightToLeft,
+                                   LEUnicode *outChars, LEGlyphStorage &glyphStorage);
 
 private:
-    static void sortMarks(le_int32 *indices, const le_int32 *combiningClasses,
-        le_int32 index, le_int32 limit);
+    static void sortMarks(le_int32 *indices, const le_int32 *combiningClasses, le_int32 index, le_int32 limit);
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/CharSubstitutionFilter.h b/src/share/native/sun/font/layout/CharSubstitutionFilter.h
--- jdk/src/share/native/sun/font/layout/CharSubstitutionFilter.h
+++ jdk/src/share/native/sun/font/layout/CharSubstitutionFilter.h
@@ -35,6 +35,8 @@
 #include "LETypes.h"
 #include "LEGlyphFilter.h"
 
+U_NAMESPACE_BEGIN
+
 class LEFontInstance;
 
 /**
@@ -43,7 +45,7 @@
  *
  * @internal
  */
-class CharSubstitutionFilter : public LEGlyphFilter
+class CharSubstitutionFilter : public UMemory, public LEGlyphFilter
 {
 private:
     /**
@@ -98,4 +100,7 @@
     le_bool accept(LEGlyphID glyph) const;
 };
 
+U_NAMESPACE_END
 #endif
+
+
diff --git a/src/share/native/sun/font/layout/ClassDefinitionTables.cpp b/src/share/native/sun/font/layout/ClassDefinitionTables.cpp
--- jdk/src/share/native/sun/font/layout/ClassDefinitionTables.cpp
+++ jdk/src/share/native/sun/font/layout/ClassDefinitionTables.cpp
@@ -35,6 +35,8 @@
 #include "ClassDefinitionTables.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 le_int32 ClassDefinitionTable::getGlyphClass(LEGlyphID glyphID) const
 {
     switch(SWAPW(classFormat)) {
@@ -139,3 +141,5 @@
 
     return FALSE;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/ClassDefinitionTables.h b/src/share/native/sun/font/layout/ClassDefinitionTables.h
--- jdk/src/share/native/sun/font/layout/ClassDefinitionTables.h
+++ jdk/src/share/native/sun/font/layout/ClassDefinitionTables.h
@@ -32,9 +32,16 @@
 #ifndef __CLASSDEFINITIONTABLES_H
 #define __CLASSDEFINITIONTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 
+U_NAMESPACE_BEGIN
+
 struct ClassDefinitionTable
 {
     le_uint16 classFormat;
@@ -69,4 +76,5 @@
     le_bool hasGlyphClass(le_int32 glyphClass) const;
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/ContextualGlyphInsertion.h b/src/share/native/sun/font/layout/ContextualGlyphInsertion.h
--- jdk/src/share/native/sun/font/layout/ContextualGlyphInsertion.h
+++ jdk/src/share/native/sun/font/layout/ContextualGlyphInsertion.h
@@ -32,12 +32,19 @@
 #ifndef __CONTEXTUALGLYPHINSERTION_H
 #define __CONTEXTUALGLYPHINSERTION_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LayoutTables.h"
 #include "StateTables.h"
 #include "MorphTables.h"
 #include "MorphStateTables.h"
 
+U_NAMESPACE_BEGIN
+
 struct ContextualGlyphInsertionHeader : MorphStateTableHeader
 {
 };
@@ -60,4 +67,5 @@
     ByteOffset markedInsertionListOffset;
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/ContextualGlyphSubstProc.cpp b/src/share/native/sun/font/layout/ContextualGlyphSubstProc.cpp
--- jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc.cpp
+++ jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc.cpp
@@ -39,6 +39,10 @@
 #include "LEGlyphStorage.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(ContextualGlyphSubstitutionProcessor)
+
 ContextualGlyphSubstitutionProcessor::ContextualGlyphSubstitutionProcessor(const MorphSubtableHeader *morphSubtableHeader)
   : StateTableProcessor(morphSubtableHeader)
 {
@@ -57,8 +61,7 @@
     markGlyph = 0;
 }
 
-ByteOffset ContextualGlyphSubstitutionProcessor::processStateEntry(LEGlyphStorage &glyphStorage,
-    le_int32 &currGlyph, EntryTableIndex index)
+ByteOffset ContextualGlyphSubstitutionProcessor::processStateEntry(LEGlyphStorage &glyphStorage, le_int32 &currGlyph, EntryTableIndex index)
 {
     const ContextualGlyphSubstitutionStateEntry *entry = &entryTable[index];
     ByteOffset newState = SWAPW(entry->newStateOffset);
@@ -97,3 +100,5 @@
 void ContextualGlyphSubstitutionProcessor::endStateTable()
 {
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/ContextualGlyphSubstProc.h b/src/share/native/sun/font/layout/ContextualGlyphSubstProc.h
--- jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc.h
+++ jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc.h
@@ -32,12 +32,19 @@
 #ifndef __CONTEXTUALGLYPHSUBSTITUTIONPROCESSOR_H
 #define __CONTEXTUALGLYPHSUBSTITUTIONPROCESSOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "MorphTables.h"
 #include "SubtableProcessor.h"
 #include "StateTableProcessor.h"
 #include "ContextualGlyphSubstitution.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 class ContextualGlyphSubstitutionProcessor : public StateTableProcessor
@@ -52,6 +59,20 @@
     ContextualGlyphSubstitutionProcessor(const MorphSubtableHeader *morphSubtableHeader);
     virtual ~ContextualGlyphSubstitutionProcessor();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 private:
     ContextualGlyphSubstitutionProcessor();
 
@@ -62,6 +83,8 @@
     le_int32 markGlyph;
 
     const ContextualGlyphSubstitutionHeader *contextualGlyphSubstitutionHeader;
+
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/ContextualGlyphSubstitution.h b/src/share/native/sun/font/layout/ContextualGlyphSubstitution.h
--- jdk/src/share/native/sun/font/layout/ContextualGlyphSubstitution.h
+++ jdk/src/share/native/sun/font/layout/ContextualGlyphSubstitution.h
@@ -32,11 +32,18 @@
 #ifndef __CONTEXTUALGLYPHSUBSTITUTION_H
 #define __CONTEXTUALGLYPHSUBSTITUTION_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LayoutTables.h"
 #include "StateTables.h"
 #include "MorphTables.h"
 
+U_NAMESPACE_BEGIN
+
 struct ContextualGlyphSubstitutionHeader : MorphStateTableHeader
 {
     ByteOffset  substitutionTableOffset;
@@ -55,4 +62,5 @@
     WordOffset currOffset;
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/ContextualSubstSubtables.cpp b/src/share/native/sun/font/layout/ContextualSubstSubtables.cpp
--- jdk/src/share/native/sun/font/layout/ContextualSubstSubtables.cpp
+++ jdk/src/share/native/sun/font/layout/ContextualSubstSubtables.cpp
@@ -24,7 +24,6 @@
  */
 
 /*
- *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
  *
  */
@@ -39,6 +38,8 @@
 #include "CoverageTables.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 /*
     NOTE: This could be optimized somewhat by keeping track
     of the previous sequenceIndex in the loop and doing next()
@@ -350,7 +351,7 @@
 
 // NOTE: This could be a #define, but that seems to confuse
 // the Visual Studio .NET 2003 compiler on the calls to the
-// GlyphIterator constructor.  It somehow can't decide if
+// GlyphIterator constructor. It somehow can't decide if
 // emptyFeatureList matches an le_uint32 or an le_uint16...
 static const FeatureMask emptyFeatureList = 0x00000000UL;
 
@@ -542,3 +543,5 @@
 
     return 0;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/ContextualSubstSubtables.h b/src/share/native/sun/font/layout/ContextualSubstSubtables.h
--- jdk/src/share/native/sun/font/layout/ContextualSubstSubtables.h
+++ jdk/src/share/native/sun/font/layout/ContextualSubstSubtables.h
@@ -32,6 +32,11 @@
 #ifndef __CONTEXTUALSUBSTITUTIONSUBTABLES_H
 #define __CONTEXTUALSUBSTITUTIONSUBTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEFontInstance.h"
 #include "OpenTypeTables.h"
@@ -39,6 +44,8 @@
 #include "GlyphIterator.h"
 #include "LookupProcessor.h"
 
+U_NAMESPACE_BEGIN
+
 struct SubstitutionLookupRecord
 {
     le_uint16  sequenceIndex;
@@ -218,4 +225,5 @@
     le_uint32  process(const LookupProcessor *lookupProcessor, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/CoverageTables.cpp b/src/share/native/sun/font/layout/CoverageTables.cpp
--- jdk/src/share/native/sun/font/layout/CoverageTables.cpp
+++ jdk/src/share/native/sun/font/layout/CoverageTables.cpp
@@ -35,6 +35,8 @@
 #include "CoverageTables.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 le_int32 CoverageTable::getGlyphCoverage(LEGlyphID glyphID) const
 {
     switch(SWAPW(coverageFormat))
@@ -106,3 +108,5 @@
 
     return startCoverageIndex + (ttGlyphID - firstInRange);
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/CoverageTables.h b/src/share/native/sun/font/layout/CoverageTables.h
--- jdk/src/share/native/sun/font/layout/CoverageTables.h
+++ jdk/src/share/native/sun/font/layout/CoverageTables.h
@@ -32,9 +32,16 @@
 #ifndef __COVERAGETABLES_H
 #define __COVERAGETABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 
+U_NAMESPACE_BEGIN
+
 struct CoverageTable
 {
     le_uint16 coverageFormat;
@@ -58,5 +65,5 @@
     le_int32 getGlyphCoverage(LEGlyphID glyphID) const;
 };
 
-
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/CursiveAttachmentSubtables.cpp b/src/share/native/sun/font/layout/CursiveAttachmentSubtables.cpp
--- jdk/src/share/native/sun/font/layout/CursiveAttachmentSubtables.cpp
+++ jdk/src/share/native/sun/font/layout/CursiveAttachmentSubtables.cpp
@@ -37,6 +37,8 @@
 #include "OpenTypeUtilities.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 le_uint32 CursiveAttachmentSubtable::process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const
 {
     LEGlyphID glyphID       = glyphIterator->getCurrGlyphID();
@@ -68,3 +70,5 @@
 
     return 1;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/CursiveAttachmentSubtables.h b/src/share/native/sun/font/layout/CursiveAttachmentSubtables.h
--- jdk/src/share/native/sun/font/layout/CursiveAttachmentSubtables.h
+++ jdk/src/share/native/sun/font/layout/CursiveAttachmentSubtables.h
@@ -32,10 +32,17 @@
 #ifndef __CURSIVEATTACHMENTSUBTABLES_H
 #define __CURSIVEATTACHMENTSUBTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 #include "GlyphPositioningTables.h"
 
+U_NAMESPACE_BEGIN
+
 class LEFontInstance;
 class GlyphIterator;
 
@@ -53,4 +60,7 @@
     le_uint32  process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
 };
 
+U_NAMESPACE_END
 #endif
+
+
diff --git a/src/share/native/sun/font/layout/DefaultCharMapper.h b/src/share/native/sun/font/layout/DefaultCharMapper.h
--- jdk/src/share/native/sun/font/layout/DefaultCharMapper.h
+++ jdk/src/share/native/sun/font/layout/DefaultCharMapper.h
@@ -24,7 +24,6 @@
  */
 
 /*
- *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
  *
  */
@@ -32,9 +31,16 @@
 #ifndef __DEFAULTCHARMAPPER_H
 #define __DEFAULTCHARMAPPER_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEFontInstance.h"
 
+U_NAMESPACE_BEGIN
+
 /**
  * This class is an instance of LECharMapper which
  * implements control character filtering and bidi
@@ -42,7 +48,7 @@
  *
  * @see LECharMapper
  */
-class DefaultCharMapper : public LECharMapper
+class DefaultCharMapper : public UMemory, public LECharMapper
 {
 private:
     le_bool fFilterControls;
@@ -77,4 +83,5 @@
     LEUnicode32 mapChar(LEUnicode32 ch) const;
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/DeviceTables.cpp b/src/share/native/sun/font/layout/DeviceTables.cpp
--- jdk/src/share/native/sun/font/layout/DeviceTables.cpp
+++ jdk/src/share/native/sun/font/layout/DeviceTables.cpp
@@ -25,6 +25,7 @@
 
 /*
  *
+ *
  * (C) Copyright IBM Corp. 1998 - 2005 - All Rights Reserved
  *
  */
@@ -34,6 +35,8 @@
 #include "DeviceTables.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 const le_uint16 DeviceTable::fieldMasks[]    = {0x0003, 0x000F, 0x00FF};
 const le_uint16 DeviceTable::fieldSignBits[] = {0x0002, 0x0008, 0x0080};
 const le_uint16 DeviceTable::fieldBits[]     = {     2,      4,      8};
@@ -62,3 +65,5 @@
 
     return result;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/DeviceTables.h b/src/share/native/sun/font/layout/DeviceTables.h
--- jdk/src/share/native/sun/font/layout/DeviceTables.h
+++ jdk/src/share/native/sun/font/layout/DeviceTables.h
@@ -25,6 +25,7 @@
 
 /*
  *
+ *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
  *
  */
@@ -32,10 +33,15 @@
 #ifndef __DEVICETABLES_H
 #define __DEVICETABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
-#include "GlyphIterator.h"
-#include "GlyphPositionAdjustments.h"
+
+U_NAMESPACE_BEGIN
 
 struct DeviceTable
 {
@@ -52,5 +58,7 @@
     static const le_uint16 fieldBits[];
 };
 
+U_NAMESPACE_END
+#endif
 
-#endif
+
diff --git a/src/share/native/sun/font/layout/ExtensionSubtables.cpp b/src/share/native/sun/font/layout/ExtensionSubtables.cpp
--- jdk/src/share/native/sun/font/layout/ExtensionSubtables.cpp
+++ jdk/src/share/native/sun/font/layout/ExtensionSubtables.cpp
@@ -25,7 +25,8 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 2003 - All Rights Reserved
+ *
+ * (C) Copyright IBM Corp. 2002 - All Rights Reserved
  *
  */
 
@@ -37,6 +38,9 @@
 #include "GlyphIterator.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
+
 // FIXME: should look at the format too... maybe have a sub-class for it?
 le_uint32 ExtensionSubtable::process(const LookupProcessor *lookupProcessor, le_uint16 lookupType,
                                       GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const
@@ -52,3 +56,5 @@
 
     return 0;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/ExtensionSubtables.h b/src/share/native/sun/font/layout/ExtensionSubtables.h
--- jdk/src/share/native/sun/font/layout/ExtensionSubtables.h
+++ jdk/src/share/native/sun/font/layout/ExtensionSubtables.h
@@ -25,6 +25,7 @@
 
 /*
  *
+ *
  * (C) Copyright IBM Corp. 2002-2003 - All Rights Reserved
  *
  */
@@ -32,12 +33,19 @@
 #ifndef __EXTENSIONSUBTABLES_H
 #define __EXTENSIONSUBTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 #include "GlyphSubstitutionTables.h"
 #include "LookupProcessor.h"
 #include "GlyphIterator.h"
 
+U_NAMESPACE_BEGIN
+
 struct ExtensionSubtable //: GlyphSubstitutionSubtable
 {
     le_uint16 substFormat;
@@ -48,4 +56,5 @@
                       GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/Features.cpp b/src/share/native/sun/font/layout/Features.cpp
--- jdk/src/share/native/sun/font/layout/Features.cpp
+++ jdk/src/share/native/sun/font/layout/Features.cpp
@@ -25,6 +25,7 @@
 
 /*
  *
+ *
  * (C) Copyright IBM Corp. 1998-2003 - All Rights Reserved
  *
  */
@@ -35,6 +36,8 @@
 #include "Features.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 const FeatureTable *FeatureListTable::getFeatureTable(le_uint16 featureIndex, LETag *featureTag) const
 {
     if (featureIndex >= SWAPW(featureCount)) {
@@ -79,3 +82,5 @@
     return 0;
 #endif
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/Features.h b/src/share/native/sun/font/layout/Features.h
--- jdk/src/share/native/sun/font/layout/Features.h
+++ jdk/src/share/native/sun/font/layout/Features.h
@@ -32,9 +32,16 @@
 #ifndef __FEATURES_H
 #define __FEATURES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 
+U_NAMESPACE_BEGIN
+
 struct FeatureRecord
 {
     ATag        featureTag;
@@ -53,9 +60,10 @@
     le_uint16           featureCount;
     FeatureRecord       featureRecordArray[ANY_NUMBER];
 
-    const FeatureTable *getFeatureTable(le_uint16 featureIndex, LETag *featureTag) const;
+    const FeatureTable  *getFeatureTable(le_uint16 featureIndex, LETag *featureTag) const;
 
     const FeatureTable *getFeatureTable(LETag featureTag) const;
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/GDEFMarkFilter.cpp b/src/share/native/sun/font/layout/GDEFMarkFilter.cpp
--- jdk/src/share/native/sun/font/layout/GDEFMarkFilter.cpp
+++ jdk/src/share/native/sun/font/layout/GDEFMarkFilter.cpp
@@ -34,6 +34,8 @@
 #include "GDEFMarkFilter.h"
 #include "GlyphDefinitionTables.h"
 
+U_NAMESPACE_BEGIN
+
 GDEFMarkFilter::GDEFMarkFilter(const GlyphDefinitionTableHeader *gdefTable)
 {
     classDefTable = gdefTable->getGlyphClassDefinitionTable();
@@ -50,3 +52,5 @@
 
     return glyphClass == gcdMarkGlyph;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/GDEFMarkFilter.h b/src/share/native/sun/font/layout/GDEFMarkFilter.h
--- jdk/src/share/native/sun/font/layout/GDEFMarkFilter.h
+++ jdk/src/share/native/sun/font/layout/GDEFMarkFilter.h
@@ -32,11 +32,18 @@
 #ifndef __GDEFMARKFILTER__H
 #define __GDEFMARKFILTER__H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEGlyphFilter.h"
 #include "GlyphDefinitionTables.h"
 
-class GDEFMarkFilter : public LEGlyphFilter
+U_NAMESPACE_BEGIN
+
+class GDEFMarkFilter : public UMemory, public LEGlyphFilter
 {
 private:
     const GlyphClassDefinitionTable *classDefTable;
@@ -51,5 +58,5 @@
     virtual le_bool accept(LEGlyphID glyph) const;
 };
 
-
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/GXLayoutEngine.cpp b/src/share/native/sun/font/layout/GXLayoutEngine.cpp
--- jdk/src/share/native/sun/font/layout/GXLayoutEngine.cpp
+++ jdk/src/share/native/sun/font/layout/GXLayoutEngine.cpp
@@ -23,6 +23,7 @@
  *
  */
 
+
 /*
  *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
@@ -36,8 +37,11 @@
 
 #include "MorphTables.h"
 
-GXLayoutEngine::GXLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode,
-    le_int32 languageCode, const MorphTableHeader *morphTable)
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(GXLayoutEngine)
+
+GXLayoutEngine::GXLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, const MorphTableHeader *morphTable)
     : LayoutEngine(fontInstance, scriptCode, languageCode, 0), fMorphTable(morphTable)
 {
     // nothing else to do?
@@ -49,9 +53,7 @@
 }
 
 // apply 'mort' table
-le_int32 GXLayoutEngine::computeGlyphs(const LEUnicode chars[], le_int32 offset,
-    le_int32 count, le_int32 max, le_bool rightToLeft, LEGlyphStorage &glyphStorage,
-    LEErrorCode &success)
+le_int32 GXLayoutEngine::computeGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft, LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
@@ -74,9 +76,8 @@
 }
 
 // apply positional tables
-void GXLayoutEngine::adjustGlyphPositions(const LEUnicode chars[],
-    le_int32 offset, le_int32 count, le_bool /*reverse*/,
-    LEGlyphStorage &/*glyphStorage*/, LEErrorCode &success)
+void GXLayoutEngine::adjustGlyphPositions(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool /*reverse*/,
+                                          LEGlyphStorage &/*glyphStorage*/, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return;
@@ -89,3 +90,5 @@
 
     // FIXME: no positional processing yet...
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/GXLayoutEngine.h b/src/share/native/sun/font/layout/GXLayoutEngine.h
--- jdk/src/share/native/sun/font/layout/GXLayoutEngine.h
+++ jdk/src/share/native/sun/font/layout/GXLayoutEngine.h
@@ -23,6 +23,7 @@
  *
  */
 
+
 /*
  *
  * (C) Copyright IBM Corp. 1998-2004 - All Rights Reserved
@@ -37,6 +38,8 @@
 
 #include "MorphTables.h"
 
+U_NAMESPACE_BEGIN
+
 class LEFontInstance;
 class LEGlyphStorage;
 
@@ -70,8 +73,7 @@
      *
      * @internal
      */
-    GXLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode,
-        le_int32 languageCode, const MorphTableHeader *morphTable);
+    GXLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, const MorphTableHeader *morphTable);
 
     /**
      * The destructor, virtual for correct polymorphic invocation.
@@ -80,6 +82,20 @@
      */
     virtual ~GXLayoutEngine();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 protected:
 
     /**
@@ -99,10 +115,8 @@
      * @param offset - the index of the first character to process
      * @param count - the number of characters to process
      * @param max - the number of characters in the input context
-     * @param rightToLeft - <code>TRUE</code> if the text is in a
-     *    right to left directional run
-     * @param glyphStorage - the glyph storage object. The glyph
-     *    and char index arrays will be set.
+     * @param rightToLeft - <code>TRUE</code> if the text is in a right to left directional run
+     * @param glyphStorage - the glyph storage object. The glyph and char index arrays will be set.
      *
      * Output parameters:
      * @param success - set to an error code if the operation fails
@@ -111,8 +125,7 @@
      *
      * @internal
      */
-    virtual le_int32 computeGlyphs(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_int32 max, le_bool rightToLeft,
+    virtual le_int32 computeGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
         LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     /**
@@ -120,16 +133,18 @@
      * 'kern', 'trak', 'bsln', 'opbd' and 'just' tables.
      *
      * Input parameters:
-     * @param glyphStorage - the object holding the glyph storage.
-     *     The positions will be updated as needed.
+     * @param glyphStorage - the object holding the glyph storage. The positions will be updated as needed.
      *
      * Output parameters:
      * @param success - set to an error code if the operation fails
      *
      * @internal
      */
-    virtual void adjustGlyphPositions(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_bool reverse, LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual void adjustGlyphPositions(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse,
+                                      LEGlyphStorage &glyphStorage, LEErrorCode &success);
+
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/GlyphDefinitionTables.cpp b/src/share/native/sun/font/layout/GlyphDefinitionTables.cpp
--- jdk/src/share/native/sun/font/layout/GlyphDefinitionTables.cpp
+++ jdk/src/share/native/sun/font/layout/GlyphDefinitionTables.cpp
@@ -34,6 +34,8 @@
 #include "GlyphDefinitionTables.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 const GlyphClassDefinitionTable *GlyphDefinitionTableHeader::getGlyphClassDefinitionTable() const
 {
     return (const GlyphClassDefinitionTable *) ((char *) this + SWAPW(glyphClassDefOffset));
@@ -53,3 +55,5 @@
 {
     return (const MarkAttachClassDefinitionTable *) ((char *) this + SWAPW(MarkAttachClassDefOffset));
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/GlyphDefinitionTables.h b/src/share/native/sun/font/layout/GlyphDefinitionTables.h
--- jdk/src/share/native/sun/font/layout/GlyphDefinitionTables.h
+++ jdk/src/share/native/sun/font/layout/GlyphDefinitionTables.h
@@ -32,10 +32,17 @@
 #ifndef __GLYPHDEFINITIONTABLES_H
 #define __GLYPHDEFINITIONTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 #include "ClassDefinitionTables.h"
 
+U_NAMESPACE_BEGIN
+
 typedef ClassDefinitionTable GlyphClassDefinitionTable;
 
 enum GlyphClassDefinitions
@@ -110,4 +117,5 @@
     const MarkAttachClassDefinitionTable *getMarkAttachClassDefinitionTable() const;
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/GlyphIterator.cpp b/src/share/native/sun/font/layout/GlyphIterator.cpp
--- jdk/src/share/native/sun/font/layout/GlyphIterator.cpp
+++ jdk/src/share/native/sun/font/layout/GlyphIterator.cpp
@@ -38,11 +38,10 @@
 #include "Lookups.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
 
-GlyphIterator::GlyphIterator(LEGlyphStorage &theGlyphStorage,
-    GlyphPositionAdjustments *theGlyphPositionAdjustments,
-    le_bool rightToLeft, le_uint16 theLookupFlags, FeatureMask theFeatureMask,
-    const GlyphDefinitionTableHeader *theGlyphDefinitionTableHeader)
+GlyphIterator::GlyphIterator(LEGlyphStorage &theGlyphStorage, GlyphPositionAdjustments *theGlyphPositionAdjustments, le_bool rightToLeft, le_uint16 theLookupFlags,
+                             FeatureMask theFeatureMask, const GlyphDefinitionTableHeader *theGlyphDefinitionTableHeader)
   : direction(1), position(-1), nextLimit(-1), prevLimit(-1),
     glyphStorage(theGlyphStorage), glyphPositionAdjustments(theGlyphPositionAdjustments),
     srcIndex(-1), destIndex(-1), lookupFlags(theLookupFlags), featureMask(theFeatureMask),
@@ -262,8 +261,8 @@
     glyphPositionAdjustments->setBaseOffset(position, baseOffset);
 }
 
-void GlyphIterator::adjustCurrGlyphPositionAdjustment(float xPlacementAdjust,
-    float yPlacementAdjust, float xAdvanceAdjust, float yAdvanceAdjust)
+void GlyphIterator::adjustCurrGlyphPositionAdjustment(float xPlacementAdjust, float yPlacementAdjust,
+                                                      float xAdvanceAdjust, float yAdvanceAdjust)
 {
     if (direction < 0) {
         if (position <= nextLimit || position >= prevLimit) {
@@ -281,8 +280,8 @@
     glyphPositionAdjustments->adjustYAdvance(position, yAdvanceAdjust);
 }
 
-void GlyphIterator::setCurrGlyphPositionAdjustment(float xPlacementAdjust,
-    float yPlacementAdjust, float xAdvanceAdjust, float yAdvanceAdjust)
+void GlyphIterator::setCurrGlyphPositionAdjustment(float xPlacementAdjust, float yPlacementAdjust,
+                                                      float xAdvanceAdjust, float yAdvanceAdjust)
 {
     if (direction < 0) {
         if (position <= nextLimit || position >= prevLimit) {
@@ -484,10 +483,11 @@
 
     do {
         newPosition -= direction;
-    } while (newPosition != prevLimit && glyphStorage[newPosition] != 0xFFFE &&
-        filterGlyph(newPosition));
+    } while (newPosition != prevLimit && glyphStorage[newPosition] != 0xFFFE && filterGlyph(newPosition));
 
     position = newPosition;
 
     return position != prevLimit;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/GlyphIterator.h b/src/share/native/sun/font/layout/GlyphIterator.h
--- jdk/src/share/native/sun/font/layout/GlyphIterator.h
+++ jdk/src/share/native/sun/font/layout/GlyphIterator.h
@@ -32,26 +32,24 @@
 #ifndef __GLYPHITERATOR_H
 #define __GLYPHITERATOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 #include "GlyphDefinitionTables.h"
 
-struct InsertionRecord
-{
-    InsertionRecord *next;
-    le_int32 position;
-    le_int32 count;
-    LEGlyphID glyphs[ANY_NUMBER];
-};
+U_NAMESPACE_BEGIN
 
 class LEGlyphStorage;
 class GlyphPositionAdjustments;
 
-class GlyphIterator {
+class GlyphIterator : public UMemory {
 public:
-    GlyphIterator(LEGlyphStorage &theGlyphStorage, GlyphPositionAdjustments *theGlyphPositionAdjustments,
-        le_bool rightToLeft, le_uint16 theLookupFlags, FeatureMask theFeatureMask,
-        const GlyphDefinitionTableHeader *theGlyphDefinitionTableHeader);
+    GlyphIterator(LEGlyphStorage &theGlyphStorage, GlyphPositionAdjustments *theGlyphPositionAdjustments, le_bool rightToLeft, le_uint16 theLookupFlags,
+        FeatureMask theFeatureMask, const GlyphDefinitionTableHeader *theGlyphDefinitionTableHeader);
 
     GlyphIterator(GlyphIterator &that);
 
@@ -122,4 +120,5 @@
     GlyphIterator &operator=(const GlyphIterator &other); // forbid copying of this class
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/GlyphLookupTables.cpp b/src/share/native/sun/font/layout/GlyphLookupTables.cpp
--- jdk/src/share/native/sun/font/layout/GlyphLookupTables.cpp
+++ jdk/src/share/native/sun/font/layout/GlyphLookupTables.cpp
@@ -35,6 +35,8 @@
 #include "GlyphLookupTables.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 le_bool GlyphLookupTableHeader::coversScript(LETag scriptTag) const
 {
     const ScriptListTable *scriptListTable = (const ScriptListTable *) ((char *)this + SWAPW(scriptListOffset));
@@ -51,3 +53,5 @@
     // Note: don't have to SWAPW langSysTable->featureCount to check for non-zero.
     return langSysTable != NULL && langSysTable->featureCount != 0;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/GlyphLookupTables.h b/src/share/native/sun/font/layout/GlyphLookupTables.h
--- jdk/src/share/native/sun/font/layout/GlyphLookupTables.h
+++ jdk/src/share/native/sun/font/layout/GlyphLookupTables.h
@@ -32,9 +32,16 @@
 #ifndef __GLYPHLOOKUPTABLES_H
 #define __GLYPHLOOKUPTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 
+U_NAMESPACE_BEGIN
+
 struct GlyphLookupTableHeader
 {
     fixed32 version;
@@ -46,4 +53,7 @@
     le_bool coversScriptAndLanguage(LETag scriptTag, LETag languageTag, le_bool exactMatch = FALSE) const;
 };
 
+U_NAMESPACE_END
+
 #endif
+
diff --git a/src/share/native/sun/font/layout/GlyphPositionAdjustments.cpp b/src/share/native/sun/font/layout/GlyphPositionAdjustments.cpp
--- jdk/src/share/native/sun/font/layout/GlyphPositionAdjustments.cpp
+++ jdk/src/share/native/sun/font/layout/GlyphPositionAdjustments.cpp
@@ -34,6 +34,8 @@
 #include "LEGlyphStorage.h"
 #include "LEFontInstance.h"
 
+U_NAMESPACE_BEGIN
+
 #define CHECK_ALLOCATE_ARRAY(array, type, size) \
     if (array == NULL) { \
         array = (type *) new type[size]; \
@@ -185,3 +187,5 @@
 
     return NULL;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/GlyphPositionAdjustments.h b/src/share/native/sun/font/layout/GlyphPositionAdjustments.h
--- jdk/src/share/native/sun/font/layout/GlyphPositionAdjustments.h
+++ jdk/src/share/native/sun/font/layout/GlyphPositionAdjustments.h
@@ -32,16 +32,23 @@
 #ifndef __GLYPHPOSITIONADJUSTMENTS_H
 #define __GLYPHPOSITIONADJUSTMENTS_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 class LEFontInstance;
 
-class GlyphPositionAdjustments
+class GlyphPositionAdjustments : public UMemory
 {
 private:
-    class Adjustment {
+    class Adjustment : public UMemory {
     public:
 
         inline Adjustment();
@@ -78,7 +85,7 @@
         // allow copying of this class because all of its fields are simple types
     };
 
-    class EntryExitPoint
+    class EntryExitPoint : public UMemory
     {
     public:
         inline EntryExitPoint();
@@ -144,14 +151,11 @@
     inline void adjustXAdvance(le_int32 index, float xAdjustment);
     inline void adjustYAdvance(le_int32 index, float yAdjustment);
 
-    void setEntryPoint(le_int32 index, LEPoint &newEntryPoint,
-        le_bool baselineIsLogicalEnd);
-    void setExitPoint(le_int32 index, LEPoint &newExitPoint,
-        le_bool baselineIsLogicalEnd);
+    void setEntryPoint(le_int32 index, LEPoint &newEntryPoint, le_bool baselineIsLogicalEnd);
+    void setExitPoint(le_int32 index, LEPoint &newExitPoint, le_bool baselineIsLogicalEnd);
     void setCursiveGlyph(le_int32 index, le_bool baselineIsLogicalEnd);
 
-    void applyCursiveAdjustments(LEGlyphStorage &glyphStorage, le_bool rightToLeft,
-        const LEFontInstance *fontInstance);
+    void applyCursiveAdjustments(LEGlyphStorage &glyphStorage, le_bool rightToLeft, const LEFontInstance *fontInstance);
 };
 
 inline GlyphPositionAdjustments::Adjustment::Adjustment()
@@ -160,10 +164,8 @@
     // nothing else to do!
 }
 
-inline GlyphPositionAdjustments::Adjustment::Adjustment(float xPlace, float yPlace,
-    float xAdv, float yAdv, le_int32 baseOff)
-  : xPlacement(xPlace), yPlacement(yPlace), xAdvance(xAdv), yAdvance(yAdv),
-    baseOffset(baseOff)
+inline GlyphPositionAdjustments::Adjustment::Adjustment(float xPlace, float yPlace, float xAdv, float yAdv, le_int32 baseOff)
+  : xPlacement(xPlace), yPlacement(yPlace), xAdvance(xAdv), yAdvance(yAdv), baseOffset(baseOff)
 {
     // nothing else to do!
 }
@@ -246,7 +248,7 @@
 inline GlyphPositionAdjustments::EntryExitPoint::EntryExitPoint()
     : fFlags(0)
 {
-    fEntryPoint.fX = fEntryPoint.fY = fExitPoint.fX = fEntryPoint.fY = 0;
+    fEntryPoint.fX = fEntryPoint.fY = fExitPoint.fX = fExitPoint.fY = 0;
 }
 
 inline GlyphPositionAdjustments::EntryExitPoint::~EntryExitPoint()
@@ -264,12 +266,10 @@
     return (fFlags & EEF_BASELINE_IS_LOGICAL_END) != 0;
 }
 
-inline void GlyphPositionAdjustments::EntryExitPoint::setEntryPoint(
-    LEPoint &newEntryPoint, le_bool baselineIsLogicalEnd)
+inline void GlyphPositionAdjustments::EntryExitPoint::setEntryPoint(LEPoint &newEntryPoint, le_bool baselineIsLogicalEnd)
 {
     if (baselineIsLogicalEnd) {
-        fFlags |= (EEF_HAS_ENTRY_POINT | EEF_IS_CURSIVE_GLYPH |
-        EEF_BASELINE_IS_LOGICAL_END);
+        fFlags |= (EEF_HAS_ENTRY_POINT | EEF_IS_CURSIVE_GLYPH | EEF_BASELINE_IS_LOGICAL_END);
     } else {
         fFlags |= (EEF_HAS_ENTRY_POINT | EEF_IS_CURSIVE_GLYPH);
     }
@@ -277,12 +277,10 @@
     fEntryPoint = newEntryPoint;
 }
 
-inline void GlyphPositionAdjustments::EntryExitPoint::setExitPoint(
-    LEPoint &newExitPoint, le_bool baselineIsLogicalEnd)
+inline void GlyphPositionAdjustments::EntryExitPoint::setExitPoint(LEPoint &newExitPoint, le_bool baselineIsLogicalEnd)
 {
     if (baselineIsLogicalEnd) {
-        fFlags |= (EEF_HAS_EXIT_POINT | EEF_IS_CURSIVE_GLYPH |
-            EEF_BASELINE_IS_LOGICAL_END);
+        fFlags |= (EEF_HAS_EXIT_POINT | EEF_IS_CURSIVE_GLYPH | EEF_BASELINE_IS_LOGICAL_END);
     } else {
         fFlags |= (EEF_HAS_EXIT_POINT | EEF_IS_CURSIVE_GLYPH);
     }
@@ -290,8 +288,7 @@
     fExitPoint  = newExitPoint;
 }
 
-inline void GlyphPositionAdjustments::EntryExitPoint::setCursiveGlyph(
-    le_bool baselineIsLogicalEnd)
+inline void GlyphPositionAdjustments::EntryExitPoint::setCursiveGlyph(le_bool baselineIsLogicalEnd)
 {
     if (baselineIsLogicalEnd) {
         fFlags |= (EEF_IS_CURSIVE_GLYPH | EEF_BASELINE_IS_LOGICAL_END);
@@ -386,4 +383,5 @@
     return fEntryExitPoints != NULL;
 }
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/GlyphPositioningTables.cpp b/src/share/native/sun/font/layout/GlyphPositioningTables.cpp
--- jdk/src/share/native/sun/font/layout/GlyphPositioningTables.cpp
+++ jdk/src/share/native/sun/font/layout/GlyphPositioningTables.cpp
@@ -24,7 +24,6 @@
  */
 
 /*
- *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
  *
  */
@@ -40,18 +39,18 @@
 #include "LEGlyphStorage.h"
 #include "GlyphPositionAdjustments.h"
 
-void GlyphPositioningTableHeader::process(LEGlyphStorage &glyphStorage,
-    GlyphPositionAdjustments *glyphPositionAdjustments, le_bool rightToLeft,
-    LETag scriptTag, LETag languageTag,
-    const GlyphDefinitionTableHeader *glyphDefinitionTableHeader,
-    const LEFontInstance *fontInstance,
-    const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder) const
+U_NAMESPACE_BEGIN
+
+void GlyphPositioningTableHeader::process(LEGlyphStorage &glyphStorage, GlyphPositionAdjustments *glyphPositionAdjustments, le_bool rightToLeft,
+                                          LETag scriptTag, LETag languageTag,
+                                          const GlyphDefinitionTableHeader *glyphDefinitionTableHeader,
+                                          const LEFontInstance *fontInstance, const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder) const
 {
-    GlyphPositioningLookupProcessor processor(this, scriptTag, languageTag, featureMap,
-        featureMapCount, featureOrder);
+    GlyphPositioningLookupProcessor processor(this, scriptTag, languageTag, featureMap, featureMapCount, featureOrder);
 
-    processor.process(glyphStorage, glyphPositionAdjustments, rightToLeft,
-                      glyphDefinitionTableHeader, fontInstance);
+    processor.process(glyphStorage, glyphPositionAdjustments, rightToLeft, glyphDefinitionTableHeader, fontInstance);
 
     glyphPositionAdjustments->applyCursiveAdjustments(glyphStorage, rightToLeft, fontInstance);
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/GlyphPositioningTables.h b/src/share/native/sun/font/layout/GlyphPositioningTables.h
--- jdk/src/share/native/sun/font/layout/GlyphPositioningTables.h
+++ jdk/src/share/native/sun/font/layout/GlyphPositioningTables.h
@@ -24,7 +24,6 @@
  */
 
 /*
- *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
  *
  */
@@ -32,11 +31,18 @@
 #ifndef __GLYPHPOSITIONINGTABLES_H
 #define __GLYPHPOSITIONINGTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 #include "Lookups.h"
 #include "GlyphLookupTables.h"
 
+U_NAMESPACE_BEGIN
+
 class  LEFontInstance;
 class  LEGlyphStorage;
 class  LEGlyphFilter;
@@ -45,12 +51,10 @@
 
 struct GlyphPositioningTableHeader : public GlyphLookupTableHeader
 {
-    void    process(LEGlyphStorage &glyphStorage,
-                GlyphPositionAdjustments *glyphPositionAdjustments,
+    void    process(LEGlyphStorage &glyphStorage, GlyphPositionAdjustments *glyphPositionAdjustments,
                 le_bool rightToLeft, LETag scriptTag, LETag languageTag,
                 const GlyphDefinitionTableHeader *glyphDefinitionTableHeader,
-                const LEFontInstance *fontInstance,
-                const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder) const;
+                const LEFontInstance *fontInstance, const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder) const;
 };
 
 enum GlyphPositioningSubtableTypes
@@ -68,4 +72,5 @@
 
 typedef LookupSubtable GlyphPositioningSubtable;
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/GlyphPosnLookupProc.cpp b/src/share/native/sun/font/layout/GlyphPosnLookupProc.cpp
--- jdk/src/share/native/sun/font/layout/GlyphPosnLookupProc.cpp
+++ jdk/src/share/native/sun/font/layout/GlyphPosnLookupProc.cpp
@@ -24,7 +24,6 @@
  */
 
 /*
- *
  * (C) Copyright IBM Corp. 1998 - 2005 - All Rights Reserved
  *
  */
@@ -50,6 +49,8 @@
 #include "GlyphPosnLookupProc.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 // Aside from the names, the contextual positioning subtables are
 // the same as the contextual substitution subtables.
 typedef ContextualSubstitutionSubtable ContextualPositioningSubtable;
@@ -57,8 +58,7 @@
 
 GlyphPositioningLookupProcessor::GlyphPositioningLookupProcessor(
         const GlyphPositioningTableHeader *glyphPositioningTableHeader,
-        LETag scriptTag, LETag languageTag,
-        const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder)
+        LETag scriptTag, LETag languageTag, const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder)
     : LookupProcessor(
                       (char *) glyphPositioningTableHeader,
                       SWAPW(glyphPositioningTableHeader->scriptListOffset),
@@ -166,3 +166,5 @@
 GlyphPositioningLookupProcessor::~GlyphPositioningLookupProcessor()
 {
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/GlyphPosnLookupProc.h b/src/share/native/sun/font/layout/GlyphPosnLookupProc.h
--- jdk/src/share/native/sun/font/layout/GlyphPosnLookupProc.h
+++ jdk/src/share/native/sun/font/layout/GlyphPosnLookupProc.h
@@ -24,7 +24,6 @@
  */
 
 /*
- *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
  *
  */
@@ -32,6 +31,11 @@
 #ifndef __GLYPHPOSITIONINGLOOKUPPROCESSOR_H
 #define __GLYPHPOSITIONINGLOOKUPPROCESSOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEFontInstance.h"
 #include "OpenTypeTables.h"
@@ -42,12 +46,13 @@
 #include "GlyphIterator.h"
 #include "LookupProcessor.h"
 
+U_NAMESPACE_BEGIN
+
 class GlyphPositioningLookupProcessor : public LookupProcessor
 {
 public:
     GlyphPositioningLookupProcessor(const GlyphPositioningTableHeader *glyphPositioningTableHeader,
-        LETag scriptTag, LETag languageTag,
-        const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder);
+        LETag scriptTag, LETag languageTag, const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder);
 
     virtual ~GlyphPositioningLookupProcessor();
 
@@ -63,4 +68,5 @@
     GlyphPositioningLookupProcessor &operator=(const GlyphPositioningLookupProcessor &other); // forbid copying of this class
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/GlyphSubstLookupProc.cpp b/src/share/native/sun/font/layout/GlyphSubstLookupProc.cpp
--- jdk/src/share/native/sun/font/layout/GlyphSubstLookupProc.cpp
+++ jdk/src/share/native/sun/font/layout/GlyphSubstLookupProc.cpp
@@ -48,17 +48,17 @@
 #include "GlyphSubstLookupProc.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 GlyphSubstitutionLookupProcessor::GlyphSubstitutionLookupProcessor(
         const GlyphSubstitutionTableHeader *glyphSubstitutionTableHeader,
-        LETag scriptTag, LETag languageTag, const LEGlyphFilter *filter,
-        const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder)
+        LETag scriptTag, LETag languageTag, const LEGlyphFilter *filter, const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder)
     : LookupProcessor(
                       (char *) glyphSubstitutionTableHeader,
                       SWAPW(glyphSubstitutionTableHeader->scriptListOffset),
                       SWAPW(glyphSubstitutionTableHeader->featureListOffset),
                       SWAPW(glyphSubstitutionTableHeader->lookupListOffset),
-                      scriptTag, languageTag, featureMap, featureMapCount, featureOrder)
-    , fFilter(filter)
+                      scriptTag, languageTag, featureMap, featureMapCount, featureOrder), fFilter(filter)
 {
     // anything?
 }
@@ -143,3 +143,5 @@
 GlyphSubstitutionLookupProcessor::~GlyphSubstitutionLookupProcessor()
 {
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/GlyphSubstLookupProc.h b/src/share/native/sun/font/layout/GlyphSubstLookupProc.h
--- jdk/src/share/native/sun/font/layout/GlyphSubstLookupProc.h
+++ jdk/src/share/native/sun/font/layout/GlyphSubstLookupProc.h
@@ -24,7 +24,6 @@
  */
 
 /*
- *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
  *
  */
@@ -32,6 +31,11 @@
 #ifndef __GLYPHSUBSTITUTIONLOOKUPPROCESSOR_H
 #define __GLYPHSUBSTITUTIONLOOKUPPROCESSOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEGlyphFilter.h"
 #include "LEFontInstance.h"
@@ -43,12 +47,13 @@
 #include "GlyphIterator.h"
 #include "LookupProcessor.h"
 
+U_NAMESPACE_BEGIN
+
 class GlyphSubstitutionLookupProcessor : public LookupProcessor
 {
 public:
     GlyphSubstitutionLookupProcessor(const GlyphSubstitutionTableHeader *glyphSubstitutionTableHeader,
-        LETag scriptTag, LETag languageTag, const LEGlyphFilter *filter,
-        const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder);
+        LETag scriptTag, LETag languageTag, const LEGlyphFilter *filter, const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder);
 
     virtual ~GlyphSubstitutionLookupProcessor();
 
@@ -65,4 +70,5 @@
     GlyphSubstitutionLookupProcessor &operator=(const GlyphSubstitutionLookupProcessor &other); // forbid copying of this class
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/GlyphSubstitutionTables.cpp b/src/share/native/sun/font/layout/GlyphSubstitutionTables.cpp
--- jdk/src/share/native/sun/font/layout/GlyphSubstitutionTables.cpp
+++ jdk/src/share/native/sun/font/layout/GlyphSubstitutionTables.cpp
@@ -40,14 +40,15 @@
 #include "LEGlyphStorage.h"
 #include "LESwaps.h"
 
-le_int32 GlyphSubstitutionTableHeader::process(LEGlyphStorage &glyphStorage,
-    le_bool rightToLeft, LETag scriptTag, LETag languageTag,
-    const GlyphDefinitionTableHeader *glyphDefinitionTableHeader,
-    const LEGlyphFilter *filter, const FeatureMap *featureMap,
-    le_int32 featureMapCount, le_bool featureOrder) const
+U_NAMESPACE_BEGIN
+
+le_int32 GlyphSubstitutionTableHeader::process(LEGlyphStorage &glyphStorage, le_bool rightToLeft, LETag scriptTag, LETag languageTag,
+                                           const GlyphDefinitionTableHeader *glyphDefinitionTableHeader,
+                                           const LEGlyphFilter *filter, const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder) const
 {
-    GlyphSubstitutionLookupProcessor processor(this, scriptTag, languageTag, filter, featureMap,
-        featureMapCount, featureOrder);
+    GlyphSubstitutionLookupProcessor processor(this, scriptTag, languageTag, filter, featureMap, featureMapCount, featureOrder);
 
     return processor.process(glyphStorage, NULL, rightToLeft, glyphDefinitionTableHeader, NULL);
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/GlyphSubstitutionTables.h b/src/share/native/sun/font/layout/GlyphSubstitutionTables.h
--- jdk/src/share/native/sun/font/layout/GlyphSubstitutionTables.h
+++ jdk/src/share/native/sun/font/layout/GlyphSubstitutionTables.h
@@ -32,22 +32,27 @@
 #ifndef __GLYPHSUBSTITUTIONTABLES_H
 #define __GLYPHSUBSTITUTIONTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 #include "Lookups.h"
 #include "GlyphLookupTables.h"
 
+U_NAMESPACE_BEGIN
+
 class  LEGlyphStorage;
 class  LEGlyphFilter;
 struct GlyphDefinitionTableHeader;
 
 struct GlyphSubstitutionTableHeader : public GlyphLookupTableHeader
 {
-    le_int32 process(LEGlyphStorage &glyphStorage,
-        le_bool rightToLeft, LETag scriptTag, LETag languageTag,
-        const GlyphDefinitionTableHeader *glyphDefinitionTableHeader,
-        const LEGlyphFilter *filter, const FeatureMap *featureMap,
-        le_int32 featureMapCount, le_bool featureOrder) const;
+    le_int32    process(LEGlyphStorage &glyphStorage, le_bool rightToLeft, LETag scriptTag, LETag languageTag,
+                        const GlyphDefinitionTableHeader *glyphDefinitionTableHeader, const LEGlyphFilter *filter,
+                        const FeatureMap *featureMap, le_int32 featureMapCount, le_bool featureOrder) const;
 };
 
 enum GlyphSubstitutionSubtableTypes
@@ -64,4 +69,5 @@
 
 typedef LookupSubtable GlyphSubstitutionSubtable;
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/HanLayoutEngine.cpp b/src/share/native/sun/font/layout/HanLayoutEngine.cpp
--- jdk/src/share/native/sun/font/layout/HanLayoutEngine.cpp
+++ jdk/src/share/native/sun/font/layout/HanLayoutEngine.cpp
@@ -24,7 +24,6 @@
  */
 
 /*
- *
  * HanLayoutEngine.cpp: OpenType processing for Han fonts.
  *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved.
@@ -41,6 +40,10 @@
 #include "LEGlyphStorage.h"
 #include "OpenTypeTables.h"
 
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(HanOpenTypeLayoutEngine)
+
 #define loclFeatureTag LE_LOCL_FEATURE_TAG
 #define smplFeatureTag LE_SMPL_FEATURE_TAG
 #define tradFeatureTag LE_TRAD_FEATURE_TAG
@@ -60,9 +63,8 @@
 
 #define features (loclFeatureMask)
 
-HanOpenTypeLayoutEngine::HanOpenTypeLayoutEngine(const LEFontInstance *fontInstance,
-    le_int32 scriptCode,  le_int32 languageCode, le_int32 typoFlags,
-    const GlyphSubstitutionTableHeader *gsubTable)
+HanOpenTypeLayoutEngine::HanOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                        le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable)
     : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable)
 {
     fFeatureMap      = featureMap;
@@ -74,9 +76,8 @@
     // nothing to do
 }
 
-le_int32 HanOpenTypeLayoutEngine::characterProcessing(const LEUnicode chars[],
-    le_int32 offset, le_int32 count, le_int32 max, le_bool /*rightToLeft*/,
-    LEUnicode *&/*outChars*/, LEGlyphStorage &glyphStorage, LEErrorCode &success)
+le_int32 HanOpenTypeLayoutEngine::characterProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool /*rightToLeft*/,
+        LEUnicode *&/*outChars*/, LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
@@ -104,3 +105,5 @@
 
     return count;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/HanLayoutEngine.h b/src/share/native/sun/font/layout/HanLayoutEngine.h
--- jdk/src/share/native/sun/font/layout/HanLayoutEngine.h
+++ jdk/src/share/native/sun/font/layout/HanLayoutEngine.h
@@ -23,8 +23,8 @@
  *
  */
 
+
 /*
- *
  * HanLayoutEngine.h: OpenType processing for Han fonts.
  *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved.
@@ -40,6 +40,8 @@
 
 #include "GlyphSubstitutionTables.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 /**
@@ -69,9 +71,8 @@
      *
      * @internal
      */
-    HanOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode,
-        le_int32 languageCode,
-        le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable);
+    HanOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                            le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable);
 
 
     /**
@@ -81,6 +82,20 @@
      */
     virtual ~HanOpenTypeLayoutEngine();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 protected:
 
     /**
@@ -92,10 +107,8 @@
      * @param offset - the index of the first character to process
      * @param count - the number of characters to process
      * @param max - the number of characters in the input context
-     * @param rightToLeft - <code>TRUE</code> if the characters are in a
-     *    right to left directional run
-     * @param glyphStorage - the object holding the glyph storage. The char
-     *    index and auxillary data arrays will be set.
+     * @param rightToLeft - <code>TRUE</code> if the characters are in a right to left directional run
+     * @param glyphStorage - the object holding the glyph storage. The char index and auxillary data arrays will be set.
      *
      * Output parameters:
      * @param outChars - the output character arrayt
@@ -107,9 +120,10 @@
      *
      * @internal
      */
-    virtual le_int32 characterProcessing(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_int32 max, le_bool rightToLeft,
-        LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual le_int32 characterProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+            LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success);
+
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/IndicClassTables.cpp b/src/share/native/sun/font/layout/IndicClassTables.cpp
--- jdk/src/share/native/sun/font/layout/IndicClassTables.cpp
+++ jdk/src/share/native/sun/font/layout/IndicClassTables.cpp
@@ -35,6 +35,8 @@
 #include "OpenTypeUtilities.h"
 #include "IndicReordering.h"
 
+U_NAMESPACE_BEGIN
+
 // Split matra table indices
 #define _x1  (1 << CF_INDEX_SHIFT)
 #define _x2  (2 << CF_INDEX_SHIFT)
@@ -385,3 +387,5 @@
 
     return classTable->getWorstCaseExpansion();
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/IndicLayoutEngine.cpp b/src/share/native/sun/font/layout/IndicLayoutEngine.cpp
--- jdk/src/share/native/sun/font/layout/IndicLayoutEngine.cpp
+++ jdk/src/share/native/sun/font/layout/IndicLayoutEngine.cpp
@@ -45,20 +45,20 @@
 
 #include "IndicReordering.h"
 
-IndicOpenTypeLayoutEngine::IndicOpenTypeLayoutEngine(const LEFontInstance *fontInstance,
-    le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags,
-    const GlyphSubstitutionTableHeader *gsubTable)
-    : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable),
-    fMPreFixups(NULL)
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(IndicOpenTypeLayoutEngine)
+
+IndicOpenTypeLayoutEngine::IndicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                    le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable)
+    : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable), fMPreFixups(NULL)
 {
     fFeatureMap = IndicReordering::getFeatureMap(fFeatureMapCount);
     fFeatureOrder = TRUE;
 }
 
-IndicOpenTypeLayoutEngine::IndicOpenTypeLayoutEngine(const LEFontInstance *fontInstance,
-    le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags)
-    : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags),
-    fMPreFixups(NULL)
+IndicOpenTypeLayoutEngine::IndicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags)
+    : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags), fMPreFixups(NULL)
 {
     fFeatureMap = IndicReordering::getFeatureMap(fFeatureMapCount);
     fFeatureOrder = TRUE;
@@ -71,9 +71,8 @@
 
 // Input: characters, tags
 // Output: glyphs, char indices
-le_int32 IndicOpenTypeLayoutEngine::glyphProcessing(const LEUnicode chars[],
-    le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
-    LEGlyphStorage &glyphStorage, LEErrorCode &success)
+le_int32 IndicOpenTypeLayoutEngine::glyphProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+                    LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
@@ -84,8 +83,7 @@
         return 0;
     }
 
-    le_int32 retCount = OpenTypeLayoutEngine::glyphProcessing(chars, offset, count, max,
-        rightToLeft, glyphStorage, success);
+    le_int32 retCount = OpenTypeLayoutEngine::glyphProcessing(chars, offset, count, max, rightToLeft, glyphStorage, success);
 
     if (LE_FAILURE(success)) {
         return 0;
@@ -99,9 +97,8 @@
 // Input: characters
 // Output: characters, char indices, tags
 // Returns: output character count
-le_int32 IndicOpenTypeLayoutEngine::characterProcessing(const LEUnicode chars[],
-    le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
-    LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success)
+le_int32 IndicOpenTypeLayoutEngine::characterProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+        LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
@@ -131,9 +128,10 @@
 
     // NOTE: assumes this allocates featureTags...
     // (probably better than doing the worst case stuff here...)
-    le_int32 outCharCount = IndicReordering::reorder(&chars[offset], count, fScriptCode,
-        outChars, glyphStorage, &fMPreFixups);
+    le_int32 outCharCount = IndicReordering::reorder(&chars[offset], count, fScriptCode, outChars, glyphStorage, &fMPreFixups);
+
     glyphStorage.adoptGlyphCount(outCharCount);
-
     return outCharCount;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/IndicLayoutEngine.h b/src/share/native/sun/font/layout/IndicLayoutEngine.h
--- jdk/src/share/native/sun/font/layout/IndicLayoutEngine.h
+++ jdk/src/share/native/sun/font/layout/IndicLayoutEngine.h
@@ -43,6 +43,8 @@
 #include "GlyphDefinitionTables.h"
 #include "GlyphPositioningTables.h"
 
+U_NAMESPACE_BEGIN
+
 class MPreFixups;
 class LEGlyphStorage;
 
@@ -77,9 +79,8 @@
      *
      * @internal
      */
-    IndicOpenTypeLayoutEngine(const LEFontInstance *fontInstance,
-        le_int32 scriptCode, le_int32 languageCode,
-        le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable);
+    IndicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                            le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable);
 
     /**
      * This constructor is used when the font requires a "canned" GSUB table which can't be known
@@ -94,8 +95,8 @@
      *
      * @internal
      */
-    IndicOpenTypeLayoutEngine(const LEFontInstance *fontInstance,
-        le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags);
+    IndicOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                              le_int32 typoFlags);
 
     /**
      * The destructor, virtual for correct polymorphic invocation.
@@ -104,6 +105,20 @@
      */
    virtual ~IndicOpenTypeLayoutEngine();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 protected:
 
     /**
@@ -117,10 +132,9 @@
      * @param offset - the index of the first character to process
      * @param count - the number of characters to process
      * @param max - the number of characters in the input context
-     * @param rightToLeft - <code>TRUE</code> if the characters are in a
-     *    right to left directional run
-     * @param glyphStorage - the glyph storage object. The glyph and character
-     *    index arrays will be set. The auxillary data array will be set to the feature tags.
+     * @param rightToLeft - <code>TRUE</code> if the characters are in a right to left directional run
+     * @param glyphStorage - the glyph storage object. The glyph and character index arrays will be set.
+     *                       the auxillary data array will be set to the feature tags.
      *
      * Output parameters:
      * @param success - set to an error code if the operation fails
@@ -129,9 +143,8 @@
      *
      * @internal
      */
-    virtual le_int32 characterProcessing(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_int32 max, le_bool rightToLeft,
-        LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual le_int32 characterProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+            LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     /**
      * This method does character to glyph mapping, applies the GSUB table and applies
@@ -147,11 +160,9 @@
      * @param offset - the index of the first character to process
      * @param count - the number of characters to process
      * @param max - the number of characters in the input context
-     * @param rightToLeft - <code>TRUE</code> if the characters are in a
-     *    right to left directional run
+     * @param rightToLeft - <code>TRUE</code> if the characters are in a right to left directional run
      * @param featureTags - the feature tag array
-     * @param glyphStorage - the glyph storage object. The glyph and char
-     *    index arrays will be set.
+     * @param glyphStorage - the glyph storage object. The glyph and char index arrays will be set.
      *
      * Output parameters:
      * @param success - set to an error code if the operation fails
@@ -163,12 +174,14 @@
      *
      * @internal
      */
-    virtual le_int32 glyphProcessing(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_int32 max, le_bool rightToLeft, LEGlyphStorage &glyphStorage,
-        LEErrorCode &success);
+    virtual le_int32 glyphProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+            LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
 private:
+
     MPreFixups *fMPreFixups;
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/IndicRearrangement.h b/src/share/native/sun/font/layout/IndicRearrangement.h
--- jdk/src/share/native/sun/font/layout/IndicRearrangement.h
+++ jdk/src/share/native/sun/font/layout/IndicRearrangement.h
@@ -32,12 +32,19 @@
 #ifndef __INDICREARRANGEMENT_H
 #define __INDICREARRANGEMENT_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LayoutTables.h"
 #include "StateTables.h"
 #include "MorphTables.h"
 #include "MorphStateTables.h"
 
+U_NAMESPACE_BEGIN
+
 struct IndicRearrangementSubtableHeader : MorphStateTableHeader
 {
 };
@@ -78,4 +85,6 @@
 {
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/IndicRearrangementProcessor.cpp b/src/share/native/sun/font/layout/IndicRearrangementProcessor.cpp
--- jdk/src/share/native/sun/font/layout/IndicRearrangementProcessor.cpp
+++ jdk/src/share/native/sun/font/layout/IndicRearrangementProcessor.cpp
@@ -39,6 +39,10 @@
 #include "LEGlyphStorage.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(IndicRearrangementProcessor)
+
 IndicRearrangementProcessor::IndicRearrangementProcessor(const MorphSubtableHeader *morphSubtableHeader)
   : StateTableProcessor(morphSubtableHeader)
 {
@@ -56,8 +60,7 @@
     lastGlyph = 0;
 }
 
-ByteOffset IndicRearrangementProcessor::processStateEntry(LEGlyphStorage &glyphStorage,
-    le_int32 &currGlyph, EntryTableIndex index)
+ByteOffset IndicRearrangementProcessor::processStateEntry(LEGlyphStorage &glyphStorage, le_int32 &currGlyph, EntryTableIndex index)
 {
     const IndicRearrangementStateEntry *entry = &entryTable[index];
     ByteOffset newState = SWAPW(entry->newStateOffset);
@@ -416,3 +419,5 @@
         break;
     }
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/IndicRearrangementProcessor.h b/src/share/native/sun/font/layout/IndicRearrangementProcessor.h
--- jdk/src/share/native/sun/font/layout/IndicRearrangementProcessor.h
+++ jdk/src/share/native/sun/font/layout/IndicRearrangementProcessor.h
@@ -32,12 +32,19 @@
 #ifndef __INDICREARRANGEMENTPROCESSOR_H
 #define __INDICREARRANGEMENTPROCESSOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "MorphTables.h"
 #include "SubtableProcessor.h"
 #include "StateTableProcessor.h"
 #include "IndicRearrangement.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 class IndicRearrangementProcessor : public StateTableProcessor
@@ -54,12 +61,28 @@
     IndicRearrangementProcessor(const MorphSubtableHeader *morphSubtableHeader);
     virtual ~IndicRearrangementProcessor();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 protected:
     le_int32 firstGlyph;
     le_int32 lastGlyph;
 
     const IndicRearrangementStateEntry *entryTable;
     const IndicRearrangementSubtableHeader *indicRearrangementSubtableHeader;
+
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/IndicReordering.cpp b/src/share/native/sun/font/layout/IndicReordering.cpp
--- jdk/src/share/native/sun/font/layout/IndicReordering.cpp
+++ jdk/src/share/native/sun/font/layout/IndicReordering.cpp
@@ -36,6 +36,8 @@
 #include "LEGlyphStorage.h"
 #include "MPreFixups.h"
 
+U_NAMESPACE_BEGIN
+
 #define initFeatureTag LE_INIT_FEATURE_TAG
 #define nuktFeatureTag LE_NUKT_FEATURE_TAG
 #define akhnFeatureTag LE_AKHN_FEATURE_TAG
@@ -71,7 +73,7 @@
 #define distFeatureMask 0x00020000UL
 #define initFeatureMask 0x00010000UL
 
-class ReorderingOutput {
+class ReorderingOutput : public UMemory {
 private:
     le_int32   fOutIndex;
     LEUnicode *fOutChars;
@@ -187,8 +189,7 @@
         fOutIndex += 1;
     }
 
-    le_bool noteMatra(const IndicClassTable *classTable, LEUnicode matra, le_uint32 matraIndex,
-        FeatureMask matraFeatures, le_bool wordStart)
+    le_bool noteMatra(const IndicClassTable *classTable, LEUnicode matra, le_uint32 matraIndex, FeatureMask matraFeatures, le_bool wordStart)
     {
         IndicClassTable::CharClass matraClass = classTable->getCharClass(matra);
 
@@ -219,13 +220,12 @@
         return FALSE;
     }
 
-    void noteVowelModifier(const IndicClassTable *classTable, LEUnicode vowelModifier,
-        le_uint32 vowelModifierIndex, FeatureMask vowelModifierFeatures)
+    void noteVowelModifier(const IndicClassTable *classTable, LEUnicode vowelModifier, le_uint32 vowelModifierIndex, FeatureMask vowelModifierFeatures)
     {
         IndicClassTable::CharClass vmClass = classTable->getCharClass(vowelModifier);
 
         fVMIndex = vowelModifierIndex;
-        fVMFeatures = vowelModifierFeatures;
+        fVMFeatures  = vowelModifierFeatures;
 
         if (IndicClassTable::isVowelModifier(vmClass)) {
            switch (vmClass & CF_POS_MASK) {
@@ -244,13 +244,12 @@
         }
     }
 
-    void noteStressMark(const IndicClassTable *classTable, LEUnicode stressMark,
-        le_uint32 stressMarkIndex, FeatureMask stressMarkFeatures)
+    void noteStressMark(const IndicClassTable *classTable, LEUnicode stressMark, le_uint32 stressMarkIndex, FeatureMask stressMarkFeatures)
     {
        IndicClassTable::CharClass smClass = classTable->getCharClass(stressMark);
 
         fSMIndex = stressMarkIndex;
-        fSMFeatures = stressMarkFeatures;
+        fSMFeatures  = stressMarkFeatures;
 
         if (IndicClassTable::isStressMark(smClass)) {
             switch (smClass & CF_POS_MASK) {
@@ -360,9 +359,7 @@
 };
 
 // TODO: Find better names for these!
-#define tagArray4 (nuktFeatureMask | akhnFeatureMask | vatuFeatureMask | presFeatureMask | \
-    blwsFeatureMask | abvsFeatureMask | pstsFeatureMask | halnFeatureMask | \
-    blwmFeatureMask | abvmFeatureMask | distFeatureMask)
+#define tagArray4 (nuktFeatureMask | akhnFeatureMask | vatuFeatureMask | presFeatureMask | blwsFeatureMask | abvsFeatureMask | pstsFeatureMask | halnFeatureMask | blwmFeatureMask | abvmFeatureMask | distFeatureMask)
 #define tagArray3 (pstfFeatureMask | tagArray4)
 #define tagArray2 (halfFeatureMask | tagArray3)
 #define tagArray1 (blwfFeatureMask | tagArray2)
@@ -415,8 +412,7 @@
     return featureMap;
 }
 
-le_int32 IndicReordering::findSyllable(const IndicClassTable *classTable,
-    const LEUnicode *chars, le_int32 prev, le_int32 charCount)
+le_int32 IndicReordering::findSyllable(const IndicClassTable *classTable, const LEUnicode *chars, le_int32 prev, le_int32 charCount)
 {
     le_int32 cursor = prev;
     le_int8 state = 0;
@@ -752,3 +748,5 @@
         delete mpreFixups;
     }
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/IndicReordering.h b/src/share/native/sun/font/layout/IndicReordering.h
--- jdk/src/share/native/sun/font/layout/IndicReordering.h
+++ jdk/src/share/native/sun/font/layout/IndicReordering.h
@@ -32,9 +32,16 @@
 #ifndef __INDICREORDERING_H
 #define __INDICREORDERING_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 
+U_NAMESPACE_BEGIN
+
 // Characters that get refered to by name...
 #define C_SIGN_ZWNJ           0x200C
 #define C_SIGN_ZWJ            0x200D
@@ -140,7 +147,7 @@
     static const IndicClassTable *getScriptClassTable(le_int32 scriptCode);
 };
 
-class IndicReordering {
+class IndicReordering /* not : public UObject because all methods are static */ {
 public:
     static le_int32 getWorstCaseExpansion(le_int32 scriptCode);
 
@@ -156,8 +163,7 @@
     // do not instantiate
     IndicReordering();
 
-    static le_int32 findSyllable(const IndicClassTable *classTable, const LEUnicode *chars,
-        le_int32 prev, le_int32 charCount);
+    static le_int32 findSyllable(const IndicClassTable *classTable, const LEUnicode *chars, le_int32 prev, le_int32 charCount);
 
 };
 
@@ -305,4 +311,5 @@
     return hasBelowBaseForm(getCharClass(ch));
 }
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/KernTable.cpp b/src/share/native/sun/font/layout/KernTable.cpp
--- jdk/src/share/native/sun/font/layout/KernTable.cpp
+++ jdk/src/share/native/sun/font/layout/KernTable.cpp
@@ -25,6 +25,7 @@
 
 /*
  *
+ *
  * (C) Copyright IBM Corp. 2004-2005 - All Rights Reserved
  *
  */
@@ -39,6 +40,8 @@
 
 #define DEBUG 0
 
+U_NAMESPACE_BEGIN
+
 struct PairInfo {
   le_uint32 key;   // sigh, MSVC compiler gags on union here
   le_int16  value; // fword, kern value in funits
@@ -191,6 +194,12 @@
     float adjust = 0;
     for (int i = 1, e = storage.getGlyphCount(); i < e; ++i) {
       key = key << 16 | (storage[i] & 0xffff);
+
+      // argh, to do a binary search, we need to have the pair list in sorted order
+      // but it is not in sorted order on win32 platforms because of the endianness difference
+      // so either I have to swap the element each time I examine it, or I have to swap
+      // all the elements ahead of time and store them in the font
+
       const PairInfo* p = pairs;
       const PairInfo* tp = (const PairInfo*)(p + rangeShift);
       if (key > tp->key) {
@@ -238,3 +247,6 @@
     storage.adjustPosition(storage.getGlyphCount(), adjust, 0, success);
   }
 }
+
+U_NAMESPACE_END
+
diff --git a/src/share/native/sun/font/layout/KernTable.h b/src/share/native/sun/font/layout/KernTable.h
--- jdk/src/share/native/sun/font/layout/KernTable.h
+++ jdk/src/share/native/sun/font/layout/KernTable.h
@@ -25,6 +25,7 @@
 
 /*
  *
+ *
  * (C) Copyright IBM Corp. 2004-2005 - All Rights Reserved
  *
  */
@@ -37,9 +38,12 @@
 #endif
 
 #include "LETypes.h"
+//#include "LEFontInstance.h"
+//#include "LEGlyphStorage.h"
 
 #include <stdio.h>
 
+U_NAMESPACE_BEGIN
 struct PairInfo;
 class  LEFontInstance;
 class  LEGlyphStorage;
@@ -67,4 +71,6 @@
   void process(LEGlyphStorage& storage);
 };
 
+U_NAMESPACE_END
+
 #endif
diff --git a/src/share/native/sun/font/layout/KhmerLayoutEngine.cpp b/src/share/native/sun/font/layout/KhmerLayoutEngine.cpp
--- jdk/src/share/native/sun/font/layout/KhmerLayoutEngine.cpp
+++ jdk/src/share/native/sun/font/layout/KhmerLayoutEngine.cpp
@@ -23,8 +23,8 @@
  *
  */
 
+
 /*
- *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
  *
  * This file is a modification of the ICU file IndicLayoutEngine.cpp
@@ -38,17 +38,20 @@
 #include "LEGlyphStorage.h"
 #include "KhmerReordering.h"
 
-KhmerOpenTypeLayoutEngine::KhmerOpenTypeLayoutEngine(const LEFontInstance *fontInstance,
-    le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags,
-    const GlyphSubstitutionTableHeader *gsubTable)
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(KhmerOpenTypeLayoutEngine)
+
+KhmerOpenTypeLayoutEngine::KhmerOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                    le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable)
     : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable)
 {
     fFeatureMap   = KhmerReordering::getFeatureMap(fFeatureMapCount);
     fFeatureOrder = TRUE;
 }
 
-KhmerOpenTypeLayoutEngine::KhmerOpenTypeLayoutEngine(const LEFontInstance *fontInstance,
-    le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags)
+KhmerOpenTypeLayoutEngine::KhmerOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                                                     le_int32 typoFlags)
     : OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags)
 {
     fFeatureMap   = KhmerReordering::getFeatureMap(fFeatureMapCount);
@@ -63,16 +66,14 @@
 // Input: characters
 // Output: characters, char indices, tags
 // Returns: output character count
-le_int32 KhmerOpenTypeLayoutEngine::characterProcessing(const LEUnicode chars[],
-    le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
-    LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success)
+le_int32 KhmerOpenTypeLayoutEngine::characterProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+        LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
     }
 
-    if (chars == NULL || offset < 0 || count < 0 || max < 0 ||
-        offset >= max || offset + count > max) {
+    if (chars == NULL || offset < 0 || count < 0 || max < 0 || offset >= max || offset + count > max) {
         success = LE_ILLEGAL_ARGUMENT_ERROR;
         return 0;
     }
@@ -96,9 +97,10 @@
 
     // NOTE: assumes this allocates featureTags...
     // (probably better than doing the worst case stuff here...)
-    le_int32 outCharCount = KhmerReordering::reorder(&chars[offset], count,
-        fScriptCode, outChars, glyphStorage);
+    le_int32 outCharCount = KhmerReordering::reorder(&chars[offset], count, fScriptCode, outChars, glyphStorage);
 
     glyphStorage.adoptGlyphCount(outCharCount);
     return outCharCount;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/KhmerLayoutEngine.h b/src/share/native/sun/font/layout/KhmerLayoutEngine.h
--- jdk/src/share/native/sun/font/layout/KhmerLayoutEngine.h
+++ jdk/src/share/native/sun/font/layout/KhmerLayoutEngine.h
@@ -23,6 +23,7 @@
  *
  */
 
+
 /*
  *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
@@ -45,19 +46,18 @@
 // #include "GlyphDefinitionTables.h"
 // #include "GlyphPositioningTables.h"
 
+U_NAMESPACE_BEGIN
+
 // class MPreFixups;
 // class LEGlyphStorage;
 
 /**
  * This class implements OpenType layout for Khmer OpenType fonts, as
- * specified by Microsoft in "Creating and Supporting OpenType Fonts
- * for Khmer Scripts"
- * (http://www.microsoft.com/typography/otspec/indicot/default.htm)
- * TODO: change url
+ * specified by Microsoft in "Creating and Supporting OpenType Fonts for
+ * Khmer Scripts" (http://www.microsoft.com/typography/otspec/indicot/default.htm) TODO: change url
  *
- * This class overrides the characterProcessing method to do Khmer
- * character processing and reordering (See the MS spec. for more
- * details)
+ * This class overrides the characterProcessing method to do Khmer character processing
+ * and reordering (See the MS spec. for more details)
  *
  * @internal
  */
@@ -65,11 +65,10 @@
 {
 public:
     /**
-     * This is the main constructor. It constructs an instance of
-     * KhmerOpenTypeLayoutEngine for a particular font, script and
-     * language. It takes the GSUB table as a parameter since
-     * LayoutEngine::layoutEngineFactory has to read the GSUB table to
-     * know that it has an Khmer OpenType font.
+     * This is the main constructor. It constructs an instance of KhmerOpenTypeLayoutEngine for
+     * a particular font, script and language. It takes the GSUB table as a parameter since
+     * LayoutEngine::layoutEngineFactory has to read the GSUB table to know that it has an
+     * Khmer OpenType font.
      *
      * @param fontInstance - the font
      * @param scriptCode - the script
@@ -82,14 +81,12 @@
      *
      * @internal
      */
-    KhmerOpenTypeLayoutEngine(const LEFontInstance *fontInstance,
-        le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags,
-        const GlyphSubstitutionTableHeader *gsubTable);
+    KhmerOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                            le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable);
 
     /**
-     * This constructor is used when the font requires a "canned" GSUB
-     * table which can't be known until after this constructor has
-     * been invoked.
+     * This constructor is used when the font requires a "canned" GSUB table which can't be known
+     * until after this constructor has been invoked.
      *
      * @param fontInstance - the font
      * @param scriptCode - the script
@@ -100,8 +97,8 @@
      *
      * @internal
      */
-    KhmerOpenTypeLayoutEngine(const LEFontInstance *fontInstance,
-        le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags);
+    KhmerOpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                              le_int32 typoFlags);
 
     /**
      * The destructor, virtual for correct polymorphic invocation.
@@ -110,25 +107,35 @@
      */
    virtual ~KhmerOpenTypeLayoutEngine();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 protected:
 
     /**
-     * This method does Khmer OpenType character processing. It
-     * assigns the OpenType feature tags to the characters, and may
-     * generate output characters which have been reordered.  It may
-     * also split some vowels, resulting in more output characters
-     * than input characters.
+     * This method does Khmer OpenType character processing. It assigns the OpenType feature
+     * tags to the characters, and may generate output characters which have been reordered.
+     * It may also split some vowels, resulting in more output characters than input characters.
      *
      * Input parameters:
      * @param chars - the input character context
      * @param offset - the index of the first character to process
      * @param count - the number of characters to process
      * @param max - the number of characters in the input context
-     * @param rightToLeft - <code>TRUE</code> if the characters are in
-     * a right to left directional run
-     * @param glyphStorage - the glyph storage object. The glyph and
-     * character index arrays will be set.  the auxillary data array
-     * will be set to the feature tags.
+     * @param rightToLeft - <code>TRUE</code> if the characters are in a right to left directional run
+     * @param glyphStorage - the glyph storage object. The glyph and character index arrays will be set.
+     *                       the auxillary data array will be set to the feature tags.
      *
      * Output parameters:
      * @param success - set to an error code if the operation fails
@@ -137,9 +144,11 @@
      *
      * @internal
      */
-    virtual le_int32 characterProcessing(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_int32 max, le_bool rightToLeft,
-        LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual le_int32 characterProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+            LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success);
+
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/KhmerReordering.cpp b/src/share/native/sun/font/layout/KhmerReordering.cpp
--- jdk/src/share/native/sun/font/layout/KhmerReordering.cpp
+++ jdk/src/share/native/sun/font/layout/KhmerReordering.cpp
@@ -37,6 +37,9 @@
 #include "KhmerReordering.h"
 #include "LEGlyphStorage.h"
 
+
+U_NAMESPACE_BEGIN
+
 // Characters that get refered to by name...
 enum
 {
@@ -53,35 +56,23 @@
 
 enum
 {
-    // simple classes, they are used in the statetable (in this file)
-    // to control the length of a syllable they are also used to know
-    // where a character should be placed (location in reference to
-    // the base character) and also to know if a character, when
-    // independtly displayed, should be displayed with a dotted-circle
-    // to indicate error in syllable construction
-
+    // simple classes, they are used in the statetable (in this file) to control the length of a syllable
+    // they are also used to know where a character should be placed (location in reference to the base character)
+    // and also to know if a character, when independtly displayed, should be displayed with a dotted-circle to
+    // indicate error in syllable construction
     _xx = KhmerClassTable::CC_RESERVED,
-    _sa = KhmerClassTable::CC_SIGN_ABOVE | KhmerClassTable::CF_DOTTED_CIRCLE
-          | KhmerClassTable::CF_POS_ABOVE,
-    _sp = KhmerClassTable::CC_SIGN_AFTER | KhmerClassTable::CF_DOTTED_CIRCLE
-          | KhmerClassTable::CF_POS_AFTER,
+    _sa = KhmerClassTable::CC_SIGN_ABOVE | KhmerClassTable::CF_DOTTED_CIRCLE | KhmerClassTable::CF_POS_ABOVE,
+    _sp = KhmerClassTable::CC_SIGN_AFTER | KhmerClassTable::CF_DOTTED_CIRCLE| KhmerClassTable::CF_POS_AFTER,
     _c1 = KhmerClassTable::CC_CONSONANT | KhmerClassTable::CF_CONSONANT,
     _c2 = KhmerClassTable::CC_CONSONANT2 | KhmerClassTable::CF_CONSONANT,
     _c3 = KhmerClassTable::CC_CONSONANT3 | KhmerClassTable::CF_CONSONANT,
-    _rb = KhmerClassTable::CC_ROBAT | KhmerClassTable::CF_POS_ABOVE
-          | KhmerClassTable::CF_DOTTED_CIRCLE,
-    _cs = KhmerClassTable::CC_CONSONANT_SHIFTER | KhmerClassTable::CF_DOTTED_CIRCLE
-          | KhmerClassTable::CF_SHIFTER,
-    _dl = KhmerClassTable::CC_DEPENDENT_VOWEL | KhmerClassTable::CF_POS_BEFORE
-          | KhmerClassTable::CF_DOTTED_CIRCLE,
-    _db = KhmerClassTable::CC_DEPENDENT_VOWEL | KhmerClassTable::CF_POS_BELOW
-          | KhmerClassTable::CF_DOTTED_CIRCLE,
-    _da = KhmerClassTable::CC_DEPENDENT_VOWEL | KhmerClassTable::CF_POS_ABOVE
-          | KhmerClassTable::CF_DOTTED_CIRCLE | KhmerClassTable::CF_ABOVE_VOWEL,
-    _dr = KhmerClassTable::CC_DEPENDENT_VOWEL | KhmerClassTable::CF_POS_AFTER
-          | KhmerClassTable::CF_DOTTED_CIRCLE,
-    _co = KhmerClassTable::CC_COENG | KhmerClassTable::CF_COENG
-          | KhmerClassTable::CF_DOTTED_CIRCLE,
+    _rb = KhmerClassTable::CC_ROBAT | KhmerClassTable::CF_POS_ABOVE | KhmerClassTable::CF_DOTTED_CIRCLE,
+    _cs = KhmerClassTable::CC_CONSONANT_SHIFTER | KhmerClassTable::CF_DOTTED_CIRCLE | KhmerClassTable::CF_SHIFTER,
+    _dl = KhmerClassTable::CC_DEPENDENT_VOWEL | KhmerClassTable::CF_POS_BEFORE | KhmerClassTable::CF_DOTTED_CIRCLE,
+    _db = KhmerClassTable::CC_DEPENDENT_VOWEL | KhmerClassTable::CF_POS_BELOW | KhmerClassTable::CF_DOTTED_CIRCLE,
+    _da = KhmerClassTable::CC_DEPENDENT_VOWEL | KhmerClassTable::CF_POS_ABOVE | KhmerClassTable::CF_DOTTED_CIRCLE | KhmerClassTable::CF_ABOVE_VOWEL,
+    _dr = KhmerClassTable::CC_DEPENDENT_VOWEL | KhmerClassTable::CF_POS_AFTER | KhmerClassTable::CF_DOTTED_CIRCLE,
+    _co = KhmerClassTable::CC_COENG | KhmerClassTable::CF_COENG | KhmerClassTable::CF_DOTTED_CIRCLE,
 
     // split vowel
     _va = _da | KhmerClassTable::CF_SPLIT_VOWEL,
@@ -90,13 +81,10 @@
 
 
 // Character class tables
-
-// _xx character does not combine into syllable, such as numbers,
-//     puntuation marks, non-Khmer signs...
+// _xx character does not combine into syllable, such as numbers, puntuation marks, non-Khmer signs...
 // _sa Sign placed above the base
 // _sp Sign placed after the base
-// _c1 Consonant of type 1 or independent vowel (independent vowels
-//     behave as type 1 consonants)
+// _c1 Consonant of type 1 or independent vowel (independent vowels behave as type 1 consonants)
 // _c2 Consonant of type 2 (only RO)
 // _c3 Consonant of type 3
 // _rb Khmer sign robat u17CC. combining mark for subscript consonants
@@ -105,13 +93,10 @@
 // _db Dependent vowel placed below the base
 // _da Dependent vowel placed above the base
 // _dr Dependent vowel placed behind the base (right of the base)
-// _co Khmer combining mark COENG u17D2, combines with the consonant
-//     or independent vowel following it to create a subscript consonant
-//     or independent vowel
-// _va Khmer split vowel in wich the first part is before the base and
-//     the second one above the base
-// _vr Khmer split vowel in wich the first part is before the base and
-//     the second one behind (right of) the base
+// _co Khmer combining mark COENG u17D2, combines with the consonant or independent vowel following
+//     it to create a subscript consonant or independent vowel
+// _va Khmer split vowel in wich the first part is before the base and the second one above the base
+// _vr Khmer split vowel in wich the first part is before the base and the second one behind (right of) the base
 
 static const KhmerClassTable::CharClass khmerCharClasses[] =
 {
@@ -129,19 +114,19 @@
 //
 
 //
-// The range of characters defined in the above table is defined
-// here. FOr Khmer 1780 to 17DF Even if the Khmer range is bigger, all
-// other characters are not combinable, and therefore treated as _xx
+// The range of characters defined in the above table is defined here. FOr Khmer 1780 to 17DF
+// Even if the Khmer range is bigger, all other characters are not combinable, and therefore treated
+// as _xx
 static const KhmerClassTable khmerClassTable = {0x1780, 0x17df, khmerCharClasses};
 
 
-// Below we define how a character in the input string is either in
-// the khmerCharClasses table (in which case we get its type back), a
-// ZWJ or ZWNJ (two characters that may appear within the syllable,
-// but are not in the table) we also get their type back, or an
-// unknown object in which case we get _xx (CC_RESERVED) back
+// Below we define how a character in the input string is either in the khmerCharClasses table
+// (in which case we get its type back), a ZWJ or ZWNJ (two characters that may appear
+// within the syllable, but are not in the table) we also get their type back, or an unknown object
+// in which case we get _xx (CC_RESERVED) back
 KhmerClassTable::CharClass KhmerClassTable::getCharClass(LEUnicode ch) const
 {
+
     if (ch == C_SIGN_ZWJ) {
         return CC_ZERO_WIDTH_J_MARK;
     }
@@ -164,13 +149,14 @@
 
 
 
-class ReorderingOutput {
+class ReorderingOutput : public UMemory {
 private:
     le_int32 fOutIndex;
     LEUnicode *fOutChars;
 
     LEGlyphStorage &fGlyphStorage;
 
+
 public:
     ReorderingOutput(LEUnicode *outChars, LEGlyphStorage &glyphStorage)
         : fOutIndex(0), fOutChars(outChars), fGlyphStorage(glyphStorage)
@@ -232,18 +218,11 @@
 #define abvmFeatureMask 0x00100000UL
 #define mkmkFeatureMask 0x00080000UL
 
-#define tagPref    (prefFeatureMask | presFeatureMask | \
-    cligFeatureMask | distFeatureMask)
-#define tagAbvf    (abvfFeatureMask | abvsFeatureMask | \
-    cligFeatureMask | distFeatureMask | abvmFeatureMask | mkmkFeatureMask)
-#define tagPstf    (blwfFeatureMask | blwsFeatureMask | prefFeatureMask | \
-    presFeatureMask | pstfFeatureMask | pstsFeatureMask | cligFeatureMask | \
-    distFeatureMask | blwmFeatureMask)
-#define tagBlwf    (blwfFeatureMask | blwsFeatureMask | cligFeatureMask | \
-    distFeatureMask | blwmFeatureMask | mkmkFeatureMask)
-#define tagDefault (prefFeatureMask | blwfFeatureMask | presFeatureMask | \
-    blwsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | \
-    blwmFeatureMask | mkmkFeatureMask)
+#define tagPref    (prefFeatureMask | presFeatureMask | cligFeatureMask | distFeatureMask)
+#define tagAbvf    (abvfFeatureMask | abvsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | mkmkFeatureMask)
+#define tagPstf    (blwfFeatureMask | blwsFeatureMask | prefFeatureMask | presFeatureMask | pstfFeatureMask | pstsFeatureMask | cligFeatureMask | distFeatureMask | blwmFeatureMask)
+#define tagBlwf    (blwfFeatureMask | blwsFeatureMask | cligFeatureMask | distFeatureMask | blwmFeatureMask | mkmkFeatureMask)
+#define tagDefault (prefFeatureMask | blwfFeatureMask | presFeatureMask | blwsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | blwmFeatureMask | mkmkFeatureMask)
 
 
 
@@ -274,35 +253,32 @@
 // The stateTable is used to calculate the end (the length) of a well
 // formed Khmer Syllable.
 //
-// Each horizontal line is ordered exactly the same way as the values
-// in KhmerClassTable CharClassValues in KhmerReordering.h This
-// coincidence of values allows the follow up of the table.
+// Each horizontal line is ordered exactly the same way as the values in KhmerClassTable
+// CharClassValues in KhmerReordering.h This coincidence of values allows the
+// follow up of the table.
 //
-// Each line corresponds to a state, which does not necessarily need
-// to be a type of component... for example, state 2 is a base, with
-// is always a first character in the syllable, but the state could be
-// produced a consonant of any type when it is the first character
-// that is analysed (in ground state).
+// Each line corresponds to a state, which does not necessarily need to be a type
+// of component... for example, state 2 is a base, with is always a first character
+// in the syllable, but the state could be produced a consonant of any type when
+// it is the first character that is analysed (in ground state).
 //
 // Differentiating 3 types of consonants is necessary in order to
 // forbid the use of certain combinations, such as having a second
-// coeng after a coeng RO.
-// The inexistent possibility of having a type 3 after another type 3
-// is permitted, eliminating it would very much complicate the table,
-// and it does not create typing problems, as the case above.
+// coeng after a coeng RO,
+// The inexistent possibility of having a type 3 after another type 3 is permitted,
+// eliminating it would very much complicate the table, and it does not create typing
+// problems, as the case above.
 //
-// The table is quite complex, in order to limit the number of coeng
-// consonants to 2 (by means of the table).
+// The table is quite complex, in order to limit the number of coeng consonants
+// to 2 (by means of the table).
 //
 // There a peculiarity, as far as Unicode is concerned:
 // - The consonant-shifter is considered in two possible different
-//   locations, the one considered in Unicode 3.0 and the one considered
-//   in Unicode 4.0. (there is a backwards compatibility problem in this
-//   standard).
+//   locations, the one considered in Unicode 3.0 and the one considered in
+//   Unicode 4.0. (there is a backwards compatibility problem in this standard).
 
 
-// xx    independent character, such as a number, punctuation sign or
-//       non-khmer char
+// xx    independent character, such as a number, punctuation sign or non-khmer char
 //
 // c1    Khmer consonant of type 1 or an independent vowel
 //       that is, a letter in which the subscript for is only under the
@@ -320,10 +296,9 @@
 //
 // co    coeng character (u17D2)
 //
-// dv    dependent vowel (including split vowels, they are treated in the
-//       same way).  even if dv is not defined above, the component that is
-//       really tested for is KhmerClassTable::CC_DEPENDENT_VOWEL, which is
-//       common to all dependent vowels
+// dv    dependent vowel (including split vowels, they are treated in the same way).
+//       even if dv is not defined above, the component that is really tested for is
+//       KhmerClassTable::CC_DEPENDENT_VOWEL, which is common to all dependent vowels
 //
 // zwj   Zero Width joiner
 //
@@ -352,8 +327,7 @@
     {-1, -1, -1, -1, 12, 13, -1, -1, 16, 17,  1, 14}, //  8 - First consonant of type 2 after coeng
     {-1, -1, -1, -1, 12, 13, -1, 10, 16, 17,  1, 14}, //  9 - First consonant or type 3 after ceong
     {-1, 11, 11, 11, -1, -1, -1, -1, -1, -1, -1, -1}, // 10 - Second Coeng (no register shifter before)
-    {-1, -1, -1, -1, 15, -1, -1, -1, 16, 17,  1, 14}, // 11 - Second coeng consonant
-                                                      //      (or ind. vowel) no register shifter before
+    {-1, -1, -1, -1, 15, -1, -1, -1, 16, 17,  1, 14}, // 11 - Second coeng consonant (or ind. vowel) no register shifter before
     {-1, -1,  1, -1, -1, 13, -1, -1, 16, -1, -1, -1}, // 12 - Second ZWNJ before a register shifter
     {-1, -1, -1, -1, 15, -1, -1, -1, 16, 17,  1, 14}, // 13 - Second register shifter
     {-1, -1, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1}, // 14 - ZWJ before vowel
@@ -363,6 +337,7 @@
     {-1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1}, // 18 - ZWJ after vowel
     {-1,  1, -1,  1, -1, -1, -1, -1, -1, -1, -1, -1}, // 19 - Third coeng
     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1, -1}, // 20 - dependent vowel after a Robat
+
 };
 
 
@@ -377,15 +352,13 @@
 // Given an input string of characters and a location in which to start looking
 // calculate, using the state table, which one is the last character of the syllable
 // that starts in the starting position.
-le_int32 KhmerReordering::findSyllable(const KhmerClassTable *classTable,
-    const LEUnicode *chars, le_int32 prev, le_int32 charCount)
+le_int32 KhmerReordering::findSyllable(const KhmerClassTable *classTable, const LEUnicode *chars, le_int32 prev, le_int32 charCount)
 {
     le_int32 cursor = prev;
     le_int8 state = 0;
 
     while (cursor < charCount) {
-        KhmerClassTable::CharClass charClass = (classTable->getCharClass(chars[cursor])
-            & KhmerClassTable::CF_CLASS_MASK);
+        KhmerClassTable::CharClass charClass = (classTable->getCharClass(chars[cursor]) & KhmerClassTable::CF_CLASS_MASK);
 
         state = khmerStateTable[state][charClass];
 
@@ -402,8 +375,8 @@
 
 // This is the real reordering function as applied to the Khmer language
 
-le_int32 KhmerReordering::reorder(const LEUnicode *chars, le_int32 charCount,
-    le_int32 /*scriptCode*/, LEUnicode *outChars, LEGlyphStorage &glyphStorage)
+le_int32 KhmerReordering::reorder(const LEUnicode *chars, le_int32 charCount, le_int32 /*scriptCode*/,
+                                  LEUnicode *outChars, LEGlyphStorage &glyphStorage)
 {
     const KhmerClassTable *classTable = KhmerClassTable::getKhmerClassTable();
 
@@ -442,8 +415,7 @@
             // and because CC_CONSONANT2 is enough to identify it, as it is the only consonant
             // with this flag
             if ( (charClass & KhmerClassTable::CF_COENG) && (i + 1 < syllable) &&
-                 ( (classTable->getCharClass(chars[i + 1]) &
-                    KhmerClassTable::CF_CLASS_MASK) == KhmerClassTable::CC_CONSONANT2) )
+                 ( (classTable->getCharClass(chars[i + 1]) & KhmerClassTable::CF_CLASS_MASK) == KhmerClassTable::CC_CONSONANT2) )
             {
                     coengRo = i;
             }
@@ -455,16 +427,15 @@
             output.writeChar(C_RO, coengRo + 1, tagPref);
         }
 
-        // shall we add a dotted circle?  If in the position in which
-        // the base should be (first char in the string) there is a
-        // character that has the Dotted circle flag (a character that
-        // cannot be a base) then write a dotted circle
+        // shall we add a dotted circle?
+        // If in the position in which the base should be (first char in the string) there is
+        // a character that has the Dotted circle flag (a character that cannot be a base)
+        // then write a dotted circle
         if (classTable->getCharClass(chars[prev]) & KhmerClassTable::CF_DOTTED_CIRCLE) {
             output.writeChar(C_DOTTED_CIRCLE, prev, tagDefault);
         }
 
-        // copy what is left to the output, skipping before vowels and
-        // coeng Ro if they are present
+        // copy what is left to the output, skipping before vowels and coeng Ro if they are present
         for (i = prev; i < syllable; i += 1) {
             charClass = classTable->getCharClass(chars[i]);
 
@@ -515,30 +486,14 @@
                     // and there is an extra rule for C_VOWEL_AA + C_SIGN_NIKAHIT also for two
                     // different positions, right after the shifter or after a vowel (Unicode 4)
                     if ( (charClass & KhmerClassTable::CF_SHIFTER) && (i + 1 < syllable) ) {
-                        if (classTable->getCharClass(chars[i + 1]) & KhmerClassTable::CF_ABOVE_VOWEL ) {
-                            output.writeChar(chars[i], i, tagBlwf);
-                            break;
-                        }
-                        if (i + 2 < syllable &&
-                            ( (classTable->getCharClass(chars[i + 1]) &
-                               KhmerClassTable::CF_CLASS_MASK) == C_VOWEL_AA) &&
-                            ( (classTable->getCharClass(chars[i + 2]) &
-                               KhmerClassTable::CF_CLASS_MASK) == C_SIGN_NIKAHIT) )
-                        {
-                            output.writeChar(chars[i], i, tagBlwf);
-                            break;
-                        }
-                        if (i + 3 < syllable && (classTable->getCharClass(chars[i + 3]) &
-                            KhmerClassTable::CF_ABOVE_VOWEL) )
-                        {
-                            output.writeChar(chars[i], i, tagBlwf);
-                            break;
-                        }
-                        if (i + 4 < syllable &&
-                            ( (classTable->getCharClass(chars[i + 3]) &
-                               KhmerClassTable::CF_CLASS_MASK) == C_VOWEL_AA) &&
-                            ( (classTable->getCharClass(chars[i + 4]) &
-                               KhmerClassTable::CF_CLASS_MASK) == C_SIGN_NIKAHIT) )
+                        if ((classTable->getCharClass(chars[i + 1]) & KhmerClassTable::CF_ABOVE_VOWEL)
+                            || (i + 2 < syllable
+                                && ( (classTable->getCharClass(chars[i + 1]) & KhmerClassTable::CF_CLASS_MASK) == C_VOWEL_AA)
+                                && ( (classTable->getCharClass(chars[i + 2]) & KhmerClassTable::CF_CLASS_MASK) == C_SIGN_NIKAHIT))
+                            || (i + 3 < syllable && (classTable->getCharClass(chars[i + 3]) & KhmerClassTable::CF_ABOVE_VOWEL))
+                            || (i + 4 < syllable
+                                && ( (classTable->getCharClass(chars[i + 3]) & KhmerClassTable::CF_CLASS_MASK) == C_VOWEL_AA)
+                                && ( (classTable->getCharClass(chars[i + 4]) & KhmerClassTable::CF_CLASS_MASK) == C_SIGN_NIKAHIT) ) )
                         {
                             output.writeChar(chars[i], i, tagBlwf);
                             break;
@@ -556,3 +511,6 @@
 
     return output.getOutputIndex();
 }
+
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/KhmerReordering.h b/src/share/native/sun/font/layout/KhmerReordering.h
--- jdk/src/share/native/sun/font/layout/KhmerReordering.h
+++ jdk/src/share/native/sun/font/layout/KhmerReordering.h
@@ -24,7 +24,6 @@
  */
 
 /*
- *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
  *
  * This file is a modification of the ICU file IndicReordering.h
@@ -35,80 +34,60 @@
 #ifndef __KHMERREORDERING_H
 #define __KHMERREORDERING_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 // Vocabulary
-
-// Base ->
-//     A consonant or an independent vowel in its full (not
-//     subscript) form. It is the center of the syllable, it can be
-//     souranded by coeng (subscript) consonants, vowels, split
-//     vowels, signs... but there is only one base in a syllable, it
-//     has to be coded as the first character of the syllable.
-// split vowel ->
-//     vowel that has two parts placed separately (e.g. Before and
-//     after the consonant).  Khmer language has five of them. Khmer
-//     split vowels either have one part before the base and one after
-//     the base or they have a part before the base and a part above
-//     the base.  The first part of all Khmer split vowels is the same
-//     character, identical to the glyph of Khmer dependent vowel SRA
-//     EI
-// coeng ->
-//     modifier used in Khmer to construct coeng (subscript)
-//     consonants differently than indian languages, the coeng
-//     modifies the consonant that follows it, not the one preceding
-//     it Each consonant has two forms, the base form and the
-//     subscript form the base form is the normal one (using the
-//     consonants code-point), the subscript form is displayed when
-//     the combination coeng + consonant is encountered.
-// Consonant of type 1 ->
-//     A consonant which has subscript for that only occupies space
-//     under a base consonant
-// Consonant of type 2 ->
-//     Its subscript form occupies space under and before the base
-//     (only one, RO)
-// Consonant of Type 3 ->
-//     Its subscript form occupies space under and after the base
-//     (KHO, CHHO, THHO, BA, YO, SA)
-// Consonant shifter ->
-//     Khmer has to series of consonants. The same dependent vowel has
-//     different sounds if it is attached to a consonant of the first
-//     series or a consonant of the second series Most consonants have
-//     an equivalent in the other series, but some of theme exist only
-//     in one series (for example SA). If we want to use the consonant
-//     SA with a vowel sound that can only be done with a vowel sound
-//     that corresponds to a vowel accompanying a consonant of the
-//     other series, then we need to use a consonant shifter: TRIISAP
-//     or MUSIKATOAN x17C9 y x17CA. TRIISAP changes a first series
-//     consonant to second series sound and MUSIKATOAN a second series
-//     consonant to have a first series vowel sound.  Consonant
-//     shifter are both normally supercript marks, but, when they are
-//     followed by a superscript, they change shape and take the form
-//     of subscript dependent vowel SRA U.  If they are in the same
-//     syllable as a coeng consonant, Unicode 3.0 says that they
-//     should be typed before the coeng. Unicode 4.0 breaks the
-//     standard and says that it should be placed after the coeng
-//     consonant.
-// Dependent vowel ->
-//     In khmer dependent vowels can be placed above, below, before or
-//     after the base Each vowel has its own position. Only one vowel
-//     per syllable is allowed.
-// Signs ->
-//     Khmer has above signs and post signs. Only one above sign
-//     and/or one post sign are Allowed in a syllable.
+//     Base ->         A consonant or an independent vowel in its full (not subscript) form. It is the
+//                     center of the syllable, it can be souranded by coeng (subscript) consonants, vowels,
+//                     split vowels, signs... but there is only one base in a syllable, it has to be coded as
+//                     the first character of the syllable.
+//     split vowel --> vowel that has two parts placed separately (e.g. Before and after the consonant).
+//                     Khmer language has five of them. Khmer split vowels either have one part before the
+//                     base and one after the base or they have a part before the base and a part above the base.
+//                     The first part of all Khmer split vowels is the same character, identical to
+//                     the glyph of Khmer dependent vowel SRA EI
+//     coeng -->  modifier used in Khmer to construct coeng (subscript) consonants
+//                Differently than indian languages, the coeng modifies the consonant that follows it,
+//                not the one preceding it  Each consonant has two forms, the base form and the subscript form
+//                the base form is the normal one (using the consonants code-point), the subscript form is
+//                displayed when the combination coeng + consonant is encountered.
+//     Consonant of type 1 -> A consonant which has subscript for that only occupies space under a base consonant
+//     Consonant of type 2.-> Its subscript form occupies space under and before the base (only one, RO)
+//     Consonant of Type 3 -> Its subscript form occupies space under and after the base (KHO, CHHO, THHO, BA, YO, SA)
+//     Consonant shifter -> Khmer has to series of consonants. The same dependent vowel has different sounds
+//                          if it is attached to a consonant of the first series or a consonant of the second series
+//                          Most consonants have an equivalent in the other series, but some of theme exist only in
+//                          one series (for example SA). If we want to use the consonant SA with a vowel sound that
+//                          can only be done with a vowel sound that corresponds to a vowel accompanying a consonant
+//                          of the other series, then we need to use a consonant shifter: TRIISAP or MUSIKATOAN
+//                          x17C9 y x17CA. TRIISAP changes a first series consonant to second series sound and
+//                          MUSIKATOAN a second series consonant to have a first series vowel sound.
+//                          Consonant shifter are both normally supercript marks, but, when they are followed by a
+//                          superscript, they change shape and take the form of subscript dependent vowel SRA U.
+//                          If they are in the same syllable as a coeng consonant, Unicode 3.0 says that they
+//                          should be typed before the coeng. Unicode 4.0 breaks the standard and says that it should
+//                          be placed after the coeng consonant.
+//     Dependent vowel ->   In khmer dependent vowels can be placed above, below, before or after the base
+//                          Each vowel has its own position. Only one vowel per syllable is allowed.
+//     Signs            ->  Khmer has above signs and post signs. Only one above sign and/or one post sign are
+//                          Allowed in a syllable.
+//
 //
 
-// This list must include all types of components that can be used
-// inside a syllable
-struct KhmerClassTable
+struct KhmerClassTable    // This list must include all types of components that can be used inside a syllable
 {
-    // order is important here! This order must be the same that is
-    // found in each horizontal line in the statetable for Khmer (file
-    // KhmerReordering.cpp).
-    enum CharClassValues
+    enum CharClassValues  // order is important here! This order must be the same that is found in each horizontal
+                          // line in the statetable for Khmer (file KhmerReordering.cpp).
     {
         CC_RESERVED             =  0,
         CC_CONSONANT            =  1, // consonant of type 1 or independent vowel
@@ -116,8 +95,7 @@
         CC_CONSONANT3           =  3, // Consonant of type 3
         CC_ZERO_WIDTH_NJ_MARK   =  4, // Zero Width non joiner character (0x200C)
         CC_CONSONANT_SHIFTER    =  5,
-        CC_ROBAT                =  6, // Khmer special diacritic accent
-                                      // -treated differently in state table
+        CC_ROBAT                =  6, // Khmer special diacritic accent -treated differently in state table
         CC_COENG                =  7, // Subscript consonant combining character
         CC_DEPENDENT_VOWEL      =  8,
         CC_SIGN_ABOVE           =  9,
@@ -131,10 +109,8 @@
         CF_CLASS_MASK    = 0x0000FFFF,
 
         CF_CONSONANT     = 0x01000000,  // flag to speed up comparing
-        CF_SPLIT_VOWEL   = 0x02000000,  // flag for a split vowel -> the first part
-                                        // is added in front of the syllable
-        CF_DOTTED_CIRCLE = 0x04000000,  // add a dotted circle if a character with
-                                        // this flag is the first in a syllable
+        CF_SPLIT_VOWEL   = 0x02000000,  // flag for a split vowel -> the first part is added in front of the syllable
+        CF_DOTTED_CIRCLE = 0x04000000,  // add a dotted circle if a character with this flag is the first in a syllable
         CF_COENG         = 0x08000000,  // flag to speed up comparing
         CF_SHIFTER       = 0x10000000,  // flag to speed up comparing
         CF_ABOVE_VOWEL   = 0x20000000,  // flag to speed up comparing
@@ -161,10 +137,10 @@
 };
 
 
-class KhmerReordering {
+class KhmerReordering /* not : public UObject because all methods are static */ {
 public:
-    static le_int32 reorder(const LEUnicode *theChars, le_int32 charCount,
-        le_int32 scriptCode, LEUnicode *outChars, LEGlyphStorage &glyphStorage);
+    static le_int32 reorder(const LEUnicode *theChars, le_int32 charCount, le_int32 scriptCode,
+        LEUnicode *outChars, LEGlyphStorage &glyphStorage);
 
     static const FeatureMap *getFeatureMap(le_int32 &count);
 
@@ -172,8 +148,10 @@
     // do not instantiate
     KhmerReordering();
 
-    static le_int32 findSyllable(const KhmerClassTable *classTable,
-        const LEUnicode *chars, le_int32 prev, le_int32 charCount);
+    static le_int32 findSyllable(const KhmerClassTable *classTable, const LEUnicode *chars, le_int32 prev, le_int32 charCount);
+
 };
 
+
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/LEFontInstance.cpp b/src/share/native/sun/font/layout/LEFontInstance.cpp
--- jdk/src/share/native/sun/font/layout/LEFontInstance.cpp
+++ jdk/src/share/native/sun/font/layout/LEFontInstance.cpp
@@ -24,7 +24,6 @@
  */
 
 /*
- *
  *******************************************************************************
  *
  *   Copyright (C) 1999-2005, International Business Machines
@@ -42,6 +41,10 @@
 #include "LEFontInstance.h"
 #include "LEGlyphStorage.h"
 
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(LEFontInstance)
+
 const LEFontInstance *LEFontInstance::getSubFont(const LEUnicode chars[], le_int32 *offset, le_int32 limit,
                                                        le_int32 script, LEErrorCode &success) const
 {
@@ -59,7 +62,7 @@
 }
 
 void LEFontInstance::mapCharsToGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count,
-    le_bool reverse, const LECharMapper *mapper, LEGlyphStorage &glyphStorage) const
+                                      le_bool reverse, const LECharMapper *mapper, LEGlyphStorage &glyphStorage) const
 {
     le_int32 i, out = 0, dir = 1;
 
@@ -100,3 +103,5 @@
 
     return mapCharToGlyph(mappedChar);
 }
+U_NAMESPACE_END
+
diff --git a/src/share/native/sun/font/layout/LEFontInstance.h b/src/share/native/sun/font/layout/LEFontInstance.h
--- jdk/src/share/native/sun/font/layout/LEFontInstance.h
+++ jdk/src/share/native/sun/font/layout/LEFontInstance.h
@@ -34,6 +34,12 @@
 #define __LEFONTINSTANCE_H
 
 #include "LETypes.h"
+/**
+ * \file
+ * \brief C++ API: Layout Engine Font Instance object
+ */
+
+U_NAMESPACE_BEGIN
 
 /**
  * Instances of this class are used by <code>LEFontInstance::mapCharsToGlyphs</code> and
@@ -44,7 +50,7 @@
  *
  * @stable ICU 3.2
  */
-class LECharMapper
+class LECharMapper /* not : public UObject because this is an interface/mixin class */
 {
 public:
     /**
@@ -97,7 +103,7 @@
  *
  * @draft ICU 3.0
  */
-class LEFontInstance
+class U_LAYOUT_API LEFontInstance : public UObject
 {
 public:
 
@@ -160,8 +166,7 @@
      *
      * @stable ICU 3.2
      */
-    virtual const LEFontInstance *getSubFont(const LEUnicode chars[], le_int32 *offset,
-        le_int32 limit, le_int32 script, LEErrorCode &success) const;
+    virtual const LEFontInstance *getSubFont(const LEUnicode chars[], le_int32 *offset, le_int32 limit, le_int32 script, LEErrorCode &success) const;
 
     //
     // Font file access
@@ -238,8 +243,7 @@
      *
      * @draft ICU 3.0
      */
-    virtual void mapCharsToGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count,
-        le_bool reverse, const LECharMapper *mapper, LEGlyphStorage &glyphStorage) const;
+    virtual void mapCharsToGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse, const LECharMapper *mapper, LEGlyphStorage &glyphStorage) const;
 
     /**
      * This method maps a single character to a glyph index, using the
@@ -502,6 +506,21 @@
      * @stable ICU 3.2
      */
     virtual le_int32 getLineHeight() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 3.2
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 3.2
+     */
+    static UClassID getStaticClassID();
+
 };
 
 inline le_bool LEFontInstance::canDisplay(LEUnicode32 ch) const
@@ -562,4 +581,7 @@
     return getAscent() + getDescent() + getLeading();
 }
 
+U_NAMESPACE_END
 #endif
+
+
diff --git a/src/share/native/sun/font/layout/LEGlyphFilter.h b/src/share/native/sun/font/layout/LEGlyphFilter.h
--- jdk/src/share/native/sun/font/layout/LEGlyphFilter.h
+++ jdk/src/share/native/sun/font/layout/LEGlyphFilter.h
@@ -34,14 +34,15 @@
 
 #include "LETypes.h"
 
+U_NAMESPACE_BEGIN
+
 /**
  * This is a helper class that is used to
  * recognize a set of glyph indices.
  *
  * @internal
  */
-class LEGlyphFilter
-{
+class LEGlyphFilter /* not : public UObject because this is an interface/mixin class */ {
 public:
     /**
      * Destructor.
@@ -63,4 +64,5 @@
     virtual le_bool accept(LEGlyphID glyph) const = 0;
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/LEGlyphStorage.cpp b/src/share/native/sun/font/layout/LEGlyphStorage.cpp
--- jdk/src/share/native/sun/font/layout/LEGlyphStorage.cpp
+++ jdk/src/share/native/sun/font/layout/LEGlyphStorage.cpp
@@ -24,7 +24,6 @@
  */
 
 /*
- *
  **********************************************************************
  *   Copyright (C) 1998-2005, International Business Machines
  *   Corporation and others.  All Rights Reserved.
@@ -35,6 +34,10 @@
 #include "LEInsertionList.h"
 #include "LEGlyphStorage.h"
 
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(LEGlyphStorage)
+
 LEGlyphStorage::LEGlyphStorage()
     : fGlyphCount(0), fGlyphs(NULL), fCharIndices(NULL), fPositions(NULL),
       fAuxData(NULL), fInsertionList(NULL), fSrcIndex(0), fDestIndex(0)
@@ -603,3 +606,6 @@
 
     return FALSE;
 }
+
+U_NAMESPACE_END
+
diff --git a/src/share/native/sun/font/layout/LEGlyphStorage.h b/src/share/native/sun/font/layout/LEGlyphStorage.h
--- jdk/src/share/native/sun/font/layout/LEGlyphStorage.h
+++ jdk/src/share/native/sun/font/layout/LEGlyphStorage.h
@@ -24,7 +24,6 @@
  */
 
 /*
- *
  **********************************************************************
  *   Copyright (C) 1998-2005, International Business Machines
  *   Corporation and others.  All Rights Reserved.
@@ -38,6 +37,13 @@
 #include "LEInsertionList.h"
 
 /**
+ * \file
+ * \brief C++ API: This class encapsulates the per-glyph storage used by the ICU LayoutEngine.
+ */
+
+U_NAMESPACE_BEGIN
+
+/**
  * This class encapsulates the per-glyph storage used by the ICU LayoutEngine.
  * For each glyph it holds the glyph ID, the index of the backing store character
  * which produced the glyph, the X and Y position of the glyph and an auxillary data
@@ -50,7 +56,7 @@
  *
  * @draft ICU 3.6
  */
-class U_LAYOUT_API LEGlyphStorage : protected LEInsertionCallback
+class U_LAYOUT_API LEGlyphStorage : public UObject, protected LEInsertionCallback
 {
 private:
     /**
@@ -112,35 +118,37 @@
 
 protected:
     /**
-     * This implements <code>LEInsertionCallback</code>. The
-     * <code>LEInsertionList</code> will call this method once for
-     * each insertion.
+     * This implements <code>LEInsertionCallback</code>. The <code>LEInsertionList</code>
+     * will call this method once for each insertion.
      *
      * @param atPosition the position of the insertion
      * @param count the number of glyphs being inserted
      * @param newGlyphs the address of the new glyph IDs
      *
-     * @return <code>true</code> if <code>LEInsertionList</code>
-     * should stop processing the insertion list after this insertion.
+     * @return <code>true</code> if <code>LEInsertionList</code> should stop
+     *         processing the insertion list after this insertion.
      *
      * @see LEInsertionList.h
      *
      * @draft ICU 3.0
      */
-    virtual le_bool applyInsertion(le_int32 atPosition, le_int32 count,
-        LEGlyphID newGlyphs[]);
+    virtual le_bool applyInsertion(le_int32 atPosition, le_int32 count, LEGlyphID newGlyphs[]);
 
 public:
 
     /**
-     * Allocates an empty <code>LEGlyphStorage</code> object. You must
-     * call <code>allocateGlyphArray, allocatePositions and
-     * allocateAuxData</code> to allocate the data.
+     * Allocates an empty <code>LEGlyphStorage</code> object. You must call
+     * <code>allocateGlyphArray, allocatePositions and allocateAuxData</code>
+     * to allocate the data.
+     *
+     * @draft ICU 3.0
      */
     LEGlyphStorage();
 
     /**
      * The destructor. This will deallocate all of the arrays.
+     *
+     * @draft ICU 3.0
      */
     ~LEGlyphStorage();
 
@@ -154,9 +162,9 @@
     inline le_int32 getGlyphCount() const;
 
     /**
-     * This method copies the glyph array into a caller supplied
-     * array.  The caller must ensure that the array is large enough
-     * to hold all the glyphs.
+     * This method copies the glyph array into a caller supplied array.
+     * The caller must ensure that the array is large enough to hold all
+     * the glyphs.
      *
      * @param glyphs - the destiniation glyph array
      * @param success - set to an error code if the operation fails
@@ -166,10 +174,10 @@
     void getGlyphs(LEGlyphID glyphs[], LEErrorCode &success) const;
 
     /**
-     * This method copies the glyph array into a caller supplied
-     * array, ORing in extra bits. (This functionality is needed by
-     * the JDK, which uses 32 bits pre glyph idex, with the high 16
-     * bits encoding the composite font slot number)
+     * This method copies the glyph array into a caller supplied array,
+     * ORing in extra bits. (This functionality is needed by the JDK,
+     * which uses 32 bits pre glyph idex, with the high 16 bits encoding
+     * the composite font slot number)
      *
      * @param glyphs - the destination (32 bit) glyph array
      * @param extraBits - this value will be ORed with each glyph index
@@ -177,13 +185,12 @@
      *
      * @draft ICU 3.0
      */
-    void getGlyphs(le_uint32 glyphs[], le_uint32 extraBits,
-        LEErrorCode &success) const;
+    void getGlyphs(le_uint32 glyphs[], le_uint32 extraBits, LEErrorCode &success) const;
 
     /**
-     * This method copies the character index array into a caller
-     * supplied array.  The caller must ensure that the array is large
-     * enough to hold a character index for each glyph.
+     * This method copies the character index array into a caller supplied array.
+     * The caller must ensure that the array is large enough to hold a
+     * character index for each glyph.
      *
      * @param charIndices - the destiniation character index array
      * @param success - set to an error code if the operation fails
@@ -193,9 +200,9 @@
     void getCharIndices(le_int32 charIndices[], LEErrorCode &success) const;
 
     /**
-     * This method copies the character index array into a caller
-     * supplied array.  The caller must ensure that the array is large
-     * enough to hold a character index for each glyph.
+     * This method copies the character index array into a caller supplied array.
+     * The caller must ensure that the array is large enough to hold a
+     * character index for each glyph.
      *
      * @param charIndices - the destiniation character index array
      * @param indexBase - an offset which will be added to each index
@@ -203,14 +210,13 @@
      *
      * @draft ICU 3.0
      */
-    void getCharIndices(le_int32 charIndices[], le_int32 indexBase,
-        LEErrorCode &success) const;
+    void getCharIndices(le_int32 charIndices[], le_int32 indexBase, LEErrorCode &success) const;
 
     /**
-     * This method copies the position array into a caller supplied
-     * array.  The caller must ensure that the array is large enough
-     * to hold an X and Y position for each glyph, plus an extra X and
-     * Y for the advance of the last glyph.
+     * This method copies the position array into a caller supplied array.
+     * The caller must ensure that the array is large enough to hold an
+     * X and Y position for each glyph, plus an extra X and Y for the
+     * advance of the last glyph.
      *
      * @param positions - the destiniation position array
      * @param success - set to an error code if the operation fails
@@ -233,33 +239,27 @@
      *
      * @draft ICU 3.0
      */
-    void getGlyphPosition(le_int32 glyphIndex, float &x, float &y,
-        LEErrorCode &success) const;
+    void getGlyphPosition(le_int32 glyphIndex, float &x, float &y, LEErrorCode &success) const;
 
     /**
-     * This method allocates the glyph array, the char indices array
-     * and the insertion list. You must call this method before using
-     * the object. This method also initializes the char indices
+     * This method allocates the glyph array, the char indices array and the insertion list. You
+     * must call this method before using the object. This method also initializes the char indices
      * array.
-     * @param initialGlyphCount the initial size of the glyph and char
-     *     indices arrays.
-     * @param rightToLeft <code>true</code> if the original input text
-     *     is right to left.
-     * @param success set to an error code if the storage cannot be
-     *     allocated of if the initial glyph count is not positive.
+     *
+     * @param initialGlyphCount the initial size of the glyph and char indices arrays.
+     * @param rightToLeft <code>true</code> if the original input text is right to left.
+     * @param success set to an error code if the storage cannot be allocated of if the initial
+     *        glyph count is not positive.
      *
      * @draft ICU 3.0
      */
-    void allocateGlyphArray(le_int32 initialGlyphCount, le_bool rightToLeft,
-        LEErrorCode &success);
+    void allocateGlyphArray(le_int32 initialGlyphCount, le_bool rightToLeft, LEErrorCode &success);
 
     /**
-     * This method allocates the storage for the glyph positions. It
-     * allocates one extra X, Y position pair for the position just
-     * after the last glyph.
+     * This method allocates the storage for the glyph positions. It allocates one extra X, Y
+     * position pair for the position just after the last glyph.
      *
-     * @param success set to an error code if the positions array
-     *     cannot be allocated.
+     * @param success set to an error code if the positions array cannot be allocated.
      *
      * @return the number of X, Y position pairs allocated.
      *
@@ -270,8 +270,7 @@
     /**
      * This method allocates the storage for the auxillary glyph data.
      *
-     * @param success set to an error code if the aulillary data array
-     *     cannot be allocated.
+     * @param success set to an error code if the aulillary data array cannot be allocated.
      *
      * @return the size of the auxillary data array.
      *
@@ -282,10 +281,8 @@
     /**
      * Copy the entire auxillary data array.
      *
-     * @param auxData the auxillary data array will be copied to this
-     *     address
-     * @param success set to an error code if the data cannot be
-     *     copied
+     * @param auxData the auxillary data array will be copied to this address
+     * @param success set to an error code if the data cannot be copied
      *
      * @draft ICU 3.6
      */
@@ -295,8 +292,7 @@
      * Get the glyph ID for a particular glyph.
      *
      * @param glyphIndex the index into the glyph array
-     * @param success set to an error code if the glyph ID cannot be
-     *     retrieved.
+     * @param success set to an error code if the glyph ID cannot be retrieved.
      *
      * @return the glyph ID
      *
@@ -308,8 +304,7 @@
      * Get the char index for a particular glyph.
      *
      * @param glyphIndex the index into the glyph array
-     * @param success set to an error code if the char index cannot be
-     *     retrieved.
+     * @param success set to an error code if the char index cannot be retrieved.
      *
      * @return the character index
      *
@@ -322,8 +317,7 @@
      * Get the auxillary data for a particular glyph.
      *
      * @param glyphIndex the index into the glyph array
-     * @param success set to an error code if the auxillary data
-     *     cannot be retrieved.
+     * @param success set to an error code if the auxillary data cannot be retrieved.
      *
      * @return the auxillary data
      *
@@ -345,11 +339,10 @@
 
     /**
      * Call this method to replace a single glyph in the glyph array
-     * with multiple glyphs. This method uses the
-     * <code>LEInsertionList</code> to do the insertion. It returns
-     * the address of storage where the new glyph IDs can be
-     * stored. They will not actually be inserted into the glyph array
-     * until <code>applyInsertions</code> is called.
+     * with multiple glyphs. This method uses the <code>LEInsertionList</code>
+     * to do the insertion. It returns the address of storage where the new
+     * glyph IDs can be stored. They will not actually be inserted into the
+     * glyph array until <code>applyInsertions</code> is called.
      *
      * @param atIndex the index of the glyph to be replaced
      * @param insertCount the number of glyphs to replace it with
@@ -381,26 +374,22 @@
      *
      * @param glyphIndex the index of the glyph
      * @param glyphID the new glyph ID
-     * @param success will be set to an error code if the glyph ID
-     *     cannot be set.
+     * @param success will be set to an error code if the glyph ID cannot be set.
      *
      * @draft ICU 3.0
      */
-    void setGlyphID(le_int32 glyphIndex, LEGlyphID glyphID,
-        LEErrorCode &success);
+    void setGlyphID(le_int32 glyphIndex, LEGlyphID glyphID, LEErrorCode &success);
 
     /**
      * Set the char index for a particular glyph.
      *
      * @param glyphIndex the index of the glyph
      * @param charIndex the new char index
-     * @param success will be set to an error code if the char index
-     *     cannot be set.
+     * @param success will be set to an error code if the char index cannot be set.
      *
      * @draft ICU 3.0
      */
-    void setCharIndex(le_int32 glyphIndex, le_int32 charIndex,
-        LEErrorCode &success);
+    void setCharIndex(le_int32 glyphIndex, le_int32 charIndex, LEErrorCode &success);
 
     /**
      * Set the X, Y position for a particular glyph.
@@ -408,13 +397,11 @@
      * @param glyphIndex the index of the glyph
      * @param x the new X position
      * @param y the new Y position
-     * @param success will be set to an error code if the position
-     *     cannot be set.
+     * @param success will be set to an error code if the position cannot be set.
      *
      * @draft ICU 3.0
      */
-    void setPosition(le_int32 glyphIndex, float x, float y,
-        LEErrorCode &success);
+    void setPosition(le_int32 glyphIndex, float x, float y, LEErrorCode &success);
 
     /**
      * Adjust the X, Y position for a particular glyph.
@@ -422,21 +409,18 @@
      * @param glyphIndex the index of the glyph
      * @param xAdjust the adjustment to the glyph's X position
      * @param yAdjust the adjustment to the glyph's Y position
-     * @param success will be set to an error code if the glyph's
-     *     position cannot be adjusted.
+     * @param success will be set to an error code if the glyph's position cannot be adjusted.
      *
      * @draft ICU 3.0
      */
-    void adjustPosition(le_int32 glyphIndex, float xAdjust, float yAdjust,
-        LEErrorCode &success);
+    void adjustPosition(le_int32 glyphIndex, float xAdjust, float yAdjust, LEErrorCode &success);
 
     /**
      * Set the auxillary data for a particular glyph.
      *
      * @param glyphIndex the index of the glyph
      * @param auxData the new auxillary data
-     * @param success will be set to an error code if the auxillary
-     *     data cannot be set.
+     * @param success will be set to an error code if the auxillary data cannot be set.
      *
      * @draft ICU 3.6
      */
@@ -511,14 +495,28 @@
     void adoptGlyphCount(le_int32 newGlyphCount);
 
     /**
-     * This method frees the glyph, character index, position and
-     * auxillary data arrays so that the LayoutEngine can be reused to
-     * layout a different characer array. (This method is also called
+     * This method frees the glyph, character index, position  and
+     * auxillary data arrays so that the LayoutEngine can be reused
+     * to layout a different characer array. (This method is also called
      * by the destructor)
      *
      * @draft ICU 3.0
      */
     void reset();
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @draft ICU 3.0
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @draft ICU 3.0
+     */
+    static UClassID getStaticClassID();
 };
 
 inline le_int32 LEGlyphStorage::getGlyphCount() const
@@ -531,4 +529,7 @@
     return fGlyphs[glyphIndex];
 }
 
+
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/LEInsertionList.cpp b/src/share/native/sun/font/layout/LEInsertionList.cpp
--- jdk/src/share/native/sun/font/layout/LEInsertionList.cpp
+++ jdk/src/share/native/sun/font/layout/LEInsertionList.cpp
@@ -24,7 +24,6 @@
  */
 
 /*
- *
  **********************************************************************
  *   Copyright (C) 1998-2004, International Business Machines
  *   Corporation and others.  All Rights Reserved.
@@ -34,6 +33,8 @@
 #include "LETypes.h"
 #include "LEInsertionList.h"
 
+U_NAMESPACE_BEGIN
+
 #define ANY_NUMBER 1
 
 struct InsertionRecord
@@ -44,6 +45,8 @@
     LEGlyphID glyphs[ANY_NUMBER];
 };
 
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(LEInsertionList)
+
 LEInsertionList::LEInsertionList(le_bool rightToLeft)
 : head(NULL), tail(NULL), growAmount(0), append(rightToLeft)
 {
@@ -106,3 +109,5 @@
 
     return FALSE;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/LEInsertionList.h b/src/share/native/sun/font/layout/LEInsertionList.h
--- jdk/src/share/native/sun/font/layout/LEInsertionList.h
+++ jdk/src/share/native/sun/font/layout/LEInsertionList.h
@@ -24,7 +24,6 @@
  */
 
 /*
- *
  **********************************************************************
  *   Copyright (C) 1998-2004, International Business Machines
  *   Corporation and others.  All Rights Reserved.
@@ -36,6 +35,8 @@
 
 #include "LETypes.h"
 
+U_NAMESPACE_BEGIN
+
 struct InsertionRecord;
 
 /**
@@ -78,7 +79,7 @@
  *
  * @internal
  */
-class LEInsertionList
+class LEInsertionList : public UObject
 {
 public:
     /**
@@ -140,6 +141,20 @@
      */
     void reset();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 private:
 
     /**
@@ -174,4 +189,6 @@
     le_bool  append;
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/LELanguages.h b/src/share/native/sun/font/layout/LELanguages.h
--- jdk/src/share/native/sun/font/layout/LELanguages.h
+++ jdk/src/share/native/sun/font/layout/LELanguages.h
@@ -25,10 +25,12 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2004. All Rights Reserved.
+ * (C) Copyright IBM Corp. 1998-2005. All Rights Reserved.
  *
  * WARNING: THIS FILE IS MACHINE GENERATED. DO NOT HAND EDIT IT UNLESS
  * YOU REALLY KNOW WHAT YOU'RE DOING.
+ *
+ * Generated on: 07/19/2005 01:01:08 PM PDT
  */
 
 #ifndef __LELANGUAGES_H
@@ -37,11 +39,18 @@
 #include "LETypes.h"
 
 /**
+ * \file
+ * \brief C++ API: List of language codes for LayoutEngine
+ */
+
+U_NAMESPACE_BEGIN
+
+/**
  * A provisional list of language codes. For now,
  * this is just a list of languages which the LayoutEngine
  * supports.
  *
- * @draft ICU 3.0
+ * @draft ICU 3.4
  */
 
 enum LanguageCodes {
@@ -79,4 +88,5 @@
     languageCodeCount = 30
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/LEScripts.h b/src/share/native/sun/font/layout/LEScripts.h
--- jdk/src/share/native/sun/font/layout/LEScripts.h
+++ jdk/src/share/native/sun/font/layout/LEScripts.h
@@ -25,17 +25,23 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2004. All Rights Reserved.
+ * (C) Copyright IBM Corp. 1998-2005. All Rights Reserved.
  *
  * WARNING: THIS FILE IS MACHINE GENERATED. DO NOT HAND EDIT IT UNLESS
  * YOU REALLY KNOW WHAT YOU'RE DOING.
- *
  */
 
 #ifndef __LESCRIPTS_H
 #define __LESCRIPTS_H
 
 #include "LETypes.h"
+/**
+ * \file
+ * \brief C++ API: Constants for Unicode script values
+ */
+
+
+U_NAMESPACE_BEGIN
 
 /**
  * Constants for Unicode script values, generated using
@@ -104,4 +110,5 @@
     scriptCodeCount = 55
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/LEStandalone.h b/src/share/native/sun/font/layout/LEStandalone.h
new file mode 100644
--- /dev/null
+++ jdk/src/share/native/sun/font/layout/LEStandalone.h
@@ -0,0 +1,132 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+#ifndef __LESTANDALONE
+#define __LESTANDALONE
+
+/* Definitions to make Layout Engine work away from ICU. */
+#ifndef U_NAMESPACE_BEGIN
+#define U_NAMESPACE_BEGIN
+#endif
+
+#ifndef U_NAMESPACE_END
+#define U_NAMESPACE_END
+#endif
+
+/* RTTI Definition */
+typedef const char *UClassID;
+#ifndef UOBJECT_DEFINE_RTTI_IMPLEMENTATION
+#define UOBJECT_DEFINE_RTTI_IMPLEMENTATION(x) UClassID x::getStaticClassID(){static char z=0; return (UClassID)&z; } UClassID x::getDynamicClassID() const{return x::getStaticClassID(); }
+#endif
+
+/* UMemory's functions aren't used by the layout engine. */
+struct UMemory {};
+/* UObject's functions aren't used by the layout engine. */
+struct UObject {};
+
+/* String handling */
+#include <stdlib.h>
+#include <string.h>
+
+/**
+ * A convenience macro to test for the success of a LayoutEngine call.
+ *
+ * @stable ICU 2.4
+ */
+#define LE_SUCCESS(code) ((code)<=LE_NO_ERROR)
+
+/**
+ * A convenience macro to test for the failure of a LayoutEngine call.
+ *
+ * @stable ICU 2.4
+ */
+#define LE_FAILURE(code) ((code)>LE_NO_ERROR)
+
+
+#ifndef _LP64
+typedef long le_int32;
+typedef unsigned long le_uint32;
+#else
+typedef int le_int32;
+typedef unsigned int le_uint32;
+#endif
+
+#define HAVE_LE_INT32 1
+#define HAVE_LE_UINT32 1
+
+typedef unsigned short UChar;
+typedef le_uint32 UChar32;
+
+typedef short le_int16;
+#define HAVE_LE_INT16 1
+
+typedef unsigned short le_uint16;
+#define HAVE_LE_UINT16
+
+typedef signed char le_int8;
+#define HAVE_LE_INT8
+
+typedef unsigned char le_uint8;
+#define HAVE_LE_UINT8
+
+typedef char UBool;
+
+/**
+ * Error codes returned by the LayoutEngine.
+ *
+ * @stable ICU 2.4
+ */
+enum LEErrorCode {
+    /* informational */
+    LE_NO_SUBFONT_WARNING           = -127, // U_USING_DEFAULT_WARNING,
+
+    /* success */
+    LE_NO_ERROR                     = 0, // U_ZERO_ERROR,
+
+    /* failures */
+    LE_ILLEGAL_ARGUMENT_ERROR       = 1, // U_ILLEGAL_ARGUMENT_ERROR,
+    LE_MEMORY_ALLOCATION_ERROR      = 7, // U_MEMORY_ALLOCATION_ERROR,
+    LE_INDEX_OUT_OF_BOUNDS_ERROR    = 8, //U_INDEX_OUTOFBOUNDS_ERROR,
+    LE_NO_LAYOUT_ERROR              = 16, // U_UNSUPPORTED_ERROR,
+    LE_INTERNAL_ERROR               = 5, // U_INTERNAL_PROGRAM_ERROR,
+    LE_FONT_FILE_NOT_FOUND_ERROR    = 4, // U_FILE_ACCESS_ERROR,
+    LE_MISSING_FONT_TABLE_ERROR     = 2  // U_MISSING_RESOURCE_ERROR
+};
+#define HAVE_LEERRORCODE
+
+#define U_LAYOUT_API
+
+#define uprv_malloc malloc
+#define uprv_free free
+#define uprv_memcpy memcpy
+#define uprv_realloc realloc
+
+#if !defined(U_IS_BIG_ENDIAN)
+    #ifdef _LITTLE_ENDIAN
+        #define U_IS_BIG_ENDIAN 0
+    #endif
+#endif
+
+#endif
diff --git a/src/share/native/sun/font/layout/LESwaps.h b/src/share/native/sun/font/layout/LESwaps.h
--- jdk/src/share/native/sun/font/layout/LESwaps.h
+++ jdk/src/share/native/sun/font/layout/LESwaps.h
@@ -26,7 +26,7 @@
 
 /*
  *
- * (C) Copyright IBM Corp. 1998-2004 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
  *
  */
 
@@ -35,11 +35,12 @@
 
 #include "LETypes.h"
 
-#if !defined(U_IS_BIG_ENDIAN)
-    #ifdef _LITTLE_ENDIAN
-        #define U_IS_BIG_ENDIAN 0
-    #endif
-#endif
+/**
+ * \file
+ * \brief C++ API: Endian independent access to data for LayoutEngine
+ */
+
+U_NAMESPACE_BEGIN
 
 /**
  * A convenience macro which invokes the swapWord member function
@@ -47,7 +48,6 @@
  *
  * @stable ICU 2.8
  */
-
 #if defined(U_IS_BIG_ENDIAN)
     #if U_IS_BIG_ENDIAN
         #define SWAPW(value) (value)
@@ -64,7 +64,6 @@
  *
  * @stable ICU 2.8
  */
-
 #if defined(U_IS_BIG_ENDIAN)
     #if U_IS_BIG_ENDIAN
         #define SWAPL(value) (value)
@@ -86,8 +85,7 @@
  *
  * @stable ICU 2.8
  */
-class LESwaps
-{
+class U_LAYOUT_API LESwaps /* not : public UObject because all methods are static */ {
 public:
 
 #if !defined(U_IS_BIG_ENDIAN)
@@ -144,4 +142,5 @@
     LESwaps() {} // private - forbid instantiation
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/LETypes.h b/src/share/native/sun/font/layout/LETypes.h
--- jdk/src/share/native/sun/font/layout/LETypes.h
+++ jdk/src/share/native/sun/font/layout/LETypes.h
@@ -23,7 +23,6 @@
  *
  */
 
-
 /*
  *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
@@ -33,73 +32,97 @@
 #ifndef __LETYPES_H
 #define __LETYPES_H
 
+/**
+ * If LE_Standalone is defined, it must exist and contain
+ * definitions for some core ICU defines.
+ */
+#ifdef LE_STANDALONE
+#include "LEStandalone.h"
+#endif
+
+#ifdef LE_STANDALONE
+/* Stand-alone Layout Engine- without ICU. */
+#include "LEStandalone.h"
 #define LE_USE_CMEMORY
+#else
+#if !defined(LE_USE_CMEMORY) && (defined(U_LAYOUT_IMPLEMENTATION) || defined(U_LAYOUTEX_IMPLEMENTATION) || defined(U_STATIC_IMPLEMENTATION) || defined(U_COMBINED_IMPLEMENTATION))
+#define LE_USE_CMEMORY
+#endif
 
+#include "unicode/utypes.h"
+#include "unicode/uobject.h"
 #ifdef LE_USE_CMEMORY
 #include "cmemory.h"
 #endif
+#endif /* not standalone */
 
-#ifndef _LP64
-typedef long le_int32;
-typedef unsigned long le_uint32;
-#else
-typedef int le_int32;
-typedef unsigned int le_uint32;
-#endif
+U_NAMESPACE_BEGIN
 
-typedef short le_int16;
-typedef unsigned short le_uint16;
-typedef signed char le_int8;
-typedef unsigned char le_uint8;
-typedef char le_bool;
+/*!
+ * \file
+ * \brief Basic definitions for the ICU LayoutEngine
+ */
 
-typedef char UClassID;
-
-#if 0
 /**
  * A type used for signed, 32-bit integers.
  *
  * @stable ICU 2.4
  */
+#ifndef HAVE_LE_INT32
 typedef int32_t le_int32;
+#endif
 
 /**
  * A type used for unsigned, 32-bit integers.
  *
  * @stable ICU 2.4
  */
+#ifndef HAVE_LE_UINT32
 typedef uint32_t le_uint32;
+#endif
 
 /**
  * A type used for signed, 16-bit integers.
  *
  * @stable ICU 2.4
  */
+#ifndef HAVE_LE_INT16
 typedef int16_t le_int16;
+#endif
 
+#ifndef HAVE_LE_UINT16
 /**
  * A type used for unsigned, 16-bit integers.
  *
  * @stable ICU 2.4
  */
 typedef uint16_t le_uint16;
+#endif
 
+#ifndef HAVE_LE_INT8
 /**
  * A type used for signed, 8-bit integers.
  *
  * @stable ICU 2.4
  */
 typedef int8_t le_int8;
-
+#endif
+ 
+#ifndef HAVE_LE_UINT8
 /**
  * A type used for unsigned, 8-bit integers.
  *
  * @stable ICU 2.4
  */
 typedef uint8_t le_uint8;
+#endif
 
-typedef char le_bool;
-#endif
+/**
+* A type used for boolean values.
+*
+* @stable ICU 2.4
+*/
+typedef UBool le_bool;
 
 #ifndef TRUE
 /**
@@ -292,21 +315,21 @@
  *
  * @stable ICU 2.4
  */
-typedef le_uint16 LEUnicode16;
+typedef UChar LEUnicode16;
 
 /**
  * Used to represent 32-bit Unicode code points.
  *
  * @stable ICU 2.4
  */
-typedef le_uint32 LEUnicode32;
+typedef UChar32 LEUnicode32;
 
 /**
  * Used to represent 16-bit Unicode code points.
  *
  * @deprecated since ICU 2.4. Use LEUnicode16 instead
  */
-typedef le_uint16 LEUnicode;
+typedef UChar LEUnicode;
 
 /**
  * Used to hold a pair of (x, y) values which represent a point.
@@ -353,7 +376,7 @@
  *
  * @internal
  */
-#define LE_ARRAY_COPY(dst, src, count) memcpy((void *) (dst), (void *) (src), (count) * sizeof (src)[0])
+#define LE_ARRAY_COPY(dst, src, count) uprv_memcpy((void *) (dst), (void *) (src), (count) * sizeof (src)[0])
 
 /**
  * Allocate an array of basic types. This is used to isolate the rest of
@@ -361,7 +384,7 @@
  *
  * @internal
  */
-#define LE_NEW_ARRAY(type, count) (type *) malloc((count) * sizeof(type))
+#define LE_NEW_ARRAY(type, count) (type *) uprv_malloc((count) * sizeof(type))
 
 /**
  * Re-allocate an array of basic types. This is used to isolate the rest of
@@ -369,7 +392,7 @@
  *
  * @internal
  */
-#define LE_GROW_ARRAY(array, newSize) realloc((void *) (array), (newSize) * sizeof (array)[0])
+#define LE_GROW_ARRAY(array, newSize) uprv_realloc((void *) (array), (newSize) * sizeof (array)[0])
 
  /**
  * Free an array of basic types. This is used to isolate the rest of
@@ -377,7 +400,7 @@
  *
  * @internal
  */
-#define LE_DELETE_ARRAY(array) free((void *) (array))
+#define LE_DELETE_ARRAY(array) uprv_free((void *) (array))
 #endif
 
 /**
@@ -595,22 +618,24 @@
  *
  * @stable ICU 2.4
  */
+#ifndef HAVE_LEERRORCODE
 enum LEErrorCode {
     /* informational */
-    LE_NO_SUBFONT_WARNING           = -127, // U_USING_DEFAULT_WARNING,
+    LE_NO_SUBFONT_WARNING          = U_USING_DEFAULT_WARNING, /**< The font does not contain subfonts. */
 
     /* success */
-    LE_NO_ERROR                     = 0, // U_ZERO_ERROR,
+    LE_NO_ERROR                     = U_ZERO_ERROR, /**< No error, no warning. */
 
     /* failures */
-    LE_ILLEGAL_ARGUMENT_ERROR       = 1, // U_ILLEGAL_ARGUMENT_ERROR,
-    LE_MEMORY_ALLOCATION_ERROR      = 7, // U_MEMORY_ALLOCATION_ERROR,
-    LE_INDEX_OUT_OF_BOUNDS_ERROR    = 8, //U_INDEX_OUTOFBOUNDS_ERROR,
-    LE_NO_LAYOUT_ERROR              = 16, // U_UNSUPPORTED_ERROR,
-    LE_INTERNAL_ERROR               = 5, // U_INTERNAL_PROGRAM_ERROR,
-    LE_FONT_FILE_NOT_FOUND_ERROR    = 4, // U_FILE_ACCESS_ERROR,
-    LE_MISSING_FONT_TABLE_ERROR     = 2  // U_MISSING_RESOURCE_ERROR
+    LE_ILLEGAL_ARGUMENT_ERROR       = U_ILLEGAL_ARGUMENT_ERROR,  /**< An illegal argument was detected. */
+    LE_MEMORY_ALLOCATION_ERROR      = U_MEMORY_ALLOCATION_ERROR, /**< Memory allocation error. */
+    LE_INDEX_OUT_OF_BOUNDS_ERROR    = U_INDEX_OUTOFBOUNDS_ERROR, /**< Trying to access an index that is out of bounds. */
+    LE_NO_LAYOUT_ERROR              = U_UNSUPPORTED_ERROR,       /**< You must call layoutChars() first. */
+    LE_INTERNAL_ERROR               = U_INTERNAL_PROGRAM_ERROR,  /**< An internal error was encountered. */
+    LE_FONT_FILE_NOT_FOUND_ERROR    = U_FILE_ACCESS_ERROR,       /**< The requested font file cannot be opened. */
+    LE_MISSING_FONT_TABLE_ERROR     = U_MISSING_RESOURCE_ERROR   /**< The requested font table does not exist. */
 };
+#endif
 
 #ifndef XP_CPLUSPLUS
 /**
@@ -626,7 +651,9 @@
  *
  * @stable ICU 2.4
  */
-#define LE_SUCCESS(code) ((code)<=LE_NO_ERROR)
+#ifndef LE_FAILURE
+#define LE_SUCCESS(code) (U_SUCCESS((UErrorCode)code))
+#endif
 
 enum LEFeatureENUMs {
  LE_Kerning_FEATURE_ENUM = 0,
@@ -648,7 +675,11 @@
  *
  * @stable ICU 2.4
  */
-#define LE_FAILURE(code) ((code)>LE_NO_ERROR)
+#ifndef LE_FAILURE
+#define LE_FAILURE(code) (U_FAILURE((UErrorCode)code))
+#endif
 
-#define U_LAYOUT_API
+U_NAMESPACE_END
 #endif
+
+
diff --git a/src/share/native/sun/font/layout/LayoutEngine.cpp b/src/share/native/sun/font/layout/LayoutEngine.cpp
--- jdk/src/share/native/sun/font/layout/LayoutEngine.cpp
+++ jdk/src/share/native/sun/font/layout/LayoutEngine.cpp
@@ -23,6 +23,7 @@
  *
  */
 
+
 /*
  *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
@@ -41,6 +42,7 @@
 #include "IndicLayoutEngine.h"
 #include "KhmerLayoutEngine.h"
 #include "ThaiLayoutEngine.h"
+//#include "TibetanLayoutEngine.h"
 #include "GXLayoutEngine.h"
 #include "ScriptAndLanguageTags.h"
 #include "CharSubstitutionFilter.h"
@@ -56,6 +58,8 @@
 
 #include "KernTable.h"
 
+U_NAMESPACE_BEGIN
+
 const LEUnicode32 DefaultCharMapper::controlChars[] = {
     0x0009, 0x000A, 0x000D,
     /*0x200C, 0x200D,*/ 0x200E, 0x200F,
@@ -102,9 +106,7 @@
     }
 
     if (fMirror) {
-        le_int32 index = OpenTypeUtilities::search((le_uint32) ch,
-                                                   (le_uint32 *)DefaultCharMapper::mirroredChars,
-                                                   DefaultCharMapper::mirroredCharsCount);
+        le_int32 index = OpenTypeUtilities::search((le_uint32) ch, (le_uint32 *)DefaultCharMapper::mirroredChars, DefaultCharMapper::mirroredCharsCount);
 
         if (mirroredChars[index] == ch) {
             return DefaultCharMapper::srahCderorrim[index];
@@ -133,6 +135,9 @@
     // nothing to do
 }
 
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(LayoutEngine)
+
 #define ccmpFeatureTag  LE_CCMP_FEATURE_TAG
 
 #define ccmpFeatureMask 0x80000000UL
@@ -146,10 +151,9 @@
 
 static const le_int32 canonFeatureMapCount = LE_ARRAY_SIZE(canonFeatureMap);
 
-LayoutEngine::LayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode,
-    le_int32 languageCode, le_int32 typoFlags)
-  : fGlyphStorage(NULL), fFontInstance(fontInstance), fScriptCode(scriptCode),
-    fLanguageCode(languageCode), fTypoFlags(typoFlags)
+LayoutEngine::LayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags)
+  : fGlyphStorage(NULL), fFontInstance(fontInstance), fScriptCode(scriptCode), fLanguageCode(languageCode),
+    fTypoFlags(typoFlags)
 {
     fGlyphStorage = new LEGlyphStorage();
 }
@@ -159,8 +163,7 @@
     return fGlyphStorage->getGlyphCount();
 }
 
-void LayoutEngine::getCharIndices(le_int32 charIndices[], le_int32 indexBase,
-    LEErrorCode &success) const
+void LayoutEngine::getCharIndices(le_int32 charIndices[], le_int32 indexBase, LEErrorCode &success) const
 {
     fGlyphStorage->getCharIndices(charIndices, indexBase, success);
 }
@@ -171,8 +174,7 @@
 }
 
 // Copy the glyphs into caller's (32-bit) glyph array, OR in extraBits
-void LayoutEngine::getGlyphs(le_uint32 glyphs[], le_uint32 extraBits,
-    LEErrorCode &success) const
+void LayoutEngine::getGlyphs(le_uint32 glyphs[], le_uint32 extraBits, LEErrorCode &success) const
 {
     fGlyphStorage->getGlyphs(glyphs, extraBits, success);
 }
@@ -219,15 +221,13 @@
     fGlyphStorage->getGlyphPositions(positions, success);
 }
 
-void LayoutEngine::getGlyphPosition(le_int32 glyphIndex, float &x, float &y,
-    LEErrorCode &success) const
+void LayoutEngine::getGlyphPosition(le_int32 glyphIndex, float &x, float &y, LEErrorCode &success) const
 {
     fGlyphStorage->getGlyphPosition(glyphIndex, x, y, success);
 }
 
-le_int32 LayoutEngine::characterProcessing(const LEUnicode chars[], le_int32 offset,
-    le_int32 count, le_int32 max, le_bool rightToLeft, LEUnicode *&outChars,
-    LEGlyphStorage &glyphStorage, LEErrorCode &success)
+le_int32 LayoutEngine::characterProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+                LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
@@ -238,12 +238,7 @@
         return 0;
     }
 
-    if ((fTypoFlags & 0x4) == 0) { // no canonical processing
-        return count;
-    }
-
-    const GlyphSubstitutionTableHeader *canonGSUBTable =
-        (GlyphSubstitutionTableHeader *) CanonShaping::glyphSubstitutionTable;
+    const GlyphSubstitutionTableHeader *canonGSUBTable = (GlyphSubstitutionTableHeader *) CanonShaping::glyphSubstitutionTable;
     LETag scriptTag  = OpenTypeLayoutEngine::getScriptTag(fScriptCode);
     LETag langSysTag = OpenTypeLayoutEngine::getLangSysTag(fLanguageCode);
     le_int32 i, dir = 1, out = 0, outCharCount = count;
@@ -257,16 +252,15 @@
                 // We could just do the mark reordering for all scripts, but most
                 // of them probably don't need it...
                 if (fScriptCode == hebrScriptCode) {
-                    reordered = LE_NEW_ARRAY(LEUnicode, count);
+                        reordered = LE_NEW_ARRAY(LEUnicode, count);
 
-                    if (reordered == NULL) {
-                        success = LE_MEMORY_ALLOCATION_ERROR;
-                        return 0;
-                    }
+                        if (reordered == NULL) {
+                                success = LE_MEMORY_ALLOCATION_ERROR;
+                                return 0;
+                        }
 
-                    CanonShaping::reorderMarks(&chars[offset], count, rightToLeft,
-                        reordered, glyphStorage);
-                    inChars = reordered;
+                        CanonShaping::reorderMarks(&chars[offset], count, rightToLeft, reordered, glyphStorage);
+                        inChars = reordered;
                 }
 
         glyphStorage.allocateGlyphArray(count, rightToLeft, success);
@@ -290,8 +284,7 @@
                         LE_DELETE_ARRAY(reordered);
                 }
 
-        outCharCount = canonGSUBTable->process(glyphStorage, rightToLeft, scriptTag,
-            langSysTag, NULL, substitutionFilter, canonFeatureMap, canonFeatureMapCount, FALSE);
+        outCharCount = canonGSUBTable->process(glyphStorage, rightToLeft, scriptTag, langSysTag, NULL, substitutionFilter, canonFeatureMap, canonFeatureMapCount, FALSE);
 
         out = (rightToLeft? outCharCount - 1 : 0);
 
@@ -306,35 +299,26 @@
     return outCharCount;
 }
 
-
-le_int32 LayoutEngine::computeGlyphs(const LEUnicode chars[], le_int32 offset,
-    le_int32 count, le_int32 max, le_bool rightToLeft,
-    LEGlyphStorage &glyphStorage, LEErrorCode &success)
+le_int32 LayoutEngine::computeGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+                                            LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
     }
 
-    if (chars == NULL || offset < 0 || count < 0 || max < 0 || offset >= max ||
-        offset + count > max) {
-
+    if (chars == NULL || offset < 0 || count < 0 || max < 0 || offset >= max || offset + count > max) {
         success = LE_ILLEGAL_ARGUMENT_ERROR;
         return 0;
     }
 
     LEUnicode *outChars = NULL;
-    le_int32 outCharCount = characterProcessing(chars, offset, count, max,
-        rightToLeft, outChars, glyphStorage, success);
+    le_int32 outCharCount = characterProcessing(chars, offset, count, max, rightToLeft, outChars, glyphStorage, success);
 
     if (outChars != NULL) {
-        mapCharsToGlyphs(outChars, 0, outCharCount, rightToLeft, rightToLeft,
-            glyphStorage, success);
-        // FIXME: a subclass may have allocated this, in which case this delete
-        // might not work...
-        LE_DELETE_ARRAY(outChars);
+        mapCharsToGlyphs(outChars, 0, outCharCount, rightToLeft, rightToLeft, glyphStorage, success);
+        LE_DELETE_ARRAY(outChars); // FIXME: a subclass may have allocated this, in which case this delete might not work...
     } else {
-        mapCharsToGlyphs(chars, offset, count, rightToLeft, rightToLeft,
-            glyphStorage, success);
+        mapCharsToGlyphs(chars, offset, count, rightToLeft, rightToLeft, glyphStorage, success);
     }
 
     return glyphStorage.getGlyphCount();
@@ -342,8 +326,7 @@
 
 // Input: glyphs
 // Output: positions
-void LayoutEngine::positionGlyphs(LEGlyphStorage &glyphStorage,
-    float x, float y, LEErrorCode &success)
+void LayoutEngine::positionGlyphs(LEGlyphStorage &glyphStorage, float x, float y, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return;
@@ -370,9 +353,8 @@
     glyphStorage.setPosition(glyphCount, x, y, success);
 }
 
-void LayoutEngine::adjustGlyphPositions(const LEUnicode chars[], le_int32 offset,
-    le_int32 count, le_bool reverse,
-    LEGlyphStorage &glyphStorage, LEErrorCode &success)
+void LayoutEngine::adjustGlyphPositions(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse,
+                                        LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return;
@@ -399,8 +381,7 @@
     return;
 }
 
-void LayoutEngine::adjustMarkGlyphs(LEGlyphStorage &glyphStorage,
-    LEGlyphFilter *markFilter, LEErrorCode &success)
+void LayoutEngine::adjustMarkGlyphs(LEGlyphStorage &glyphStorage, LEGlyphFilter *markFilter, LEErrorCode &success)
 {
     float xAdjust = 0;
     le_int32 p, glyphCount = glyphStorage.getGlyphCount();
@@ -436,9 +417,7 @@
     glyphStorage.adjustPosition(glyphCount, xAdjust, 0, success);
 }
 
-void LayoutEngine::adjustMarkGlyphs(const LEUnicode chars[], le_int32 charCount,
-    le_bool reverse, LEGlyphStorage &glyphStorage, LEGlyphFilter *markFilter,
-    LEErrorCode &success)
+void LayoutEngine::adjustMarkGlyphs(const LEUnicode chars[], le_int32 charCount, le_bool reverse, LEGlyphStorage &glyphStorage, LEGlyphFilter *markFilter, LEErrorCode &success)
 {
     float xAdjust = 0;
     le_int32 c = 0, direction = 1, p;
@@ -485,9 +464,8 @@
     return fFontInstance->getFontTable(tableTag);
 }
 
-void LayoutEngine::mapCharsToGlyphs(const LEUnicode chars[], le_int32 offset,
-    le_int32 count, le_bool reverse, le_bool mirror,
-    LEGlyphStorage &glyphStorage, LEErrorCode &success)
+void LayoutEngine::mapCharsToGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse, le_bool mirror,
+                                    LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return;
@@ -497,32 +475,27 @@
 
     DefaultCharMapper charMapper(TRUE, mirror);
 
-    fFontInstance->mapCharsToGlyphs(chars, offset, count, reverse,
-        &charMapper, glyphStorage);
+    fFontInstance->mapCharsToGlyphs(chars, offset, count, reverse, &charMapper, glyphStorage);
 }
 
 // Input: characters, font?
 // Output: glyphs, positions, char indices
 // Returns: number of glyphs
-le_int32 LayoutEngine::layoutChars(const LEUnicode chars[], le_int32 offset,
-    le_int32 count, le_int32 max, le_bool rightToLeft,
-    float x, float y, LEErrorCode &success)
+le_int32 LayoutEngine::layoutChars(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+                              float x, float y, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
     }
 
-    if (chars == NULL || offset < 0 || count < 0 || max < 0 || offset >= max ||
-        offset + count > max) {
-
+    if (chars == NULL || offset < 0 || count < 0 || max < 0 || offset >= max || offset + count > max) {
         success = LE_ILLEGAL_ARGUMENT_ERROR;
         return 0;
     }
 
     le_int32 glyphCount;
 
-    glyphCount = computeGlyphs(chars, offset, count, max, rightToLeft,
-        *fGlyphStorage, success);
+    glyphCount = computeGlyphs(chars, offset, count, max, rightToLeft, *fGlyphStorage, success);
     positionGlyphs(*fGlyphStorage, x, y, success);
     adjustGlyphPositions(chars, offset, count, rightToLeft, *fGlyphStorage, success);
 
@@ -534,17 +507,13 @@
     fGlyphStorage->reset();
 }
 
-LayoutEngine *LayoutEngine::layoutEngineFactory(const LEFontInstance *fontInstance,
-    le_int32 scriptCode, le_int32 languageCode, LEErrorCode &success)
+LayoutEngine *LayoutEngine::layoutEngineFactory(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, LEErrorCode &success)
 {
   // 3 -> kerning and ligatures
-  return LayoutEngine::layoutEngineFactory(fontInstance, scriptCode,
-        languageCode, LE_DEFAULT_FEATURE_FLAG, success);
+  return LayoutEngine::layoutEngineFactory(fontInstance, scriptCode, languageCode, LE_DEFAULT_FEATURE_FLAG, success);
 }
 
-LayoutEngine *LayoutEngine::layoutEngineFactory(const LEFontInstance *fontInstance,
-    le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags,
-    LEErrorCode &success)
+LayoutEngine *LayoutEngine::layoutEngineFactory(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags, LEErrorCode &success)
 {
     static const le_uint32 gsubTableTag = LE_GSUB_TABLE_TAG;
     static const le_uint32 mortTableTag = LE_MORT_TABLE_TAG;
@@ -553,18 +522,12 @@
         return NULL;
     }
 
-    // code2000 has GPOS kern feature tags for latn script
-
-    const GlyphSubstitutionTableHeader *gsubTable =
-        (const GlyphSubstitutionTableHeader *) fontInstance->getFontTable(gsubTableTag);
+    const GlyphSubstitutionTableHeader *gsubTable = (const GlyphSubstitutionTableHeader *) fontInstance->getFontTable(gsubTableTag);
     LayoutEngine *result = NULL;
     LETag scriptTag   = 0x00000000;
     LETag languageTag = 0x00000000;
 
-    if (gsubTable != NULL &&
-        gsubTable->coversScript(scriptTag =
-            OpenTypeLayoutEngine::getScriptTag(scriptCode))) {
-
+    if (gsubTable != NULL && gsubTable->coversScript(scriptTag = OpenTypeLayoutEngine::getScriptTag(scriptCode))) {
         switch (scriptCode) {
         case bengScriptCode:
         case devaScriptCode:
@@ -576,13 +539,11 @@
         case tamlScriptCode:
         case teluScriptCode:
         case sinhScriptCode:
-            result = new IndicOpenTypeLayoutEngine(fontInstance, scriptCode,
-             languageCode, typoFlags, gsubTable);
+            result = new IndicOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable);
             break;
 
         case arabScriptCode:
-            result = new ArabicOpenTypeLayoutEngine(fontInstance, scriptCode,
-             languageCode, typoFlags, gsubTable);
+            result = new ArabicOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable);
             break;
 
         case haniScriptCode:
@@ -594,33 +555,33 @@
             case zhtLanguageCode:
             case zhsLanguageCode:
                 if (gsubTable->coversScriptAndLanguage(scriptTag, languageTag, TRUE)) {
-                    result = new HanOpenTypeLayoutEngine(fontInstance, scriptCode,
-                        languageCode, typoFlags, gsubTable);
+                    result = new HanOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable);
                     break;
                 }
 
                 // note: falling through to default case.
             default:
-                result = new OpenTypeLayoutEngine(fontInstance, scriptCode,
-                 languageCode, typoFlags, gsubTable);
+                result = new OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable);
                 break;
             }
 
             break;
+#if 0
+        case tibtScriptCode:
+             result = new TibetanOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable);
+            break;
+#endif
 
         case khmrScriptCode:
-            result = new KhmerOpenTypeLayoutEngine(fontInstance, scriptCode,
-                languageCode, typoFlags, gsubTable);
+            result = new KhmerOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable);
             break;
 
         default:
-            result = new OpenTypeLayoutEngine(fontInstance, scriptCode,
-             languageCode, typoFlags, gsubTable);
+            result = new OpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags, gsubTable);
             break;
         }
     } else {
-        const MorphTableHeader *morphTable =
-          (MorphTableHeader *) fontInstance->getFontTable(mortTableTag);
+        const MorphTableHeader *morphTable = (MorphTableHeader *) fontInstance->getFontTable(mortTableTag);
 
         if (morphTable != NULL && SWAPL(morphTable->version)==0x00010000) {
             result = new GXLayoutEngine(fontInstance, scriptCode, languageCode, morphTable);
@@ -637,16 +598,18 @@
             case teluScriptCode:
             case sinhScriptCode:
             {
-                result = new IndicOpenTypeLayoutEngine(fontInstance, scriptCode,
-                languageCode, typoFlags);
+                result = new IndicOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags);
                 break;
             }
 
             case arabScriptCode:
-                result = new UnicodeArabicOpenTypeLayoutEngine(fontInstance, scriptCode,
-                    languageCode, typoFlags);
+            //case hebrScriptCode:
+                result = new UnicodeArabicOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags);
                 break;
 
+            //case hebrScriptCode:
+            //    return new HebrewOpenTypeLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags);
+
             case thaiScriptCode:
                 result = new ThaiLayoutEngine(fontInstance, scriptCode, languageCode, typoFlags);
                 break;
@@ -668,3 +631,5 @@
 LayoutEngine::~LayoutEngine() {
     delete fGlyphStorage;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/LayoutEngine.h b/src/share/native/sun/font/layout/LayoutEngine.h
--- jdk/src/share/native/sun/font/layout/LayoutEngine.h
+++ jdk/src/share/native/sun/font/layout/LayoutEngine.h
@@ -23,6 +23,7 @@
  *
  */
 
+
 /*
  *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
@@ -34,63 +35,61 @@
 
 #include "LETypes.h"
 
-#include <string.h>
+/**
+ * \file
+ * \brief C++ API: Virtual base class for complex text layout.
+ */
+
+U_NAMESPACE_BEGIN
 
 class LEFontInstance;
 class LEGlyphFilter;
 class LEGlyphStorage;
 
 /**
- * This is a virtual base class used to do complex text layout. The
- * text must all be in a single font, script, and language. An
- * instance of a LayoutEngine can be created by calling the
- * layoutEngineFactory method. Fonts are identified by instances of
- * the LEFontInstance class. Script and language codes are identified
+ * This is a virtual base class used to do complex text layout. The text must all
+ * be in a single font, script, and language. An instance of a LayoutEngine can be
+ * created by calling the layoutEngineFactory method. Fonts are identified by
+ * instances of the LEFontInstance class. Script and language codes are identified
  * by integer codes, which are defined in ScriptAndLanuageTags.h.
  *
- * Note that this class is not public API. It is declared public so
- * that it can be exported from the library that it is a part of.
+ * Note that this class is not public API. It is declared public so that it can be
+ * exported from the library that it is a part of.
  *
- * The input to the layout process is an array of characters in
- * logical order, and a starting X, Y position for the text. The
- * output is an array of glyph indices, an array of character indices
- * for the glyphs, and an array of glyph positions.  These arrays are
- * protected members of LayoutEngine which can be retreived by a
- * public method. The reset method can be called to free these arrays
- * so that the LayoutEngine can be reused.
+ * The input to the layout process is an array of characters in logical order,
+ * and a starting X, Y position for the text. The output is an array of glyph indices,
+ * an array of character indices for the glyphs, and an array of glyph positions.
+ * These arrays are protected members of LayoutEngine which can be retreived by a
+ * public method. The reset method can be called to free these arrays so that the
+ * LayoutEngine can be reused.
  *
- * The layout process is done in three steps. There is a protected
- * virtual method for each step. These methods have a default
- * implementation which only does character to glyph mapping and
- * default positioning using the glyph's advance widths. Subclasses
- * can override these methods for more advanced layout.  There is a
- * public method which invokes the steps in the correct order.
+ * The layout process is done in three steps. There is a protected virtual method
+ * for each step. These methods have a default implementation which only does
+ * character to glyph mapping and default positioning using the glyph's advance
+ * widths. Subclasses can override these methods for more advanced layout.
+ * There is a public method which invokes the steps in the correct order.
  *
  * The steps are:
  *
- * 1) Glyph processing - character to glyph mapping and any other
- *    glyph processing such as ligature substitution and contextual
- *    forms.
+ * 1) Glyph processing - character to glyph mapping and any other glyph processing
+ *    such as ligature substitution and contextual forms.
  *
- * 2) Glyph positioning - position the glyphs based on their advance
- *    widths.
+ * 2) Glyph positioning - position the glyphs based on their advance widths.
  *
- * 3) Glyph position adjustments - adjustment of glyph positions for
- *    kerning, accent placement, etc.
+ * 3) Glyph position adjustments - adjustment of glyph positions for kerning,
+ *    accent placement, etc.
  *
- * NOTE: in all methods below, output parameters are references to
- * pointers so the method can allocate and free the storage as
- * needed. All storage allocated in this way is owned by the object
- * which created it, and will be freed when it is no longer needed, or
- * when the object's destructor is invoked.
+ * NOTE: in all methods below, output parameters are references to pointers so
+ * the method can allocate and free the storage as needed. All storage allocated
+ * in this way is owned by the object which created it, and will be freed when it
+ * is no longer needed, or when the object's destructor is invoked.
  *
  * @see LEFontInstance
  * @see ScriptAndLanguageTags.h
  *
  * @stable ICU 2.8
  */
-class U_LAYOUT_API LayoutEngine
-{
+class U_LAYOUT_API LayoutEngine : public UObject {
 protected:
     /**
      * The object which holds the glyph storage
@@ -134,21 +133,21 @@
     le_int32 fTypoFlags;
 
     /**
-     * This constructs an instance for a given font, script and
-     * language. Subclass constructors
+     * This constructs an instance for a given font, script and language. Subclass constructors
      * must call this constructor.
      *
      * @param fontInstance - the font for the text
      * @param scriptCode - the script for the text
      * @param languageCode - the language for the text
+     * @param typoFlags - the typographic control flags for the text.  Set bit 1 if kerning
+     * is desired, set bit 2 if ligature formation is desired.  Others are reserved.
      *
      * @see LEFontInstance
      * @see ScriptAndLanguageTags.h
      *
      * @internal
      */
-    LayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode,
-        le_int32 languageCode, le_int32 typoFlags);
+    LayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags);
 
     /**
      * This overrides the default no argument constructor to make it
@@ -160,11 +159,10 @@
     LayoutEngine();
 
     /**
-     * This method does any required pre-processing to the input
-     * characters. It may generate output characters that differ from
-     * the input charcters due to insertions, deletions, or
-     * reorderings. In such cases, it will also generate an output
-     * character index array reflecting these changes.
+     * This method does any required pre-processing to the input characters. It
+     * may generate output characters that differ from the input charcters due to
+     * insertions, deletions, or reorderings. In such cases, it will also generate an
+     * output character index array reflecting these changes.
      *
      * Subclasses must override this method.
      *
@@ -173,44 +171,36 @@
      * @param offset - the index of the first character to process
      * @param count - the number of characters to process
      * @param max - the number of characters in the input context
-     * @param rightToLeft - TRUE if the characters are in a right to
-     *     left directional run
-     * @param outChars - the output character array, if different from
-     *     the input
-     * @param glyphStorage - the object that holds the per-glyph
-     *     storage. The character index array may be set.
+     * @param rightToLeft - TRUE if the characters are in a right to left directional run
+     * @param outChars - the output character array, if different from the input
+     * @param glyphStorage - the object that holds the per-glyph storage. The character index array may be set.
      * @param success - set to an error code if the operation fails
-     * @return the output character count (input character count if no
-     *     change)
+     *
+     * @return the output character count (input character count if no change)
      *
      * @internal
      */
-    virtual le_int32 characterProcessing(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_int32 max, le_bool rightToLeft,
-        LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual le_int32 characterProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+            LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     /**
-     * This method does the glyph processing. It converts an array of
-     * characters into an array of glyph indices and character
-     * indices. The characters to be processed are passed in a
-     * surrounding context. The context is specified as a starting
-     * address and a maximum character count. An offset and a count
-     * are used to specify the characters to be processed.
+     * This method does the glyph processing. It converts an array of characters
+     * into an array of glyph indices and character indices. The characters to be
+     * processed are passed in a surrounding context. The context is specified as
+     * a starting address and a maximum character count. An offset and a count are
+     * used to specify the characters to be processed.
      *
-     * The default implementation of this method only does character
-     * to glyph mapping.  Subclasses needing more elaborate glyph
-     * processing must override this method.
+     * The default implementation of this method only does character to glyph mapping.
+     * Subclasses needing more elaborate glyph processing must override this method.
      *
      * Input parameters:
      * @param chars - the character context
      * @param offset - the offset of the first character to process
      * @param count - the number of characters to process
      * @param max - the number of characters in the context.
-     * @param rightToLeft - TRUE if the text is in a right to left
-     *            directional run
-     * @param glyphStorage - the object which holds the per-glyph
-     *            storage. The glyph and char indices arrays will be
-     *            set.
+     * @param rightToLeft - TRUE if the text is in a right to left directional run
+     * @param glyphStorage - the object which holds the per-glyph storage. The glyph and char indices arrays
+     *                       will be set.
      *
      * Output parameters:
      * @param success - set to an error code if the operation fails
@@ -219,60 +209,50 @@
      *
      * @internal
      */
-    virtual le_int32 computeGlyphs(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_int32 max, le_bool rightToLeft,
-        LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual le_int32 computeGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     /**
-     * This method does basic glyph positioning. The default
-     * implementation positions the glyphs based on their advance
-     * widths. This is sufficient for most uses. It is not expected
-     * that many subclasses will override this method.
+     * This method does basic glyph positioning. The default implementation positions
+     * the glyphs based on their advance widths. This is sufficient for most uses. It
+     * is not expected that many subclasses will override this method.
      *
      * Input parameters:
-     * @param glyphStorage - the object which holds the per-glyph storage.
-     *            The glyph position array will be set.
+     * @param glyphStorage - the object which holds the per-glyph storage. The glyph position array will be set.
      * @param x - the starting X position
      * @param y - the starting Y position
      * @param success - set to an error code if the operation fails
      *
      * @internal
      */
-    virtual void positionGlyphs(LEGlyphStorage &glyphStorage,
-                     float x, float y, LEErrorCode &success);
+    virtual void positionGlyphs(LEGlyphStorage &glyphStorage, float x, float y, LEErrorCode &success);
 
     /**
-     * This method does positioning adjustments like accent
-     * positioning and kerning. The default implementation does
-     * nothing. Subclasses needing position adjustments must override
-     * this method.
+     * This method does positioning adjustments like accent positioning and
+     * kerning. The default implementation does nothing. Subclasses needing
+     * position adjustments must override this method.
      *
-     * Note that this method has both characters and glyphs as input
-     * so that it can use the character codes to determine glyph types
-     * if that information isn't directly available. (e.g. Some Arabic
-     * OpenType fonts don't have a GDEF table)
+     * Note that this method has both characters and glyphs as input so that
+     * it can use the character codes to determine glyph types if that information
+     * isn't directly available. (e.g. Some Arabic OpenType fonts don't have a GDEF
+     * table)
      *
      * @param chars - the input character context
      * @param offset - the offset of the first character to process
      * @param count - the number of characters to process
-     * @param reverse - <code>TRUE</code> if the glyphs in the glyph
-     *     array have been reordered
-     * @param glyphStorage - the object which holds the per-glyph
-     *     storage. The glyph positions will be adjusted as needed.
-     * @param success - output parameter set to an error code if the
-     *     operation fails
+     * @param reverse - <code>TRUE</code> if the glyphs in the glyph array have been reordered
+     * @param glyphStorage - the object which holds the per-glyph storage. The glyph positions will be
+     *                       adjusted as needed.
+     * @param success - output parameter set to an error code if the operation fails
      *
      * @internal
      */
-    virtual void adjustGlyphPositions(const LEUnicode chars[],
-        le_int32 offset, le_int32 count, le_bool reverse,
-        LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual void adjustGlyphPositions(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     /**
-     * This method gets a table from the font associated with the
-     * text. The default implementation gets the table from the font
-     * instance. Subclasses which need to get the tables some other
-     * way must override this method.
+     * This method gets a table from the font associated with
+     * the text. The default implementation gets the table from
+     * the font instance. Subclasses which need to get the tables
+     * some other way must override this method.
      *
      * @param tableTag - the four byte table tag.
      *
@@ -283,127 +263,106 @@
     virtual const void *getFontTable(LETag tableTag) const;
 
     /**
-     * This method does character to glyph mapping. The default
-     * implementation uses the font instance to do the mapping. It
-     * will allocate the glyph and character index arrays if they're
-     * not already allocated. If it allocates the character index
-     * array, it will fill it it.
+     * This method does character to glyph mapping. The default implementation
+     * uses the font instance to do the mapping. It will allocate the glyph and
+     * character index arrays if they're not already allocated. If it allocates the
+     * character index array, it will fill it it.
      *
-     * This method supports right to left text with the ability to
-     * store the glyphs in reverse order, and by supporting character
-     * mirroring, which will replace a character which has a left and
-     * right form, such as parens, with the opposite form before
-     * mapping it to a glyph index.
+     * This method supports right to left
+     * text with the ability to store the glyphs in reverse order, and by supporting
+     * character mirroring, which will replace a character which has a left and right
+     * form, such as parens, with the opposite form before mapping it to a glyph index.
      *
      * Input parameters:
      * @param chars - the input character context
      * @param offset - the offset of the first character to be mapped
      * @param count - the number of characters to be mapped
-     * @param reverse - if <code>TRUE</code>, the output will be in
-     *            reverse order
+     * @param reverse - if <code>TRUE</code>, the output will be in reverse order
      * @param mirror - if <code>TRUE</code>, do character mirroring
-     * @param glyphStorage - the object which holds the per-glyph
-     *            storage. The glyph and char indices arrays will be
-     *            filled in.
+     * @param glyphStorage - the object which holds the per-glyph storage. The glyph and char
+     *                       indices arrays will be filled in.
      * @param success - set to an error code if the operation fails
      *
      * @see LEFontInstance
      *
      * @internal
      */
-    virtual void mapCharsToGlyphs(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_bool reverse, le_bool mirror,
-        LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual void mapCharsToGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse, le_bool mirror, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     /**
-     * This is a convenience method that forces the advance width of
-     * mark glyphs to be zero, which is required for proper selection
-     * and highlighting.
+     * This is a convenience method that forces the advance width of mark
+     * glyphs to be zero, which is required for proper selection and highlighting.
      *
-     * @param glyphStorage - the object containing the per-glyph
-     *     storage. The positions array will be modified.
+     * @param glyphStorage - the object containing the per-glyph storage. The positions array will be modified.
      * @param markFilter - used to identify mark glyphs
-     * @param success - output parameter set to an error code if the
-     *     operation fails
+     * @param success - output parameter set to an error code if the operation fails
      *
      * @see LEGlyphFilter
      *
      * @internal
      */
-    static void adjustMarkGlyphs(LEGlyphStorage &glyphStorage,
-        LEGlyphFilter *markFilter, LEErrorCode &success);
+    static void adjustMarkGlyphs(LEGlyphStorage &glyphStorage, LEGlyphFilter *markFilter, LEErrorCode &success);
 
 
     /**
-     * This is a convenience method that forces the advance width of
-     * mark glyphs to be zero, which is required for proper selection
-     * and highlighting.  This method uses the input characters to
-     * identify marks. This is required in cases where the font does
-     * not contain enough information to identify them based on the
-     * glyph IDs.
+     * This is a convenience method that forces the advance width of mark
+     * glyphs to be zero, which is required for proper selection and highlighting.
+     * This method uses the input characters to identify marks. This is required in
+     * cases where the font does not contain enough information to identify them based
+     * on the glyph IDs.
      *
      * @param chars - the array of input characters
      * @param charCount - the number of input characers
-     * @param glyphStorage - the object containing the per-glyph
-     *     storage. The positions array will be modified.
-     * @param reverse - <code>TRUE</code> if the glyph array has been
-     *     reordered
+     * @param glyphStorage - the object containing the per-glyph storage. The positions array will be modified.
+     * @param reverse - <code>TRUE</code> if the glyph array has been reordered
      * @param markFilter - used to identify mark glyphs
-     * @param success - output parameter set to an error code if the
-     *     operation fails
+     * @param success - output parameter set to an error code if the operation fails
      *
      * @see LEGlyphFilter
      *
      * @internal
      */
-    static void adjustMarkGlyphs(const LEUnicode chars[],
-        le_int32 charCount, le_bool reverse,
-        LEGlyphStorage &glyphStorage, LEGlyphFilter *markFilter,
-        LEErrorCode &success);
+    static void adjustMarkGlyphs(const LEUnicode chars[], le_int32 charCount, le_bool reverse, LEGlyphStorage &glyphStorage, LEGlyphFilter *markFilter, LEErrorCode &success);
+
 
 public:
     /**
      * The destructor. It will free any storage allocated for the
      * glyph, character index and position arrays by calling the reset
-     * method. It is declared virtual so that it will be invoked by
-     * the subclass destructors.
+     * method. It is declared virtual so that it will be invoked by the
+     * subclass destructors.
      *
      * @stable ICU 2.8
      */
     virtual ~LayoutEngine();
 
     /**
-     * This method will invoke the layout steps in their correct order
-     * by calling the 32 bit versions of the computeGlyphs and
-     * positionGlyphs methods.(It doesn't * call the
-     * adjustGlyphPositions method because that doesn't apply for
-     * default * processing.) It will compute the glyph, character
-     * index and position arrays.
+     * This method will invoke the layout steps in their correct order by calling
+     * the computeGlyphs, positionGlyphs and adjustGlyphPosition methods.. It will
+     * compute the glyph, character index and position arrays.
      *
      * @param chars - the input character context
      * @param offset - the offset of the first character to process
      * @param count - the number of characters to process
      * @param max - the number of characters in the input context
-     * @param rightToLeft - true if the characers are in a right to
-     *            left directional run
+     * @param rightToLeft - TRUE if the characers are in a right to left directional run
      * @param x - the initial X position
      * @param y - the initial Y position
-     * @param success - output parameter set to an error code if the
-     *            operation fails
+     * @param success - output parameter set to an error code if the operation fails
+     *
      * @return the number of glyphs in the glyph array
      *
-     * Note: the glyph, character index and position array can be
-     * accessed using the getter method below.
+     * Note; the glyph, character index and position array can be accessed
+     * using the getter method below.
+     *
+     * @stable ICU 2.8
      */
-    le_int32 layoutChars(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_int32 max, le_bool rightToLeft, float x,
-        float y, LEErrorCode &success);
+    virtual le_int32 layoutChars(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft, float x, float y, LEErrorCode &success);
 
     /**
-     * This method returns the number of glyphs in the glyph
-     * array. Note that the number of glyphs will be greater than or
-     * equal to the number of characters used to create the
-     * LayoutEngine.
+     * This method returns the number of glyphs in the glyph array. Note
+     * that the number of glyphs will be greater than or equal to the number
+     * of characters used to create the LayoutEngine.
      *
      * @return the number of glyphs in the glyph array
      *
@@ -412,9 +371,9 @@
     le_int32 getGlyphCount() const;
 
     /**
-     * This method copies the glyph array into a caller supplied
-     * array.  The caller must ensure that the array is large enough
-     * to hold all the glyphs.
+     * This method copies the glyph array into a caller supplied array.
+     * The caller must ensure that the array is large enough to hold all
+     * the glyphs.
      *
      * @param glyphs - the destiniation glyph array
      * @param success - set to an error code if the operation fails
@@ -424,10 +383,10 @@
     void getGlyphs(LEGlyphID glyphs[], LEErrorCode &success) const;
 
     /**
-     * This method copies the glyph array into a caller supplied
-     * array, ORing in extra bits. (This functionality is needed by
-     * the JDK, which uses 32 bits pre glyph idex, with the high 16
-     * bits encoding the composite font slot number)
+     * This method copies the glyph array into a caller supplied array,
+     * ORing in extra bits. (This functionality is needed by the JDK,
+     * which uses 32 bits pre glyph idex, with the high 16 bits encoding
+     * the composite font slot number)
      *
      * @param glyphs - the destination (32 bit) glyph array
      * @param extraBits - this value will be ORed with each glyph index
@@ -435,13 +394,12 @@
      *
      * @stable ICU 2.8
      */
-    virtual void getGlyphs(le_uint32 glyphs[], le_uint32 extraBits,
-        LEErrorCode &success) const;
+    virtual void getGlyphs(le_uint32 glyphs[], le_uint32 extraBits, LEErrorCode &success) const;
 
     /**
-     * This method copies the character index array into a caller
-     * supplied array.  The caller must ensure that the array is large
-     * enough to hold a character index for each glyph.
+     * This method copies the character index array into a caller supplied array.
+     * The caller must ensure that the array is large enough to hold a
+     * character index for each glyph.
      *
      * @param charIndices - the destiniation character index array
      * @param success - set to an error code if the operation fails
@@ -451,9 +409,9 @@
     void getCharIndices(le_int32 charIndices[], LEErrorCode &success) const;
 
     /**
-     * This method copies the character index array into a caller
-     * supplied array.  The caller must ensure that the array is large
-     * enough to hold a character index for each glyph.
+     * This method copies the character index array into a caller supplied array.
+     * The caller must ensure that the array is large enough to hold a
+     * character index for each glyph.
      *
      * @param charIndices - the destiniation character index array
      * @param indexBase - an offset which will be added to each index
@@ -461,14 +419,13 @@
      *
      * @stable ICU 2.8
      */
-    void getCharIndices(le_int32 charIndices[], le_int32 indexBase,
-        LEErrorCode &success) const;
+    void getCharIndices(le_int32 charIndices[], le_int32 indexBase, LEErrorCode &success) const;
 
     /**
-     * This method copies the position array into a caller supplied
-     * array.  The caller must ensure that the array is large enough
-     * to hold an X and Y position for each glyph, plus an extra X and
-     * Y for the advance of the last glyph.
+     * This method copies the position array into a caller supplied array.
+     * The caller must ensure that the array is large enough to hold an
+     * X and Y position for each glyph, plus an extra X and Y for the
+     * advance of the last glyph.
      *
      * @param positions - the destiniation position array
      * @param success - set to an error code if the operation fails
@@ -491,8 +448,7 @@
      *
      * @stable ICU 2.8
      */
-    void getGlyphPosition(le_int32 glyphIndex, float &x, float &y,
-        LEErrorCode &success) const;
+    void getGlyphPosition(le_int32 glyphIndex, float &x, float &y, LEErrorCode &success) const;
 
     /**
      * This method frees the glyph, character index and position arrays
@@ -511,8 +467,7 @@
      * @param fontInstance - the font of the text
      * @param scriptCode - the script of the text
      * @param languageCode - the language of the text
-     * @param success - output parameter set to an error code if the
-     *     operation fails
+     * @param success - output parameter set to an error code if the operation fails
      *
      * @return a LayoutEngine which can layout text in the given font.
      *
@@ -520,17 +475,30 @@
      *
      * @stable ICU 2.8
      */
-    static LayoutEngine *layoutEngineFactory(const LEFontInstance *fontInstance,
-        le_int32 scriptCode, le_int32 languageCode, LEErrorCode &success);
+    static LayoutEngine *layoutEngineFactory(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, LEErrorCode &success);
 
     /**
      * Override of existing call that provides flags to control typography.
      * @draft ICU 3.4
      */
-    static LayoutEngine *layoutEngineFactory(
-        const LEFontInstance *fontInstance,
-        le_int32 scriptCode, le_int32 languageCode,
-        le_int32 typo_flags, LEErrorCode &success);
+    static LayoutEngine *layoutEngineFactory(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, le_int32 typo_flags, LEErrorCode &success);
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/LayoutTables.h b/src/share/native/sun/font/layout/LayoutTables.h
--- jdk/src/share/native/sun/font/layout/LayoutTables.h
+++ jdk/src/share/native/sun/font/layout/LayoutTables.h
@@ -32,11 +32,20 @@
 #ifndef __LAYOUTTABLES_H
 #define __LAYOUTTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 
+U_NAMESPACE_BEGIN
+
 #define ANY_NUMBER 1
 
 typedef le_int16 ByteOffset;
 typedef le_int16 WordOffset;
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/LigatureSubstProc.cpp b/src/share/native/sun/font/layout/LigatureSubstProc.cpp
--- jdk/src/share/native/sun/font/layout/LigatureSubstProc.cpp
+++ jdk/src/share/native/sun/font/layout/LigatureSubstProc.cpp
@@ -39,10 +39,14 @@
 #include "LEGlyphStorage.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 #define ExtendedComplement(m) ((le_int32) (~((le_uint32) (m))))
 #define SignBit(m) ((ExtendedComplement(m) >> 1) & (le_int32)(m))
 #define SignExtend(v,m) (((v) & SignBit(m))? ((v) | ExtendedComplement(m)): (v))
 
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(LigatureSubstitutionProcessor)
+
 LigatureSubstitutionProcessor::LigatureSubstitutionProcessor(const MorphSubtableHeader *morphSubtableHeader)
   : StateTableProcessor(morphSubtableHeader)
 {
@@ -63,8 +67,7 @@
     m = -1;
 }
 
-ByteOffset LigatureSubstitutionProcessor::processStateEntry(LEGlyphStorage &glyphStorage,
-    le_int32 &currGlyph, EntryTableIndex index)
+ByteOffset LigatureSubstitutionProcessor::processStateEntry(LEGlyphStorage &glyphStorage, le_int32 &currGlyph, EntryTableIndex index)
 {
     const LigatureSubstitutionStateEntry *entry = &entryTable[index];
     ByteOffset newState = SWAPW(entry->newStateOffset);
@@ -162,3 +165,5 @@
 void LigatureSubstitutionProcessor::endStateTable()
 {
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/LigatureSubstProc.h b/src/share/native/sun/font/layout/LigatureSubstProc.h
--- jdk/src/share/native/sun/font/layout/LigatureSubstProc.h
+++ jdk/src/share/native/sun/font/layout/LigatureSubstProc.h
@@ -32,12 +32,19 @@
 #ifndef __LIGATURESUBSTITUTIONPROCESSOR_H
 #define __LIGATURESUBSTITUTIONPROCESSOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "MorphTables.h"
 #include "SubtableProcessor.h"
 #include "StateTableProcessor.h"
 #include "LigatureSubstitution.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 #define nComponents 16
@@ -54,6 +61,20 @@
     LigatureSubstitutionProcessor(const MorphSubtableHeader *morphSubtableHeader);
     virtual ~LigatureSubstitutionProcessor();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 private:
     LigatureSubstitutionProcessor();
 
@@ -68,6 +89,8 @@
     le_int16 m;
 
     const LigatureSubstitutionHeader *ligatureSubstitutionHeader;
+
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/LigatureSubstSubtables.cpp b/src/share/native/sun/font/layout/LigatureSubstSubtables.cpp
--- jdk/src/share/native/sun/font/layout/LigatureSubstSubtables.cpp
+++ jdk/src/share/native/sun/font/layout/LigatureSubstSubtables.cpp
@@ -25,6 +25,7 @@
 
 /*
  *
+ *
  * (C) Copyright IBM Corp. 1998-2003 - All Rights Reserved
  *
  */
@@ -37,6 +38,8 @@
 #include "GlyphIterator.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 le_uint32 LigatureSubstitutionSubtable::process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter) const
 {
     LEGlyphID glyph = glyphIterator->getCurrGlyphID();
@@ -92,3 +95,5 @@
 
     return 0;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/LigatureSubstSubtables.h b/src/share/native/sun/font/layout/LigatureSubstSubtables.h
--- jdk/src/share/native/sun/font/layout/LigatureSubstSubtables.h
+++ jdk/src/share/native/sun/font/layout/LigatureSubstSubtables.h
@@ -32,12 +32,19 @@
 #ifndef __LIGATURESUBSTITUTIONSUBTABLES_H
 #define __LIGATURESUBSTITUTIONSUBTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEGlyphFilter.h"
 #include "OpenTypeTables.h"
 #include "GlyphSubstitutionTables.h"
 #include "GlyphIterator.h"
 
+U_NAMESPACE_BEGIN
+
 struct LigatureSetTable
 {
     le_uint16 ligatureCount;
@@ -59,4 +66,5 @@
     le_uint32  process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter = NULL) const;
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/LigatureSubstitution.h b/src/share/native/sun/font/layout/LigatureSubstitution.h
--- jdk/src/share/native/sun/font/layout/LigatureSubstitution.h
+++ jdk/src/share/native/sun/font/layout/LigatureSubstitution.h
@@ -32,12 +32,19 @@
 #ifndef __LIGATURESUBSTITUTION_H
 #define __LIGATURESUBSTITUTION_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LayoutTables.h"
 #include "StateTables.h"
 #include "MorphTables.h"
 #include "MorphStateTables.h"
 
+U_NAMESPACE_BEGIN
+
 struct LigatureSubstitutionHeader : MorphStateTableHeader
 {
     ByteOffset ligatureActionTableOffset;
@@ -65,4 +72,5 @@
     lafComponentOffsetMask  = 0x3FFFFFFF
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/LookupProcessor.cpp b/src/share/native/sun/font/layout/LookupProcessor.cpp
--- jdk/src/share/native/sun/font/layout/LookupProcessor.cpp
+++ jdk/src/share/native/sun/font/layout/LookupProcessor.cpp
@@ -42,6 +42,8 @@
 #include "LEGlyphStorage.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 le_uint32 LookupProcessor::applyLookupTable(const LookupTable *lookupTable, GlyphIterator *glyphIterator,
                                          const LEFontInstance *fontInstance) const
 {
@@ -65,10 +67,9 @@
     return 1;
 }
 
-le_int32 LookupProcessor::process(LEGlyphStorage &glyphStorage,
-    GlyphPositionAdjustments *glyphPositionAdjustments,
-    le_bool rightToLeft, const GlyphDefinitionTableHeader *glyphDefinitionTableHeader,
-    const LEFontInstance *fontInstance) const
+le_int32 LookupProcessor::process(LEGlyphStorage &glyphStorage, GlyphPositionAdjustments *glyphPositionAdjustments,
+                              le_bool rightToLeft, const GlyphDefinitionTableHeader *glyphDefinitionTableHeader,
+                              const LEFontInstance *fontInstance) const
 {
     le_int32 glyphCount = glyphStorage.getGlyphCount();
 
@@ -140,8 +141,7 @@
 
 LookupProcessor::LookupProcessor(const char *baseAddress,
         Offset scriptListOffset, Offset featureListOffset, Offset lookupListOffset,
-        LETag scriptTag, LETag languageTag, const FeatureMap *featureMap,
-        le_int32 featureMapCount, le_bool orderFeatures)
+        LETag scriptTag, LETag languageTag, const FeatureMap *featureMap, le_int32 featureMapCount, le_bool orderFeatures)
     : lookupListTable(NULL), featureListTable(NULL), lookupSelectArray(NULL), lookupSelectCount(0),
       lookupOrderArray(NULL), lookupOrderCount(0)
 {
@@ -309,3 +309,5 @@
     LE_DELETE_ARRAY(lookupOrderArray);
     LE_DELETE_ARRAY(lookupSelectArray);
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/LookupProcessor.h b/src/share/native/sun/font/layout/LookupProcessor.h
--- jdk/src/share/native/sun/font/layout/LookupProcessor.h
+++ jdk/src/share/native/sun/font/layout/LookupProcessor.h
@@ -25,6 +25,7 @@
 
 /*
  *
+ *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
  *
  */
@@ -32,9 +33,18 @@
 #ifndef __LOOKUPPROCESSOR_H
 #define __LOOKUPPROCESSOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEFontInstance.h"
 #include "OpenTypeTables.h"
+//#include "Lookups.h"
+//#include "Features.h"
+
+U_NAMESPACE_BEGIN
 
 class  LEFontInstance;
 class  LEGlyphStorage;
@@ -46,13 +56,10 @@
 struct LookupSubtable;
 struct LookupTable;
 
-class LookupProcessor
-{
+class LookupProcessor : public UMemory {
 public:
-    le_int32 process(LEGlyphStorage &glyphStorage,
-        GlyphPositionAdjustments *glyphPositionAdjustments,
-        le_bool rightToLeft, const GlyphDefinitionTableHeader *glyphDefinitionTableHeader,
-        const LEFontInstance *fontInstance) const;
+    le_int32 process(LEGlyphStorage &glyphStorage, GlyphPositionAdjustments *glyphPositionAdjustments,
+                 le_bool rightToLeft, const GlyphDefinitionTableHeader *glyphDefinitionTableHeader, const LEFontInstance *fontInstance) const;
 
     le_uint32 applyLookupTable(const LookupTable *lookupTable, GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
 
@@ -64,19 +71,18 @@
     virtual ~LookupProcessor();
 
 protected:
-    LookupProcessor(const char *baseAddress,
+     LookupProcessor(const char *baseAddress,
         Offset scriptListOffset, Offset featureListOffset, Offset lookupListOffset,
-        LETag scriptTag, LETag languageTag, const FeatureMap *featureMap,
-        le_int32 featureMapCount, le_bool orderFeatures);
+        LETag scriptTag, LETag languageTag, const FeatureMap *featureMap, le_int32 featureMapCount, le_bool orderFeatures);
 
-    LookupProcessor();
+   LookupProcessor();
 
     le_int32 selectLookups(const FeatureTable *featureTable, FeatureMask featureMask, le_int32 order);
 
     const LookupListTable   *lookupListTable;
     const FeatureListTable  *featureListTable;
 
-    FeatureMask             *lookupSelectArray;
+    FeatureMask            *lookupSelectArray;
     le_uint32               lookupSelectCount;
 
     le_uint16               *lookupOrderArray;
@@ -88,4 +94,5 @@
     LookupProcessor &operator=(const LookupProcessor &other); // forbid copying of this class
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/LookupTables.cpp b/src/share/native/sun/font/layout/LookupTables.cpp
--- jdk/src/share/native/sun/font/layout/LookupTables.cpp
+++ jdk/src/share/native/sun/font/layout/LookupTables.cpp
@@ -34,6 +34,8 @@
 #include "LookupTables.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 /*
     These are the rolled-up versions of the uniform binary search.
     Someday, if we need more performance, we can un-roll them.
@@ -104,3 +106,5 @@
 
     return NULL;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/LookupTables.h b/src/share/native/sun/font/layout/LookupTables.h
--- jdk/src/share/native/sun/font/layout/LookupTables.h
+++ jdk/src/share/native/sun/font/layout/LookupTables.h
@@ -32,9 +32,16 @@
 #ifndef __LOOKUPTABLES_H
 #define __LOOKUPTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LayoutTables.h"
 
+U_NAMESPACE_BEGIN
+
 enum LookupTableFormat
 {
     ltfSimpleArray      = 0,
@@ -104,4 +111,5 @@
     LookupValue valueArray[ANY_NUMBER];
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/Lookups.cpp b/src/share/native/sun/font/layout/Lookups.cpp
--- jdk/src/share/native/sun/font/layout/Lookups.cpp
+++ jdk/src/share/native/sun/font/layout/Lookups.cpp
@@ -35,6 +35,8 @@
 #include "CoverageTables.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 const LookupTable *LookupListTable::getLookupTable(le_uint16 lookupTableIndex) const
 {
     if (lookupTableIndex >= SWAPW(lookupCount)) {
@@ -63,3 +65,5 @@
 
     return coverageTable->getGlyphCoverage(glyphID);
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/Lookups.h b/src/share/native/sun/font/layout/Lookups.h
--- jdk/src/share/native/sun/font/layout/Lookups.h
+++ jdk/src/share/native/sun/font/layout/Lookups.h
@@ -32,9 +32,16 @@
 #ifndef __LOOKUPS_H
 #define __LOOKUPS_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 
+U_NAMESPACE_BEGIN
+
 enum LookupFlags
 {
     lfBaselineIsLogicalEnd  = 0x0001,  // The MS spec. calls this flag "RightToLeft" but this name is more accurate
@@ -79,6 +86,5 @@
     return getGlyphCoverage(coverageTableOffset, glyphID);
 }
 
-
-
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/MPreFixups.cpp b/src/share/native/sun/font/layout/MPreFixups.cpp
--- jdk/src/share/native/sun/font/layout/MPreFixups.cpp
+++ jdk/src/share/native/sun/font/layout/MPreFixups.cpp
@@ -33,6 +33,8 @@
 #include "LEGlyphStorage.h"
 #include "MPreFixups.h"
 
+U_NAMESPACE_BEGIN
+
 struct FixupData
 {
     le_int32 fBaseIndex;
@@ -92,7 +94,7 @@
 
         for (i = 0; i < mpreCount; i += 1) {
             mpreSave[i]  = glyphStorage[mpreIndex + i];
-            indexSave[i] = glyphStorage.getCharIndex(mpreIndex + i, success);
+            indexSave[i] = glyphStorage.getCharIndex(mpreIndex + i, success); //charIndices[mpreIndex + i];
         }
 
         for (i = 0; i < moveCount; i += 1) {
@@ -112,3 +114,5 @@
         LE_DELETE_ARRAY(mpreSave);
     }
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/MPreFixups.h b/src/share/native/sun/font/layout/MPreFixups.h
--- jdk/src/share/native/sun/font/layout/MPreFixups.h
+++ jdk/src/share/native/sun/font/layout/MPreFixups.h
@@ -32,14 +32,22 @@
 #ifndef __MPREFIXUPS_H
 #define __MPREFIXUPS_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 // Might want to make this a private member...
 struct FixupData;
 
-class MPreFixups {
+class MPreFixups : public UMemory
+{
 public:
     MPreFixups(le_int32 charCount);
    ~MPreFixups();
@@ -53,4 +61,7 @@
     le_int32   fFixupCount;
 };
 
+U_NAMESPACE_END
 #endif
+
+
diff --git a/src/share/native/sun/font/layout/MarkArrays.cpp b/src/share/native/sun/font/layout/MarkArrays.cpp
--- jdk/src/share/native/sun/font/layout/MarkArrays.cpp
+++ jdk/src/share/native/sun/font/layout/MarkArrays.cpp
@@ -36,6 +36,8 @@
 #include "MarkArrays.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 le_int32 MarkArray::getMarkClass(LEGlyphID glyphID, le_int32 coverageIndex, const LEFontInstance *fontInstance,
                               LEPoint &anchor) const
 {
@@ -58,3 +60,5 @@
 
     return markClass;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/MarkArrays.h b/src/share/native/sun/font/layout/MarkArrays.h
--- jdk/src/share/native/sun/font/layout/MarkArrays.h
+++ jdk/src/share/native/sun/font/layout/MarkArrays.h
@@ -32,10 +32,17 @@
 #ifndef __MARKARRAYS_H
 #define __MARKARRAYS_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEFontInstance.h"
 #include "OpenTypeTables.h"
 
+U_NAMESPACE_BEGIN
+
 struct MarkRecord
 {
     le_uint16   markClass;
@@ -51,4 +58,7 @@
         LEPoint &anchor) const;
 };
 
+U_NAMESPACE_END
 #endif
+
+
diff --git a/src/share/native/sun/font/layout/MarkToBasePosnSubtables.cpp b/src/share/native/sun/font/layout/MarkToBasePosnSubtables.cpp
--- jdk/src/share/native/sun/font/layout/MarkToBasePosnSubtables.cpp
+++ jdk/src/share/native/sun/font/layout/MarkToBasePosnSubtables.cpp
@@ -40,6 +40,8 @@
 #include "GlyphIterator.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 LEGlyphID MarkToBasePositioningSubtable::findBaseGlyph(GlyphIterator *glyphIterator) const
 {
     if (glyphIterator->prev()) {
@@ -106,7 +108,6 @@
     glyphIterator->setCurrGlyphBaseOffset(baseIterator.getCurrStreamPosition());
 
     if (glyphIterator->isRightToLeft()) {
-        // dlf flip advance to local coordinate system
         glyphIterator->setCurrGlyphPositionAdjustment(anchorDiffX, anchorDiffY, -markAdvance.fX, -markAdvance.fY);
     } else {
         LEPoint baseAdvance;
@@ -114,9 +115,10 @@
         fontInstance->getGlyphAdvance(baseGlyph, pixels);
         fontInstance->pixelsToUnits(pixels, baseAdvance);
 
-        // flip advances to local coordinate system
         glyphIterator->setCurrGlyphPositionAdjustment(anchorDiffX - baseAdvance.fX, anchorDiffY - baseAdvance.fY, -markAdvance.fX, -markAdvance.fY);
     }
 
     return 1;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/MarkToBasePosnSubtables.h b/src/share/native/sun/font/layout/MarkToBasePosnSubtables.h
--- jdk/src/share/native/sun/font/layout/MarkToBasePosnSubtables.h
+++ jdk/src/share/native/sun/font/layout/MarkToBasePosnSubtables.h
@@ -32,6 +32,11 @@
 #ifndef __MARKTOBASEPOSITIONINGSUBTABLES_H
 #define __MARKTOBASEPOSITIONINGSUBTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEFontInstance.h"
 #include "OpenTypeTables.h"
@@ -39,6 +44,8 @@
 #include "AttachmentPosnSubtables.h"
 #include "GlyphIterator.h"
 
+U_NAMESPACE_BEGIN
+
 struct MarkToBasePositioningSubtable : AttachmentPositioningSubtable
 {
     le_int32   process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
@@ -56,4 +63,6 @@
     BaseRecord baseRecordArray[ANY_NUMBER];
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/MarkToLigaturePosnSubtables.cpp b/src/share/native/sun/font/layout/MarkToLigaturePosnSubtables.cpp
--- jdk/src/share/native/sun/font/layout/MarkToLigaturePosnSubtables.cpp
+++ jdk/src/share/native/sun/font/layout/MarkToLigaturePosnSubtables.cpp
@@ -39,6 +39,8 @@
 #include "GlyphIterator.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 LEGlyphID MarkToLigaturePositioningSubtable::findLigatureGlyph(GlyphIterator *glyphIterator) const
 {
     if (glyphIterator->prev()) {
@@ -117,9 +119,10 @@
         fontInstance->getGlyphAdvance(ligatureGlyph, pixels);
         fontInstance->pixelsToUnits(pixels, ligatureAdvance);
 
-        glyphIterator->setCurrGlyphPositionAdjustment(anchorDiffX - ligatureAdvance.fX,
-            anchorDiffY - ligatureAdvance.fY, -markAdvance.fX, -markAdvance.fY);
+        glyphIterator->setCurrGlyphPositionAdjustment(anchorDiffX - ligatureAdvance.fX, anchorDiffY - ligatureAdvance.fY, -markAdvance.fX, -markAdvance.fY);
     }
 
     return 1;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/MarkToLigaturePosnSubtables.h b/src/share/native/sun/font/layout/MarkToLigaturePosnSubtables.h
--- jdk/src/share/native/sun/font/layout/MarkToLigaturePosnSubtables.h
+++ jdk/src/share/native/sun/font/layout/MarkToLigaturePosnSubtables.h
@@ -32,6 +32,11 @@
 #ifndef __MARKTOLIGATUREPOSITIONINGSUBTABLES_H
 #define __MARKTOLIGATUREPOSITIONINGSUBTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEFontInstance.h"
 #include "OpenTypeTables.h"
@@ -39,6 +44,8 @@
 #include "AttachmentPosnSubtables.h"
 #include "GlyphIterator.h"
 
+U_NAMESPACE_BEGIN
+
 struct MarkToLigaturePositioningSubtable : AttachmentPositioningSubtable
 {
     le_int32   process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
@@ -62,4 +69,6 @@
     Offset ligatureAttachTableOffsetArray[ANY_NUMBER];
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/MarkToMarkPosnSubtables.cpp b/src/share/native/sun/font/layout/MarkToMarkPosnSubtables.cpp
--- jdk/src/share/native/sun/font/layout/MarkToMarkPosnSubtables.cpp
+++ jdk/src/share/native/sun/font/layout/MarkToMarkPosnSubtables.cpp
@@ -40,6 +40,8 @@
 #include "GlyphIterator.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 LEGlyphID MarkToMarkPositioningSubtable::findMark2Glyph(GlyphIterator *glyphIterator) const
 {
     if (glyphIterator->findMark2Glyph()) {
@@ -88,7 +90,7 @@
     const AnchorTable *anchorTable = (const AnchorTable *) ((char *) mark2Array + anchorTableOffset);
     LEPoint mark2Anchor, markAdvance, pixels;
 
-    if (anchorTableOffset == 0) { // jb4729
+    if (anchorTableOffset == 0) {
         // this seems to mean that the marks don't attach...
         return 0;
     }
@@ -111,9 +113,10 @@
         fontInstance->getGlyphAdvance(mark2Glyph, pixels);
         fontInstance->pixelsToUnits(pixels, mark2Advance);
 
-        glyphIterator->setCurrGlyphPositionAdjustment(anchorDiffX - mark2Advance.fX,
-            anchorDiffY - mark2Advance.fY, -markAdvance.fX, -markAdvance.fY);
+        glyphIterator->setCurrGlyphPositionAdjustment(anchorDiffX - mark2Advance.fX, anchorDiffY - mark2Advance.fY, -markAdvance.fX, -markAdvance.fY);
     }
 
     return 1;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/MarkToMarkPosnSubtables.h b/src/share/native/sun/font/layout/MarkToMarkPosnSubtables.h
--- jdk/src/share/native/sun/font/layout/MarkToMarkPosnSubtables.h
+++ jdk/src/share/native/sun/font/layout/MarkToMarkPosnSubtables.h
@@ -32,6 +32,11 @@
 #ifndef __MARKTOMARKPOSITIONINGSUBTABLES_H
 #define __MARKTOMARKPOSITIONINGSUBTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEFontInstance.h"
 #include "OpenTypeTables.h"
@@ -39,6 +44,8 @@
 #include "AttachmentPosnSubtables.h"
 #include "GlyphIterator.h"
 
+U_NAMESPACE_BEGIN
+
 struct MarkToMarkPositioningSubtable : AttachmentPositioningSubtable
 {
     le_int32   process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
@@ -56,4 +63,6 @@
     Mark2Record mark2RecordArray[ANY_NUMBER];
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/MirroredCharData.cpp b/src/share/native/sun/font/layout/MirroredCharData.cpp
--- jdk/src/share/native/sun/font/layout/MirroredCharData.cpp
+++ jdk/src/share/native/sun/font/layout/MirroredCharData.cpp
@@ -36,6 +36,8 @@
 #include "LETypes.h"
 #include "DefaultCharMapper.h"
 
+U_NAMESPACE_BEGIN
+
 const LEUnicode32 DefaultCharMapper::mirroredChars[] = {
     0x0028, 0x0029, 0x003C, 0x003E, 0x005B, 0x005D, 0x007B, 0x007D,
     0x00AB, 0x00BB, 0x2039, 0x203A, 0x2045, 0x2046, 0x207D, 0x207E,
@@ -127,3 +129,5 @@
 };
 
 const le_int32 DefaultCharMapper::mirroredCharsCount = 332;
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/MorphStateTables.h b/src/share/native/sun/font/layout/MorphStateTables.h
--- jdk/src/share/native/sun/font/layout/MorphStateTables.h
+++ jdk/src/share/native/sun/font/layout/MorphStateTables.h
@@ -32,14 +32,22 @@
 #ifndef __MORPHSTATETABLES_H
 #define __MORPHSTATETABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LayoutTables.h"
 #include "MorphTables.h"
 #include "StateTables.h"
 
+U_NAMESPACE_BEGIN
+
 struct MorphStateTableHeader : MorphSubtableHeader
 {
     StateTableHeader stHeader;
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/MorphTables.cpp b/src/share/native/sun/font/layout/MorphTables.cpp
--- jdk/src/share/native/sun/font/layout/MorphTables.cpp
+++ jdk/src/share/native/sun/font/layout/MorphTables.cpp
@@ -42,6 +42,8 @@
 #include "LEGlyphStorage.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 void MorphTableHeader::process(LEGlyphStorage &glyphStorage) const
 {
     const ChainHeader *chainHeader = chains;
@@ -114,3 +116,5 @@
         delete processor;
     }
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/MorphTables.h b/src/share/native/sun/font/layout/MorphTables.h
--- jdk/src/share/native/sun/font/layout/MorphTables.h
+++ jdk/src/share/native/sun/font/layout/MorphTables.h
@@ -32,9 +32,16 @@
 #ifndef __MORPHTABLES_H
 #define __MORPHTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LayoutTables.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 typedef le_uint32 FeatureFlags;
@@ -98,4 +105,6 @@
     void process(LEGlyphStorage &glyphStorage) const;
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/MultipleSubstSubtables.cpp b/src/share/native/sun/font/layout/MultipleSubstSubtables.cpp
--- jdk/src/share/native/sun/font/layout/MultipleSubstSubtables.cpp
+++ jdk/src/share/native/sun/font/layout/MultipleSubstSubtables.cpp
@@ -37,6 +37,8 @@
 #include "GlyphIterator.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 le_uint32 MultipleSubstitutionSubtable::process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter) const
 {
     LEGlyphID glyph = glyphIterator->getCurrGlyphID();
@@ -106,3 +108,5 @@
 
     return 0;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/MultipleSubstSubtables.h b/src/share/native/sun/font/layout/MultipleSubstSubtables.h
--- jdk/src/share/native/sun/font/layout/MultipleSubstSubtables.h
+++ jdk/src/share/native/sun/font/layout/MultipleSubstSubtables.h
@@ -32,12 +32,19 @@
 #ifndef __MULTIPLESUBSTITUTIONSUBTABLES_H
 #define __MULTIPLESUBSTITUTIONSUBTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEGlyphFilter.h"
 #include "OpenTypeTables.h"
 #include "GlyphSubstitutionTables.h"
 #include "GlyphIterator.h"
 
+U_NAMESPACE_BEGIN
+
 struct SequenceTable
 {
     le_uint16 glyphCount;
@@ -52,4 +59,5 @@
     le_uint32 process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter = NULL) const;
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/NonContextualGlyphSubst.h b/src/share/native/sun/font/layout/NonContextualGlyphSubst.h
--- jdk/src/share/native/sun/font/layout/NonContextualGlyphSubst.h
+++ jdk/src/share/native/sun/font/layout/NonContextualGlyphSubst.h
@@ -25,6 +25,7 @@
 
 /*
  *
+ *
  * (C) Copyright IBM Corp. 1998-2003 - All Rights Reserved
  *
  */
@@ -32,14 +33,23 @@
 #ifndef __NONCONTEXTUALGLYPHSUBSTITUTION_H
 #define __NONCONTEXTUALGLYPHSUBSTITUTION_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LayoutTables.h"
 #include "LookupTables.h"
 #include "MorphTables.h"
 
+U_NAMESPACE_BEGIN
+
 struct NonContextualGlyphSubstitutionHeader : MorphSubtableHeader
 {
     LookupTable table;
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/NonContextualGlyphSubstProc.cpp b/src/share/native/sun/font/layout/NonContextualGlyphSubstProc.cpp
--- jdk/src/share/native/sun/font/layout/NonContextualGlyphSubstProc.cpp
+++ jdk/src/share/native/sun/font/layout/NonContextualGlyphSubstProc.cpp
@@ -41,6 +41,8 @@
 #include "TrimmedArrayProcessor.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 NonContextualGlyphSubstitutionProcessor::NonContextualGlyphSubstitutionProcessor()
 {
 }
@@ -79,3 +81,5 @@
         return NULL;
     }
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/NonContextualGlyphSubstProc.h b/src/share/native/sun/font/layout/NonContextualGlyphSubstProc.h
--- jdk/src/share/native/sun/font/layout/NonContextualGlyphSubstProc.h
+++ jdk/src/share/native/sun/font/layout/NonContextualGlyphSubstProc.h
@@ -32,11 +32,18 @@
 #ifndef __NONCONTEXTUALGLYPHSUBSTITUTIONPROCESSOR_H
 #define __NONCONTEXTUALGLYPHSUBSTITUTIONPROCESSOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "MorphTables.h"
 #include "SubtableProcessor.h"
 #include "NonContextualGlyphSubst.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 class NonContextualGlyphSubstitutionProcessor : public SubtableProcessor
@@ -57,4 +64,5 @@
     NonContextualGlyphSubstitutionProcessor &operator=(const NonContextualGlyphSubstitutionProcessor &other); // forbid copying of this class
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/OpenTypeLayoutEngine.cpp b/src/share/native/sun/font/layout/OpenTypeLayoutEngine.cpp
--- jdk/src/share/native/sun/font/layout/OpenTypeLayoutEngine.cpp
+++ jdk/src/share/native/sun/font/layout/OpenTypeLayoutEngine.cpp
@@ -47,6 +47,10 @@
 
 #include "GDEFMarkFilter.h"
 
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(OpenTypeLayoutEngine)
+
 #define ccmpFeatureTag LE_CCMP_FEATURE_TAG
 #define ligaFeatureTag LE_LIGA_FEATURE_TAG
 #define cligFeatureTag LE_CLIG_FEATURE_TAG
@@ -78,7 +82,7 @@
     {ccmpFeatureTag, ccmpFeatureMask},
     {ligaFeatureTag, ligaFeatureMask},
     {cligFeatureTag, cligFeatureMask},
-    {kernFeatureTag, kernFeatureMask},
+        {kernFeatureTag, kernFeatureMask},
     {paltFeatureTag, paltFeatureMask},
     {markFeatureTag, markFeatureMask},
     {mkmkFeatureTag, mkmkFeatureMask}
@@ -86,19 +90,15 @@
 
 static const le_int32 featureMapCount = LE_ARRAY_SIZE(featureMap);
 
-OpenTypeLayoutEngine::OpenTypeLayoutEngine(const LEFontInstance *fontInstance,
-    le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags,
-    const GlyphSubstitutionTableHeader *gsubTable)
-    : LayoutEngine(fontInstance, scriptCode, languageCode, typoFlags),
-    fFeatureMask(minimalFeatures), fFeatureMap(featureMap),
-    fFeatureMapCount(featureMapCount), fFeatureOrder(FALSE),
-    fGSUBTable(gsubTable), fGDEFTable(NULL), fGPOSTable(NULL),
-    fSubstitutionFilter(NULL)
+OpenTypeLayoutEngine::OpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                        le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable)
+    : LayoutEngine(fontInstance, scriptCode, languageCode, typoFlags), fFeatureMask(minimalFeatures),
+      fFeatureMap(featureMap), fFeatureMapCount(featureMapCount), fFeatureOrder(FALSE),
+      fGSUBTable(gsubTable), fGDEFTable(NULL), fGPOSTable(NULL), fSubstitutionFilter(NULL)
 {
     static const le_uint32 gdefTableTag = LE_GDEF_TABLE_TAG;
     static const le_uint32 gposTableTag = LE_GPOS_TABLE_TAG;
-    const GlyphPositioningTableHeader *gposTable =
-        (const GlyphPositioningTableHeader *) getFontTable(gposTableTag);
+    const GlyphPositioningTableHeader *gposTable = (const GlyphPositioningTableHeader *) getFontTable(gposTableTag);
 
     applyTypoFlags();
 
@@ -128,11 +128,10 @@
     LayoutEngine::reset();
 }
 
-OpenTypeLayoutEngine::OpenTypeLayoutEngine(const LEFontInstance *fontInstance,
-    le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags)
-    : LayoutEngine(fontInstance, scriptCode, languageCode, typoFlags),
-    fFeatureOrder(FALSE), fGSUBTable(NULL), fGDEFTable(NULL),
-    fGPOSTable(NULL), fSubstitutionFilter(NULL)
+OpenTypeLayoutEngine::OpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                                           le_int32 typoFlags)
+    : LayoutEngine(fontInstance, scriptCode, languageCode, typoFlags), fFeatureOrder(FALSE),
+      fGSUBTable(NULL), fGDEFTable(NULL), fGPOSTable(NULL), fSubstitutionFilter(NULL)
 {
     applyTypoFlags();
     setScriptAndLanguageTags();
@@ -171,9 +170,8 @@
     fLangSysTag = getLangSysTag(fLanguageCode);
 }
 
-le_int32 OpenTypeLayoutEngine::characterProcessing(const LEUnicode chars[],
-    le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
- LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success)
+le_int32 OpenTypeLayoutEngine::characterProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+                LEUnicode *&outChars, LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
@@ -184,8 +182,7 @@
         return 0;
     }
 
-    le_int32 outCharCount = LayoutEngine::characterProcessing(chars, offset, count,
-         max, rightToLeft, outChars, glyphStorage, success);
+    le_int32 outCharCount = LayoutEngine::characterProcessing(chars, offset, count, max, rightToLeft, outChars, glyphStorage, success);
 
     if (LE_FAILURE(success)) {
         return 0;
@@ -203,16 +200,14 @@
 
 // Input: characters, tags
 // Output: glyphs, char indices
-le_int32 OpenTypeLayoutEngine::glyphProcessing(const LEUnicode chars[], le_int32 offset,
-    le_int32 count, le_int32 max, le_bool rightToLeft,
-    LEGlyphStorage &glyphStorage, LEErrorCode &success)
+le_int32 OpenTypeLayoutEngine::glyphProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+                                               LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
     }
 
-    if (chars == NULL || offset < 0 || count < 0 || max < 0 ||
-         offset >= max || offset + count > max) {
+    if (chars == NULL || offset < 0 || count < 0 || max < 0 || offset >= max || offset + count > max) {
         success = LE_ILLEGAL_ARGUMENT_ERROR;
         return 0;
     }
@@ -224,16 +219,14 @@
     }
 
     if (fGSUBTable != NULL) {
-        count = fGSUBTable->process(glyphStorage, rightToLeft,
-            fScriptTag, fLangSysTag, fGDEFTable, fSubstitutionFilter,
-            fFeatureMap, fFeatureMapCount, fFeatureOrder);
+        count = fGSUBTable->process(glyphStorage, rightToLeft, fScriptTag, fLangSysTag, fGDEFTable, fSubstitutionFilter,
+                                    fFeatureMap, fFeatureMapCount, fFeatureOrder);
     }
 
     return count;
 }
 
-le_int32 OpenTypeLayoutEngine::glyphPostProcessing(LEGlyphStorage &tempGlyphStorage,
-    LEGlyphStorage &glyphStorage, LEErrorCode &success)
+le_int32 OpenTypeLayoutEngine::glyphPostProcessing(LEGlyphStorage &tempGlyphStorage, LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
@@ -247,9 +240,7 @@
     return glyphStorage.getGlyphCount();
 }
 
-le_int32 OpenTypeLayoutEngine::computeGlyphs(const LEUnicode chars[], le_int32 offset,
-    le_int32 count, le_int32 max, le_bool rightToLeft, LEGlyphStorage &glyphStorage,
-    LEErrorCode &success)
+le_int32 OpenTypeLayoutEngine::computeGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft, LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     LEUnicode *outChars = NULL;
     LEGlyphStorage fakeGlyphStorage;
@@ -259,25 +250,19 @@
         return 0;
     }
 
-    if (chars == NULL || offset < 0 || count < 0 || max < 0 ||
-         offset >= max || offset + count > max) {
+    if (chars == NULL || offset < 0 || count < 0 || max < 0 || offset >= max || offset + count > max) {
         success = LE_ILLEGAL_ARGUMENT_ERROR;
         return 0;
     }
 
-    outCharCount = characterProcessing(chars, offset, count, max, rightToLeft,
-        outChars, fakeGlyphStorage, success);
+    outCharCount = characterProcessing(chars, offset, count, max, rightToLeft, outChars, fakeGlyphStorage, success);
 
     if (outChars != NULL) {
-        fakeGlyphCount = glyphProcessing(outChars, 0, outCharCount, outCharCount,
-            rightToLeft, fakeGlyphStorage, success);
-        // FIXME: a subclass may have allocated this, in which case
-        // this delete might not work...
-        LE_DELETE_ARRAY(outChars);
+        fakeGlyphCount = glyphProcessing(outChars, 0, outCharCount, outCharCount, rightToLeft, fakeGlyphStorage, success);
+        LE_DELETE_ARRAY(outChars); // FIXME: a subclass may have allocated this, in which case this delete might not work...
         //adjustGlyphs(outChars, 0, outCharCount, rightToLeft, fakeGlyphs, fakeGlyphCount);
     } else {
-        fakeGlyphCount = glyphProcessing(chars, offset, count, max, rightToLeft,
-            fakeGlyphStorage, success);
+        fakeGlyphCount = glyphProcessing(chars, offset, count, max, rightToLeft, fakeGlyphStorage, success);
         //adjustGlyphs(chars, offset, count, rightToLeft, fakeGlyphs, fakeGlyphCount);
     }
 
@@ -287,8 +272,8 @@
 }
 
 // apply GPOS table, if any
-void OpenTypeLayoutEngine::adjustGlyphPositions(const LEUnicode chars[], le_int32 offset,
-    le_int32 count, le_bool reverse,  LEGlyphStorage &glyphStorage, LEErrorCode &success)
+void OpenTypeLayoutEngine::adjustGlyphPositions(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse,
+                                                LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return;
@@ -324,8 +309,8 @@
         }
 #endif
 
-        fGPOSTable->process(glyphStorage, adjustments, reverse, fScriptTag, fLangSysTag,
-            fGDEFTable, fFontInstance, fFeatureMap, fFeatureMapCount, fFeatureOrder);
+        fGPOSTable->process(glyphStorage, adjustments, reverse, fScriptTag, fLangSysTag, fGDEFTable, fFontInstance,
+                            fFeatureMap, fFeatureMapCount, fFeatureOrder);
 
         float xAdjust = 0, yAdjust = 0;
 
@@ -360,4 +345,12 @@
 
         delete adjustments;
     }
+
+#if 0
+    // Don't know why this is here...
+    LE_DELETE_ARRAY(fFeatureTags);
+    fFeatureTags = NULL;
+#endif
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/OpenTypeLayoutEngine.h b/src/share/native/sun/font/layout/OpenTypeLayoutEngine.h
--- jdk/src/share/native/sun/font/layout/OpenTypeLayoutEngine.h
+++ jdk/src/share/native/sun/font/layout/OpenTypeLayoutEngine.h
@@ -23,9 +23,7 @@
  *
  */
 
-
 /*
- *
  * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
  *
  */
@@ -42,6 +40,8 @@
 #include "GlyphDefinitionTables.h"
 #include "GlyphPositioningTables.h"
 
+U_NAMESPACE_BEGIN
+
 /**
  * OpenTypeLayoutEngine implements complex text layout for OpenType fonts - that is
  * fonts which have GSUB and GPOS tables associated with them. In order to do this,
@@ -87,7 +87,7 @@
      * @internal
      */
     OpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
-                         le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable);
+                            le_int32 typoFlags, const GlyphSubstitutionTableHeader *gsubTable);
 
     /**
      * This constructor is used when the font requires a "canned" GSUB table which can't be known
@@ -95,11 +95,12 @@
      *
      * @param fontInstance - the font
      * @param scriptCode - the script
-     * @param languageCode - the language
+     * @param langaugeCode - the language
      *
      * @internal
      */
-    OpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags);
+    OpenTypeLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode,
+                         le_int32 typoFlags);
 
     /**
      * The destructor, virtual for correct polymorphic invocation.
@@ -132,6 +133,20 @@
      */
     static LETag getLangSysTag(le_int32 languageCode);
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 private:
 
     /**
@@ -259,9 +274,8 @@
      *
      * @internal
      */
-    virtual le_int32 characterProcessing(const LEUnicode /*chars*/[], le_int32 offset,
-        le_int32 count, le_int32 max, le_bool /*rightToLeft*/,
-        LEUnicode *&/*outChars*/, LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual le_int32 characterProcessing(const LEUnicode /*chars*/[], le_int32 offset, le_int32 count, le_int32 max, le_bool /*rightToLeft*/,
+            LEUnicode *&/*outChars*/, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     /**
      * This method does character to glyph mapping, and applies the GSUB table. The
@@ -292,9 +306,8 @@
      *
      * @internal
      */
-    virtual le_int32 glyphProcessing(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_int32 max, le_bool rightToLeft,
-        LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual le_int32 glyphProcessing(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
+            LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     /**
      * This method does any processing necessary to convert "fake"
@@ -321,8 +334,7 @@
      *
      * @internal
      */
-    virtual le_int32 glyphPostProcessing(LEGlyphStorage &tempGlyphStorage,
-        LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual le_int32 glyphPostProcessing(LEGlyphStorage &tempGlyphStorage, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     /**
      * This method applies the characterProcessing, glyphProcessing and glyphPostProcessing
@@ -346,8 +358,7 @@
      *
      * @internal
      */
-    virtual le_int32 computeGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count,
-        le_int32 max, le_bool rightToLeft, LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual le_int32 computeGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     /**
      * This method uses the GPOS table, if there is one, to adjust the glyph positions.
@@ -364,8 +375,7 @@
      *
      * @internal
      */
-    virtual void adjustGlyphPositions(const LEUnicode chars[], le_int32 offset, le_int32 count,
-        le_bool reverse, LEGlyphStorage &glyphStorage, LEErrorCode &success);
+    virtual void adjustGlyphPositions(const LEUnicode chars[], le_int32 offset, le_int32 count, le_bool reverse, LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
     /**
      * This method frees the feature tag array so that the
@@ -377,4 +387,6 @@
     virtual void reset();
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/OpenTypeTables.h b/src/share/native/sun/font/layout/OpenTypeTables.h
--- jdk/src/share/native/sun/font/layout/OpenTypeTables.h
+++ jdk/src/share/native/sun/font/layout/OpenTypeTables.h
@@ -32,8 +32,15 @@
 #ifndef __OPENTYPETABLES_H
 #define __OPENTYPETABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 
+U_NAMESPACE_BEGIN
+
 #define ANY_NUMBER 1
 
 typedef le_uint16 Offset;
@@ -62,4 +69,5 @@
     FeatureMask mask;
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/OpenTypeUtilities.cpp b/src/share/native/sun/font/layout/OpenTypeUtilities.cpp
--- jdk/src/share/native/sun/font/layout/OpenTypeUtilities.cpp
+++ jdk/src/share/native/sun/font/layout/OpenTypeUtilities.cpp
@@ -34,6 +34,8 @@
 #include "OpenTypeUtilities.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 //
 // Finds the high bit by binary searching
 // through the bits in n.
@@ -192,3 +194,7 @@
         array[i + 1] = v;
     }
 }
+
+
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/OpenTypeUtilities.h b/src/share/native/sun/font/layout/OpenTypeUtilities.h
--- jdk/src/share/native/sun/font/layout/OpenTypeUtilities.h
+++ jdk/src/share/native/sun/font/layout/OpenTypeUtilities.h
@@ -32,10 +32,17 @@
 #ifndef __OPENTYPEUTILITIES_H
 #define __OPENTYPEUTILITIES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 
-class OpenTypeUtilities {
+U_NAMESPACE_BEGIN
+
+class OpenTypeUtilities /* not : public UObject because all methods are static */ {
 public:
     static le_int8 highBit(le_int32 value);
     static Offset getTagOffset(LETag tag, const TagAndOffsetRecord *records, le_int32 recordCount);
@@ -48,4 +55,5 @@
     OpenTypeUtilities() {} // private - forbid instantiation
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/PairPositioningSubtables.cpp b/src/share/native/sun/font/layout/PairPositioningSubtables.cpp
--- jdk/src/share/native/sun/font/layout/PairPositioningSubtables.cpp
+++ jdk/src/share/native/sun/font/layout/PairPositioningSubtables.cpp
@@ -39,6 +39,8 @@
 #include "OpenTypeUtilities.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 le_uint32 PairPositioningSubtable::process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const
 {
     switch(SWAPW(subtableFormat))
@@ -82,8 +84,7 @@
         const PairValueRecord *pairValueRecord = NULL;
 
         if (pairValueCount != 0) {
-            pairValueRecord = findPairValueRecord((TTGlyphID) LE_GET_GLYPH(secondGlyph),
-                pairSetTable->pairValueRecordArray, pairValueCount, recordSize);
+            pairValueRecord = findPairValueRecord((TTGlyphID) LE_GET_GLYPH(secondGlyph), pairSetTable->pairValueRecordArray, pairValueCount, recordSize);
         }
 
         if (pairValueRecord == NULL) {
@@ -91,8 +92,7 @@
         }
 
         if (valueFormat1 != 0) {
-            pairValueRecord->valueRecord1.adjustPosition(SWAPW(valueFormat1), (char *) this,
-                tempIterator, fontInstance);
+            pairValueRecord->valueRecord1.adjustPosition(SWAPW(valueFormat1), (char *) this, tempIterator, fontInstance);
         }
 
         if (valueFormat2 != 0) {
@@ -171,3 +171,5 @@
 
     return NULL;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/PairPositioningSubtables.h b/src/share/native/sun/font/layout/PairPositioningSubtables.h
--- jdk/src/share/native/sun/font/layout/PairPositioningSubtables.h
+++ jdk/src/share/native/sun/font/layout/PairPositioningSubtables.h
@@ -32,6 +32,11 @@
 #ifndef __PAIRPOSITIONINGSUBTABLES_H
 #define __PAIRPOSITIONINGSUBTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEFontInstance.h"
 #include "OpenTypeTables.h"
@@ -39,6 +44,8 @@
 #include "ValueRecords.h"
 #include "GlyphIterator.h"
 
+U_NAMESPACE_BEGIN
+
 // NOTE: ValueRecord has a variable size
 struct PairValueRecord
 {
@@ -96,4 +103,7 @@
     le_uint32  process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
 };
 
+U_NAMESPACE_END
 #endif
+
+
diff --git a/src/share/native/sun/font/layout/ScriptAndLanguage.cpp b/src/share/native/sun/font/layout/ScriptAndLanguage.cpp
--- jdk/src/share/native/sun/font/layout/ScriptAndLanguage.cpp
+++ jdk/src/share/native/sun/font/layout/ScriptAndLanguage.cpp
@@ -25,6 +25,7 @@
 
 /*
  *
+ *
  * (C) Copyright IBM Corp. 1998-2003 - All Rights Reserved
  *
  */
@@ -35,6 +36,8 @@
 #include "ScriptAndLanguage.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 const LangSysTable *ScriptTable::findLanguage(LETag languageTag, le_bool exactMatch) const
 {
     le_uint16 count = SWAPW(langSysCount);
@@ -79,3 +82,5 @@
 
     return scriptTable->findLanguage(languageTag, exactMatch);
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/ScriptAndLanguage.h b/src/share/native/sun/font/layout/ScriptAndLanguage.h
--- jdk/src/share/native/sun/font/layout/ScriptAndLanguage.h
+++ jdk/src/share/native/sun/font/layout/ScriptAndLanguage.h
@@ -32,9 +32,16 @@
 #ifndef __SCRIPTANDLANGUAGE_H
 #define __SCRIPTANDLANGUAGE_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "OpenTypeTables.h"
 
+U_NAMESPACE_BEGIN
+
 typedef TagAndOffsetRecord LangSysRecord;
 
 struct LangSysTable
@@ -65,4 +72,6 @@
     const LangSysTable  *findLanguage(LETag scriptTag, LETag languageTag, le_bool exactMatch = FALSE) const;
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/ScriptAndLanguageTags.cpp b/src/share/native/sun/font/layout/ScriptAndLanguageTags.cpp
--- jdk/src/share/native/sun/font/layout/ScriptAndLanguageTags.cpp
+++ jdk/src/share/native/sun/font/layout/ScriptAndLanguageTags.cpp
@@ -35,6 +35,8 @@
 #include "ScriptAndLanguageTags.h"
 #include "OpenTypeLayoutEngine.h"
 
+U_NAMESPACE_BEGIN
+
 const LETag OpenTypeLayoutEngine::scriptTags[] = {
     zyyyScriptTag, /* 'zyyy' (COMMON) */
     qaaiScriptTag, /* 'qaai' (INHERITED) */
@@ -125,3 +127,5 @@
     zhsLanguageTag, /* 'ZHS' (Chinese (Simplified)) */
     zhtLanguageTag  /* 'ZHT' (Chinese (Traditional)) */
 };
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/ScriptAndLanguageTags.h b/src/share/native/sun/font/layout/ScriptAndLanguageTags.h
--- jdk/src/share/native/sun/font/layout/ScriptAndLanguageTags.h
+++ jdk/src/share/native/sun/font/layout/ScriptAndLanguageTags.h
@@ -36,6 +36,13 @@
 
 #include "LETypes.h"
 
+U_NAMESPACE_BEGIN
+
+/**
+ * \file
+ * \internal
+ */
+
 const LETag zyyyScriptTag = 0x7A797979; /* 'zyyy' (COMMON) */
 const LETag qaaiScriptTag = 0x71616169; /* 'qaai' (INHERITED) */
 const LETag arabScriptTag = 0x61726162; /* 'arab' (ARABIC) */
@@ -126,4 +133,6 @@
 const LETag zhsLanguageTag = 0x5A485320; /* 'ZHS' (Chinese (Simplified)) */
 const LETag zhtLanguageTag = 0x5A485420; /* 'ZHT' (Chinese (Traditional)) */
 
+
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/SegmentArrayProcessor.cpp b/src/share/native/sun/font/layout/SegmentArrayProcessor.cpp
--- jdk/src/share/native/sun/font/layout/SegmentArrayProcessor.cpp
+++ jdk/src/share/native/sun/font/layout/SegmentArrayProcessor.cpp
@@ -38,6 +38,10 @@
 #include "LEGlyphStorage.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(SegmentArrayProcessor)
+
 SegmentArrayProcessor::SegmentArrayProcessor()
 {
 }
@@ -77,3 +81,5 @@
         }
     }
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/SegmentArrayProcessor.h b/src/share/native/sun/font/layout/SegmentArrayProcessor.h
--- jdk/src/share/native/sun/font/layout/SegmentArrayProcessor.h
+++ jdk/src/share/native/sun/font/layout/SegmentArrayProcessor.h
@@ -32,12 +32,19 @@
 #ifndef __SEGMENTARRAYPROCESSOR_H
 #define __SEGMENTARRAYPROCESSOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "MorphTables.h"
 #include "SubtableProcessor.h"
 #include "NonContextualGlyphSubst.h"
 #include "NonContextualGlyphSubstProc.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 class SegmentArrayProcessor : public NonContextualGlyphSubstitutionProcessor
@@ -49,11 +56,28 @@
 
     virtual ~SegmentArrayProcessor();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 private:
     SegmentArrayProcessor();
 
 protected:
     const SegmentArrayLookupTable *segmentArrayLookupTable;
+
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/SegmentSingleProcessor.cpp b/src/share/native/sun/font/layout/SegmentSingleProcessor.cpp
--- jdk/src/share/native/sun/font/layout/SegmentSingleProcessor.cpp
+++ jdk/src/share/native/sun/font/layout/SegmentSingleProcessor.cpp
@@ -38,6 +38,10 @@
 #include "LEGlyphStorage.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(SegmentSingleProcessor)
+
 SegmentSingleProcessor::SegmentSingleProcessor()
 {
 }
@@ -71,3 +75,5 @@
         }
     }
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/SegmentSingleProcessor.h b/src/share/native/sun/font/layout/SegmentSingleProcessor.h
--- jdk/src/share/native/sun/font/layout/SegmentSingleProcessor.h
+++ jdk/src/share/native/sun/font/layout/SegmentSingleProcessor.h
@@ -32,12 +32,19 @@
 #ifndef __SEGMENTSINGLEPROCESSOR_H
 #define __SEGMENTSINGLEPROCESSOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "MorphTables.h"
 #include "SubtableProcessor.h"
 #include "NonContextualGlyphSubst.h"
 #include "NonContextualGlyphSubstProc.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 class SegmentSingleProcessor : public NonContextualGlyphSubstitutionProcessor
@@ -49,11 +56,28 @@
 
     virtual ~SegmentSingleProcessor();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 private:
     SegmentSingleProcessor();
 
 protected:
     const SegmentSingleLookupTable *segmentSingleLookupTable;
+
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/ShapingTypeData.cpp b/src/share/native/sun/font/layout/ShapingTypeData.cpp
--- jdk/src/share/native/sun/font/layout/ShapingTypeData.cpp
+++ jdk/src/share/native/sun/font/layout/ShapingTypeData.cpp
@@ -36,6 +36,8 @@
 #include "LETypes.h"
 #include "ArabicShaping.h"
 
+U_NAMESPACE_BEGIN
+
 const le_uint8 ArabicShaping::shapingTypeTable[] = {
     0x00, 0x02, 0x00, 0xAD, 0x00, 0xAD, 0x00, 0xAD, 0x00, 0x05, 0x03, 0x00, 0x03, 0x6F, 0x00, 0x05,
     0x04, 0x83, 0x04, 0x86, 0x00, 0x05, 0x04, 0x88, 0x04, 0x89, 0x00, 0x05, 0x05, 0x91, 0x05, 0xB9,
@@ -104,3 +106,5 @@
     0xFE, 0x20, 0xFE, 0x23, 0x00, 0x05, 0xFE, 0xFF, 0xFE, 0xFF, 0x00, 0x05, 0xFF, 0xF9, 0xFF, 0xFB,
     0x00, 0x05
 };
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/SimpleArrayProcessor.cpp b/src/share/native/sun/font/layout/SimpleArrayProcessor.cpp
--- jdk/src/share/native/sun/font/layout/SimpleArrayProcessor.cpp
+++ jdk/src/share/native/sun/font/layout/SimpleArrayProcessor.cpp
@@ -38,6 +38,10 @@
 #include "LEGlyphStorage.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(SimpleArrayProcessor)
+
 SimpleArrayProcessor::SimpleArrayProcessor()
 {
 }
@@ -68,3 +72,5 @@
         }
     }
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/SimpleArrayProcessor.h b/src/share/native/sun/font/layout/SimpleArrayProcessor.h
--- jdk/src/share/native/sun/font/layout/SimpleArrayProcessor.h
+++ jdk/src/share/native/sun/font/layout/SimpleArrayProcessor.h
@@ -32,12 +32,19 @@
 #ifndef __SIMPLEARRAYPROCESSOR_H
 #define __SIMPLEARRAYPROCESSOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "MorphTables.h"
 #include "SubtableProcessor.h"
 #include "NonContextualGlyphSubst.h"
 #include "NonContextualGlyphSubstProc.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 class SimpleArrayProcessor : public NonContextualGlyphSubstitutionProcessor
@@ -49,11 +56,28 @@
 
     virtual ~SimpleArrayProcessor();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 private:
     SimpleArrayProcessor();
 
 protected:
     const SimpleArrayLookupTable *simpleArrayLookupTable;
+
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/SinglePositioningSubtables.cpp b/src/share/native/sun/font/layout/SinglePositioningSubtables.cpp
--- jdk/src/share/native/sun/font/layout/SinglePositioningSubtables.cpp
+++ jdk/src/share/native/sun/font/layout/SinglePositioningSubtables.cpp
@@ -38,6 +38,8 @@
 #include "GlyphIterator.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 le_uint32 SinglePositioningSubtable::process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const
 {
     switch(SWAPW(subtableFormat))
@@ -84,11 +86,12 @@
     le_int16 coverageIndex = (le_int16) getGlyphCoverage(glyph);
 
     if (coverageIndex >= 0) {
-        valueRecordArray[0].adjustPosition(coverageIndex, SWAPW(valueFormat), (const char *) this,
-            *glyphIterator, fontInstance);
+        valueRecordArray[0].adjustPosition(coverageIndex, SWAPW(valueFormat), (const char *) this, *glyphIterator, fontInstance);
 
         return 1;
     }
 
     return 0;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/SinglePositioningSubtables.h b/src/share/native/sun/font/layout/SinglePositioningSubtables.h
--- jdk/src/share/native/sun/font/layout/SinglePositioningSubtables.h
+++ jdk/src/share/native/sun/font/layout/SinglePositioningSubtables.h
@@ -32,6 +32,11 @@
 #ifndef __SINGLEPOSITIONINGSUBTABLES_H
 #define __SINGLEPOSITIONINGSUBTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEFontInstance.h"
 #include "OpenTypeTables.h"
@@ -39,6 +44,8 @@
 #include "ValueRecords.h"
 #include "GlyphIterator.h"
 
+U_NAMESPACE_BEGIN
+
 struct SinglePositioningSubtable : GlyphPositioningSubtable
 {
     le_uint32  process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
@@ -61,4 +68,7 @@
     le_uint32  process(GlyphIterator *glyphIterator, const LEFontInstance *fontInstance) const;
 };
 
+U_NAMESPACE_END
 #endif
+
+
diff --git a/src/share/native/sun/font/layout/SingleSubstitutionSubtables.cpp b/src/share/native/sun/font/layout/SingleSubstitutionSubtables.cpp
--- jdk/src/share/native/sun/font/layout/SingleSubstitutionSubtables.cpp
+++ jdk/src/share/native/sun/font/layout/SingleSubstitutionSubtables.cpp
@@ -37,6 +37,8 @@
 #include "GlyphIterator.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 le_uint32 SingleSubstitutionSubtable::process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter) const
 {
     switch(SWAPW(subtableFormat))
@@ -98,3 +100,5 @@
 
     return 0;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/SingleSubstitutionSubtables.h b/src/share/native/sun/font/layout/SingleSubstitutionSubtables.h
--- jdk/src/share/native/sun/font/layout/SingleSubstitutionSubtables.h
+++ jdk/src/share/native/sun/font/layout/SingleSubstitutionSubtables.h
@@ -32,12 +32,19 @@
 #ifndef __SINGLESUBSTITUTIONSUBTABLES_H
 #define __SINGLESUBSTITUTIONSUBTABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEGlyphFilter.h"
 #include "OpenTypeTables.h"
 #include "GlyphSubstitutionTables.h"
 #include "GlyphIterator.h"
 
+U_NAMESPACE_BEGIN
+
 struct SingleSubstitutionSubtable : GlyphSubstitutionSubtable
 {
     le_uint32  process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter = NULL) const;
@@ -58,4 +65,7 @@
     le_uint32  process(GlyphIterator *glyphIterator, const LEGlyphFilter *filter = NULL) const;
 };
 
+U_NAMESPACE_END
 #endif
+
+
diff --git a/src/share/native/sun/font/layout/SingleTableProcessor.cpp b/src/share/native/sun/font/layout/SingleTableProcessor.cpp
--- jdk/src/share/native/sun/font/layout/SingleTableProcessor.cpp
+++ jdk/src/share/native/sun/font/layout/SingleTableProcessor.cpp
@@ -38,6 +38,10 @@
 #include "LEGlyphStorage.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(SingleTableProcessor)
+
 SingleTableProcessor::SingleTableProcessor()
 {
 }
@@ -68,3 +72,5 @@
         }
     }
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/SingleTableProcessor.h b/src/share/native/sun/font/layout/SingleTableProcessor.h
--- jdk/src/share/native/sun/font/layout/SingleTableProcessor.h
+++ jdk/src/share/native/sun/font/layout/SingleTableProcessor.h
@@ -32,12 +32,19 @@
 #ifndef __SINGLETABLEPROCESSOR_H
 #define __SINGLETABLEPROCESSOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "MorphTables.h"
 #include "SubtableProcessor.h"
 #include "NonContextualGlyphSubst.h"
 #include "NonContextualGlyphSubstProc.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 class SingleTableProcessor : public NonContextualGlyphSubstitutionProcessor
@@ -49,11 +56,27 @@
 
     virtual ~SingleTableProcessor();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 private:
     SingleTableProcessor();
 
 protected:
     const SingleTableLookupTable *singleTableLookupTable;
+
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/StateTableProcessor.cpp b/src/share/native/sun/font/layout/StateTableProcessor.cpp
--- jdk/src/share/native/sun/font/layout/StateTableProcessor.cpp
+++ jdk/src/share/native/sun/font/layout/StateTableProcessor.cpp
@@ -38,6 +38,8 @@
 #include "LEGlyphStorage.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 StateTableProcessor::StateTableProcessor()
 {
 }
@@ -101,3 +103,5 @@
 
     endStateTable();
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/StateTableProcessor.h b/src/share/native/sun/font/layout/StateTableProcessor.h
--- jdk/src/share/native/sun/font/layout/StateTableProcessor.h
+++ jdk/src/share/native/sun/font/layout/StateTableProcessor.h
@@ -32,11 +32,18 @@
 #ifndef __STATETABLEPROCESSOR_H
 #define __STATETABLEPROCESSOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "MorphTables.h"
 #include "MorphStateTables.h"
 #include "SubtableProcessor.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 class StateTableProcessor : public SubtableProcessor
@@ -72,4 +79,5 @@
     StateTableProcessor &operator=(const StateTableProcessor &other); // forbid copying of this class
 };
 
+U_NAMESPACE_END
 #endif
diff --git a/src/share/native/sun/font/layout/StateTables.h b/src/share/native/sun/font/layout/StateTables.h
--- jdk/src/share/native/sun/font/layout/StateTables.h
+++ jdk/src/share/native/sun/font/layout/StateTables.h
@@ -32,6 +32,11 @@
 #ifndef __STATETABLES_H
 #define __STATETABLES_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LayoutTables.h"
 
@@ -70,6 +75,8 @@
 #define LE_STATE_PATIENCE_INCR(x)    if((x)!=le_patience_curr) ++le_patience_count;
 
 
+U_NAMESPACE_BEGIN
+
 struct StateTableHeader
 {
     le_int16 stateSize;
@@ -113,4 +120,6 @@
     le_int16    flags;
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/SubstitutionLookups.cpp b/src/share/native/sun/font/layout/SubstitutionLookups.cpp
--- jdk/src/share/native/sun/font/layout/SubstitutionLookups.cpp
+++ jdk/src/share/native/sun/font/layout/SubstitutionLookups.cpp
@@ -39,6 +39,8 @@
 #include "CoverageTables.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 /*
     NOTE: This could be optimized somewhat by keeping track
     of the previous sequenceIndex in the loop and doing next()
@@ -65,3 +67,5 @@
         lookupProcessor->applySingleLookup(lookupListIndex, &tempIterator, fontInstance);
     }
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/SubstitutionLookups.h b/src/share/native/sun/font/layout/SubstitutionLookups.h
--- jdk/src/share/native/sun/font/layout/SubstitutionLookups.h
+++ jdk/src/share/native/sun/font/layout/SubstitutionLookups.h
@@ -32,6 +32,11 @@
 #ifndef __SUBSTITUTIONLOOKUPS_H
 #define __SUBSTITUTIONLOOKUPS_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEFontInstance.h"
 #include "OpenTypeTables.h"
@@ -39,6 +44,8 @@
 #include "GlyphIterator.h"
 #include "LookupProcessor.h"
 
+U_NAMESPACE_BEGIN
+
 struct SubstitutionLookupRecord
 {
     le_uint16  sequenceIndex;
@@ -56,4 +63,6 @@
         le_int32 position);
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/SubtableProcessor.cpp b/src/share/native/sun/font/layout/SubtableProcessor.cpp
--- jdk/src/share/native/sun/font/layout/SubtableProcessor.cpp
+++ jdk/src/share/native/sun/font/layout/SubtableProcessor.cpp
@@ -34,6 +34,8 @@
 #include "SubtableProcessor.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 SubtableProcessor::SubtableProcessor()
 {
 }
@@ -50,3 +52,5 @@
 SubtableProcessor::~SubtableProcessor()
 {
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/SubtableProcessor.h b/src/share/native/sun/font/layout/SubtableProcessor.h
--- jdk/src/share/native/sun/font/layout/SubtableProcessor.h
+++ jdk/src/share/native/sun/font/layout/SubtableProcessor.h
@@ -32,13 +32,19 @@
 #ifndef __SUBTABLEPROCESSOR_H
 #define __SUBTABLEPROCESSOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "MorphTables.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
-class SubtableProcessor
-{
+class SubtableProcessor : public UMemory {
 public:
     virtual void process(LEGlyphStorage &glyphStorage) = 0;
     virtual ~SubtableProcessor();
@@ -60,4 +66,6 @@
     SubtableProcessor &operator=(const SubtableProcessor &other); // forbid copying of this class
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/ThaiLayoutEngine.cpp b/src/share/native/sun/font/layout/ThaiLayoutEngine.cpp
--- jdk/src/share/native/sun/font/layout/ThaiLayoutEngine.cpp
+++ jdk/src/share/native/sun/font/layout/ThaiLayoutEngine.cpp
@@ -38,8 +38,11 @@
 
 #include "ThaiShaping.h"
 
-ThaiLayoutEngine::ThaiLayoutEngine(const LEFontInstance *fontInstance,
-    le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags)
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(ThaiLayoutEngine)
+
+ThaiLayoutEngine::ThaiLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags)
     : LayoutEngine(fontInstance, scriptCode, languageCode, typoFlags)
 {
     fErrorChar = 0x25CC;
@@ -73,16 +76,13 @@
 // Output: glyphs, char indices
 // Returns: the glyph count
 // NOTE: this assumes that ThaiShaping::compose will allocate the outChars array...
-le_int32 ThaiLayoutEngine::computeGlyphs(const LEUnicode chars[], le_int32 offset,
-    le_int32 count, le_int32 max, le_bool /*rightToLeft*/,
-    LEGlyphStorage &glyphStorage, LEErrorCode &success)
+le_int32 ThaiLayoutEngine::computeGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool /*rightToLeft*/, LEGlyphStorage &glyphStorage, LEErrorCode &success)
 {
     if (LE_FAILURE(success)) {
         return 0;
     }
 
-    if (chars == NULL || offset < 0 || count < 0 || max < 0 ||
-        offset >= max || offset + count > max) {
+    if (chars == NULL || offset < 0 || count < 0 || max < 0 || offset >= max || offset + count > max) {
         success = LE_ILLEGAL_ARGUMENT_ERROR;
         return 0;
     }
@@ -107,8 +107,7 @@
         return 0;
     }
 
-    glyphCount = ThaiShaping::compose(chars, offset, count, fGlyphSet, fErrorChar,
-        outChars, glyphStorage);
+    glyphCount = ThaiShaping::compose(chars, offset, count, fGlyphSet, fErrorChar, outChars, glyphStorage);
     mapCharsToGlyphs(outChars, 0, glyphCount, FALSE, FALSE, glyphStorage, success);
 
     LE_DELETE_ARRAY(outChars);
@@ -116,3 +115,5 @@
     glyphStorage.adoptGlyphCount(glyphCount);
     return glyphCount;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/ThaiLayoutEngine.h b/src/share/native/sun/font/layout/ThaiLayoutEngine.h
--- jdk/src/share/native/sun/font/layout/ThaiLayoutEngine.h
+++ jdk/src/share/native/sun/font/layout/ThaiLayoutEngine.h
@@ -39,6 +39,8 @@
 
 #include "ThaiShaping.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 /**
@@ -66,8 +68,7 @@
      *
      * @internal
      */
-    ThaiLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode,
-        le_int32 languageCode, le_int32 typoFlags);
+    ThaiLayoutEngine(const LEFontInstance *fontInstance, le_int32 scriptCode, le_int32 languageCode, le_int32 typoFlags);
 
     /**
      * The destructor, virtual for correct polymorphic invocation.
@@ -76,6 +77,20 @@
      */
     virtual ~ThaiLayoutEngine();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 protected:
     /**
      * A small integer indicating which Thai encoding
@@ -109,10 +124,8 @@
      * @param offset - the index of the first character to process
      * @param count - the number of characters to process
      * @param max - the number of characters in the input context
-     * @param rightToLeft - <code>TRUE</code> if the text is in a
-     *    right to left directional run
-     * @param glyphStorage - the glyph storage object. The glyph and
-     *    char index arrays will be set.
+     * @param rightToLeft - <code>TRUE</code> if the text is in a right to left directional run
+     * @param glyphStorage - the glyph storage object. The glyph and char index arrays will be set.
      *
      * Output parameters:
      * @param success - set to an error code if the operation fails
@@ -123,10 +136,11 @@
      *
      * @internal
      */
-    virtual le_int32 computeGlyphs(const LEUnicode chars[], le_int32 offset,
-        le_int32 count, le_int32 max, le_bool rightToLeft,
+    virtual le_int32 computeGlyphs(const LEUnicode chars[], le_int32 offset, le_int32 count, le_int32 max, le_bool rightToLeft,
         LEGlyphStorage &glyphStorage, LEErrorCode &success);
 
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/ThaiShaping.cpp b/src/share/native/sun/font/layout/ThaiShaping.cpp
--- jdk/src/share/native/sun/font/layout/ThaiShaping.cpp
+++ jdk/src/share/native/sun/font/layout/ThaiShaping.cpp
@@ -35,6 +35,8 @@
 #include "LEGlyphStorage.h"
 #include "ThaiShaping.h"
 
+U_NAMESPACE_BEGIN
+
 enum {
     CH_SPACE        = 0x0020,
     CH_YAMAKKAN     = 0x0E4E,
@@ -248,9 +250,8 @@
      return transition.nextState;
 }
 
-le_uint8 ThaiShaping::getNextState(LEUnicode ch, le_uint8 prevState, le_int32 inputIndex,
-    le_uint8 glyphSet, LEUnicode errorChar,
-    le_uint8 &charClass, LEUnicode *output, LEGlyphStorage &glyphStorage, le_int32 &outputIndex)
+le_uint8 ThaiShaping::getNextState(LEUnicode ch, le_uint8 prevState, le_int32 inputIndex, le_uint8 glyphSet, LEUnicode errorChar,
+                              le_uint8 &charClass, LEUnicode *output, LEGlyphStorage &glyphStorage, le_int32 &outputIndex)
 {
     StateTransition transition;
 
@@ -327,3 +328,5 @@
 
     return outputIndex;
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/ThaiShaping.h b/src/share/native/sun/font/layout/ThaiShaping.h
--- jdk/src/share/native/sun/font/layout/ThaiShaping.h
+++ jdk/src/share/native/sun/font/layout/ThaiShaping.h
@@ -32,13 +32,20 @@
 #ifndef __THAISHAPING_H
 #define __THAISHAPING_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEGlyphFilter.h"
 #include "OpenTypeTables.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
-class ThaiShaping {
+class ThaiShaping /* not : public UObject because all methods are static */ {
 public:
 
     enum {
@@ -120,4 +127,7 @@
     return thaiStateTable[state][currClass];
 }
 
+U_NAMESPACE_END
 #endif
+
+
diff --git a/src/share/native/sun/font/layout/ThaiStateTables.cpp b/src/share/native/sun/font/layout/ThaiStateTables.cpp
--- jdk/src/share/native/sun/font/layout/ThaiStateTables.cpp
+++ jdk/src/share/native/sun/font/layout/ThaiStateTables.cpp
@@ -25,6 +25,7 @@
 
 /*
  *
+ *
  * (C) Copyright IBM Corp. 1999-2003 - All Rights Reserved
  *
  * WARNING: THIS FILE IS MACHINE GENERATED. DO NOT HAND EDIT IT UNLESS
@@ -35,6 +36,8 @@
 #include "LETypes.h"
 #include "ThaiShaping.h"
 
+U_NAMESPACE_BEGIN
+
 const le_uint8 ThaiShaping::classTable[] = {
     //       0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
     //       -------------------------------------------------------------------------------
@@ -105,3 +108,5 @@
     /*50*/ {{ 0, tA}, { 1, tA}, {18, tA}, {35, tA}, { 0, tA}, { 0, tS}, { 0, tS}, { 0, tA}, { 0, tR}, { 0, tR}, { 0, tR}, {51, tC}, { 0, tR}, { 0, tC}, { 0, tR}, { 0, tR}, { 0, tR}, { 0, tR}, { 0, tR}},
     /*51*/ {{ 0, tA}, { 1, tA}, {18, tA}, {35, tA}, { 0, tA}, { 0, tS}, { 0, tA}, { 0, tA}, { 0, tR}, { 0, tR}, { 0, tR}, { 0, tR}, { 0, tR}, { 0, tR}, { 0, tR}, { 0, tR}, { 0, tR}, { 0, tR}, { 0, tR}}
 };
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/TrimmedArrayProcessor.cpp b/src/share/native/sun/font/layout/TrimmedArrayProcessor.cpp
--- jdk/src/share/native/sun/font/layout/TrimmedArrayProcessor.cpp
+++ jdk/src/share/native/sun/font/layout/TrimmedArrayProcessor.cpp
@@ -38,6 +38,10 @@
 #include "LEGlyphStorage.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(TrimmedArrayProcessor)
+
 TrimmedArrayProcessor::TrimmedArrayProcessor()
 {
 }
@@ -72,3 +76,5 @@
         }
     }
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/TrimmedArrayProcessor.h b/src/share/native/sun/font/layout/TrimmedArrayProcessor.h
--- jdk/src/share/native/sun/font/layout/TrimmedArrayProcessor.h
+++ jdk/src/share/native/sun/font/layout/TrimmedArrayProcessor.h
@@ -32,12 +32,19 @@
 #ifndef __TRIMMEDARRAYPROCESSOR_H
 #define __TRIMMEDARRAYPROCESSOR_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "MorphTables.h"
 #include "SubtableProcessor.h"
 #include "NonContextualGlyphSubst.h"
 #include "NonContextualGlyphSubstProc.h"
 
+U_NAMESPACE_BEGIN
+
 class LEGlyphStorage;
 
 class TrimmedArrayProcessor : public NonContextualGlyphSubstitutionProcessor
@@ -49,6 +56,20 @@
 
     virtual ~TrimmedArrayProcessor();
 
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for the actual class.
+     *
+     * @stable ICU 2.8
+     */
+    virtual UClassID getDynamicClassID() const;
+
+    /**
+     * ICU "poor man's RTTI", returns a UClassID for this class.
+     *
+     * @stable ICU 2.8
+     */
+    static UClassID getStaticClassID();
+
 private:
     TrimmedArrayProcessor();
 
@@ -56,6 +77,9 @@
     TTGlyphID firstGlyph;
     TTGlyphID lastGlyph;
     const TrimmedArrayLookupTable *trimmedArrayLookupTable;
+
 };
 
+U_NAMESPACE_END
 #endif
+
diff --git a/src/share/native/sun/font/layout/ValueRecords.cpp b/src/share/native/sun/font/layout/ValueRecords.cpp
--- jdk/src/share/native/sun/font/layout/ValueRecords.cpp
+++ jdk/src/share/native/sun/font/layout/ValueRecords.cpp
@@ -37,6 +37,8 @@
 #include "GlyphIterator.h"
 #include "LESwaps.h"
 
+U_NAMESPACE_BEGIN
+
 #define Nibble(value, nibble) ((value >> (nibble * 4)) & 0xF)
 #define NibbleBits(value, nibble) (bitsInNibble[Nibble(value, nibble)])
 
@@ -161,8 +163,8 @@
         xPlacementAdjustment, yPlacementAdjustment, xAdvanceAdjustment, yAdvanceAdjustment);
 }
 
-void ValueRecord::adjustPosition(le_int16 index, ValueFormat valueFormat, const char *base,
-    GlyphIterator &glyphIterator, const LEFontInstance *fontInstance) const
+void ValueRecord::adjustPosition(le_int16 index, ValueFormat valueFormat, const char *base, GlyphIterator &glyphIterator,
+                                 const LEFontInstance *fontInstance) const
 {
     float xPlacementAdjustment = 0;
     float yPlacementAdjustment = 0;
@@ -323,3 +325,5 @@
 
     return getFieldCount(valueFormat & beforeMasks[field]);
 }
+
+U_NAMESPACE_END
diff --git a/src/share/native/sun/font/layout/ValueRecords.h b/src/share/native/sun/font/layout/ValueRecords.h
--- jdk/src/share/native/sun/font/layout/ValueRecords.h
+++ jdk/src/share/native/sun/font/layout/ValueRecords.h
@@ -32,11 +32,18 @@
 #ifndef __VALUERECORDS_H
 #define __VALUERECORDS_H
 
+/**
+ * \file
+ * \internal
+ */
+
 #include "LETypes.h"
 #include "LEFontInstance.h"
 #include "OpenTypeTables.h"
 #include "GlyphIterator.h"
 
+U_NAMESPACE_BEGIN
+
 typedef le_uint16 ValueFormat;
 typedef le_int16 ValueRecordField;
 
@@ -84,5 +91,7 @@
     vfbAnyDevice    = vfbXPlaDevice + vfbYPlaDevice + vfbXAdvDevice + vfbYAdvDevice
 };
 
+U_NAMESPACE_END
+#endif
 
-#endif
+
