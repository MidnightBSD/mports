diff -ru ../../work/linuxthreads-2.2.3/Examples/Makefile ./Examples/Makefile
--- ../../work/linuxthreads-2.2.3/Examples/Makefile	Wed Mar 11 12:42:23 1998
+++ ./Examples/Makefile	Thu Jun  7 22:59:29 2001
@@ -1,6 +1,6 @@
 CC=gcc
-CFLAGS=-g -O -Wall -I.. -D_REENTRANT
-LIBPTHREAD=../libpthread.a
+CFLAGS=-g -O -Wall -I/usr/local/include/pthread/linuxthreads -D_REENTRANT
+LIBPTHREAD=-L/usr/local/lib -llthread -llgcc_r
 
 PROGS=ex1 ex2 ex3 ex4 ex5 proxy
 
diff -ru ../../work/linuxthreads-2.2.3/Makefile ./Makefile
--- ../../work/linuxthreads-2.2.3/Makefile	Wed Apr 25 21:50:59 2001
+++ ./Makefile	Thu Jun  7 23:13:52 2001
@@ -1,128 +1,143 @@
-# Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
-# This file is part of the GNU C Library.
+LIB=lthread
+.if defined(LINUXTHREADS_WRAP_API)
+.if defined(USING_GCC3)
+SHLIB_MAJOR= 5
+.else
+SHLIB_MAJOR= 4
+.endif
+.else
+.if defined(USING_GCC3)
+SHLIB_MAJOR= 3
+.else
+SHLIB_MAJOR= 2
+.endif
+.endif
+SHLIB_MINOR= 2
+
+.if defined(INSTALL_LIBLTHREAD_PIC_ARCHIVE)
+INSTALL_PIC_ARCHIVE=	yes
+.endif
+
+.if !defined(MACHINE_ARCH)
+MACHINE_ARCH != /usr/bin/uname -m
+.endif
+
+.if !defined(LIBSRC_BASE)
+LIBSRC_BASE = /usr/src/lib
+.endif
+
+.if !defined(PREFIX)
+PREFIX=	${DESTDIR}/usr/local
+.endif
+
+LIBDIR=	${PREFIX:S,^${DESTDIR},,}/lib
+
+CFLAGS +=-g -O2 -Wall
+#CFLAGS +=-g -O0 -Wall -DDEBUG 
+CFLAGS +=-DCOMPILING_LINUXTHREADS
+#CFLAGS += -D__NO_WEAK_PTHREAD_ALIASES
+
+CFLAGS += -I${.CURDIR} 
+CFLAGS += -I${.CURDIR}/sysdeps/${MACHINE_ARCH}
+CFLAGS += -I${.CURDIR}/sysdeps/pthread
+CFLAGS += -I${.CURDIR}/sysdeps/unix/sysv/linux
+CFLAGS += -I${LIBSRC_BASE}/libc/stdtime
+#CFLAGS += -I${LIBSRC_BASE}/libc/${MACHINE_ARCH}
+CFLAGS += -DLIBC_RCS
+CFLAGS += -DLINUXTHREADS 
+CFLAGS += -D__USE_UNIX98
+CFLAGS += -D__USE_XOPEN2K -D_STACK_GROWS_DOWN -DNEWLIBC -D_THREAD_SAFE
+.if defined(LINUXTHREADS_MAX_STACK_SIZE)
+CFLAGS += -DSTACK_SIZE=$(LINUXTHREADS_MAX_STACK_SIZE)
+.endif
+.if defined(LINUXTHREADS_MAX_THREADS)
+CFLAGS += -DPTHREAD_THREADS_MAX=$(LINUXTHREADS_MAX_THREADS)
+.endif
+.if defined(LINUXTHREADS_DETECT_UNSAFE_EXIT)
+CFLAGS += -DLINUXTHREADS_DETECT_UNSAFE_EXIT
+.endif
+
+.if defined(LINUXTHREADS_WRAP_API)
+CFLAGS += -DLINUXTHREADS_WRAP_API
+LD=${LINUXTHREADS_WRAP_LD}
+.endif
+
+.if defined(LINUXTHREADS_NO_POSIX_PRIORITY_SCHEDULING)
+CFLAGS += -DLINUXTHREADS_NO_POSIX_PRIORITY_SCHEDULING
+.endif
+
+.if defined(LINUXTHREADS_ALT_RESTARTSIG)
+CFLAGS += -DLINUXTHREADS_ALT_RESTARTSIG=${LINUXTHREADS_ALT_RESTARTSIG}
+.endif
+
+CFLAGS += -I${LIBSRC_BASE}/libc/${MACHINE_ARCH} -I${.CURDIR}/sysdeps/${MACHINE_ARCH}
+
+# Contents of the library.
+SRCS := attr.c cancel.c clone.S condvar.c errno.c getgr_r.c gethostby_r.c \
+	getnetby_r.c getprotoby_r.c getpw_r.c getservby_r.c join.c lclone.c \
+	libc_calls.c libc_thread.c manager.c mutex.c pt-machine.c ptfork.c \
+	pthread.c ptlongjmp.c rwlock.c sched.c semaphore.c signals.c \
+	specific.c spinlock.c uthread_file.c wraputhread.c wrapsyscall.c \
+	barrier.c localtime.c getlogin.c telldir.c ttyname.c strptime.c
+
+.if defined(USING_GCC3)
+SOBJS += libgcc_r/unwind-sjlj.o libgcc_r/unwind-dw2.o libgcc_r/unwind-dw2-fde.o
+.else
+SOBJS += libgcc_r/frame.o libgcc_r/_eh.o
+.endif
+
+beforeinstall:
+	${INSTALL} -d -o ${BINOWN} -g ${BINGRP} -m 0755 \
+		${PREFIX}/include/pthread/linuxthreads
+	${INSTALL} -C -o ${BINOWN} -g ${BINGRP} -m 444 \
+		${.CURDIR}/sysdeps/pthread/pthread.h \
+		${PREFIX}/include/pthread/linuxthreads/pthread.h
+	${INSTALL} -C -o ${BINOWN} -g ${BINGRP} -m 444 \
+		${.CURDIR}/semaphore.h \
+		${PREFIX}/include/pthread/linuxthreads/semaphore.h
+	${INSTALL} -d -o ${BINOWN} -g ${BINGRP} -m 0755 \
+		${PREFIX}/include/pthread/linuxthreads/bits
+.for hdr in libc-lock.h libc-tsd.h pthreadtypes.h stdio-lock.h initspin.h
+	${INSTALL} -C -o ${BINOWN} -g ${BINGRP} -m 444 \
+		${.CURDIR}/sysdeps/pthread/bits/$(hdr) \
+		${PREFIX}/include/pthread/linuxthreads/bits/$(hdr)
+.endfor
+.for hdr in local_lim.h posix_opt.h sigthread.h
+	${INSTALL} -C -o ${BINOWN} -g ${BINGRP} -m 444 \
+		${.CURDIR}/sysdeps/unix/sysv/linux/bits/$(hdr) \
+		${PREFIX}/include/pthread/linuxthreads/bits/$(hdr)
+.endfor
+	${INSTALL} -d -o ${BINOWN} -g ${BINGRP} -m 0755 \
+		${PREFIX}/include/pthread/linuxthreads/sys
+.for hdr in _pthreadtypes.h
+	${INSTALL} -C -o ${BINOWN} -g ${BINGRP} -m 444 \
+		${.CURDIR}/sys/$(hdr) \
+		${PREFIX}/include/pthread/linuxthreads/sys/$(hdr)
+.endfor
+.for hdr in pt-machine.h useldt.h
+	${INSTALL} -C -o ${BINOWN} -g ${BINGRP} -m 444 \
+		${.CURDIR}/sysdeps/i386/$(hdr) \
+		${PREFIX}/include/pthread/linuxthreads/$(hdr)
+.endfor
+	${INSTALL} -d -o ${BINOWN} -g ${BINGRP} -m 0755 ${PREFIX}/lib
 
-# The GNU C Library is free software; you can redistribute it and/or
-# modify it under the terms of the GNU Library General Public License as
-# published by the Free Software Foundation; either version 2 of the
-# License, or (at your option) any later version.
-
-# The GNU C Library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Library General Public License for more details.
-
-# You should have received a copy of the GNU Library General Public
-# License along with the GNU C Library; see the file COPYING.LIB.  If not,
-# write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-# Boston, MA 02111-1307, USA.
-
-#
-#	Sub-makefile for linuxthreads portion of the library.
-#
-subdir	:= linuxthreads
-
-linuxthreads-version := $(shell sed -n 's/^.*$(subdir)-\([0-9.]*\).*$$/\1/p' \
-				    Banner)
-
-headers := pthread.h semaphore.h
-distribute := internals.h queue.h restart.h spinlock.h
-
-routines := weaks no-tsd
-
-extra-libs := libpthread
-extra-libs-others := $(extra-libs)
-
-libpthread-routines := attr cancel condvar join manager mutex ptfork \
-		       ptlongjmp pthread signals specific errno lockfile \
-		       semaphore spinlock wrapsyscall rwlock pt-machine \
-		       oldsemaphore events getcpuclockid pspinlock barrier \
-		       ptclock_gettime ptclock_settime
-
-nodelete-yes = -Wl,--enable-new-dtags,-z,nodelete
-initfirst-yes = -Wl,--enable-new-dtags,-z,initfirst
-LDFLAGS-pthread.so = $(nodelete-$(have-z-nodelete)) \
-		     $(initfirst-$(have-z-initfirst))
-
-vpath %.c Examples
-
-tst-cancel-ARGS = "$(objpfx)"
-CFLAGS-tst-cancel.c = -fno-inline
-
-include ../Makeconfig
-
-ifeq ($(build-shared),yes)
-before-compile := $(objpfx)crti.o
-extra-objs = crti.o
-
-CFLAGS-pt-initfini.s = -g0 -fPIC -fno-inline-functions
-endif
-
-librt-tests = ex10 ex11
-tests = ex1 ex2 ex3 ex4 ex5 ex6 ex7 ex8 ex9 $(librt-tests) ex12 ex13 joinrace \
-	tststack $(tests-nodelete-$(have-z-nodelete)) ecmutex ex14 ex15 ex16 \
-	ex17 tst-cancel
-
-ifeq (yes,$(build-shared))
-tests-nodelete-yes = unload
-endif
-
-include ../Rules
-
-extra-B-pthread.so = -B$(common-objpfx)linuxthreads/
-
-znodelete-yes = -DHAVE_Z_NODELETE
-CFLAGS-mutex.c += -D__NO_WEAK_PTHREAD_ALIASES
-CFLAGS-specific.c += -D__NO_WEAK_PTHREAD_ALIASES
-CFLAGS-pthread.c += -D__NO_WEAK_PTHREAD_ALIASES $(znodelete-$(have-z-nodelete))
-CFLAGS-ptfork.c += -D__NO_WEAK_PTHREAD_ALIASES
-CFLAGS-cancel.c += -D__NO_WEAK_PTHREAD_ALIASES -D_RPC_THREAD_SAFE_
-CFLAGS-unload.c += -DPREFIX=\"$(objpfx)\"
-
-# Depend on libc.so so a DT_NEEDED is generated in the shared objects.
-# This ensures they will load libc.so for needed symbols if loaded by
-# a statically-linked program that hasn't already loaded it.
-$(objpfx)libpthread.so: $(common-objpfx)libc.so \
-			$(common-objpfx)libc_nonshared.a
-
-# Make sure we link with the thread library.
-ifeq ($(build-shared),yes)
-$(addprefix $(objpfx),$(tests)): $(objpfx)libpthread.so
-$(addprefix $(objpfx),$(librt-tests)): $(common-objpfx)rt/librt.so
-$(objpfx)unload: $(common-objpfx)dlfcn/libdl.so
-else
-$(addprefix $(objpfx),$(tests)): $(objpfx)libpthread.a
-$(addprefix $(objpfx),$(librt-tests)): $(common-objpfx)rt/librt.a
-endif
-ifeq ($(build-bounded),yes)
-$(tests:%=$(objpfx)%-bp): $(objpfx)libpthread_b.a
-$(librt-tests:%=$(objpfx)%-bp): $(common-objpfx)rt/librt_b.a
-endif
-
-ifeq ($(build-shared),yes)
-vpath pt-initfini.c $(full_config_sysdirs)
-
-$(objpfx)pt-initfini.s: pt-initfini.c
-	$(compile.c) -S $(CFLAGS-pt-initfini.s) -finhibit-size-directive \
-		$(patsubst -f%,-fno-%,$(exceptions)) -o $@
-
-# We only have one kind of startup code files.  Static binaries and
-# shared libraries are build using the PIC version.
-$(objpfx)crti.S: $(objpfx)pt-initfini.s
-	sed -n -e '1,/@HEADER_ENDS/p' \
-	       -e '/@_.*_PROLOG_BEGINS/,/@_.*_PROLOG_ENDS/p' \
-	       -e '/@TRAILER_BEGINS/,$$p' $< > $@
-
-$(objpfx)defs.h: $(objpfx)pt-initfini.s
-	sed -n -e '/@TESTS_BEGIN/,/@TESTS_END/p' $< | \
-		$(AWK) -f ../csu/defs.awk > $@
-
-$(objpfx)crti.o: $(objpfx)crti.S $(objpfx)defs.h
-	$(compile.S) -g0 $(ASFLAGS-.os) -o $@
-
-generated += crti.S defs.h pt-initfini.s
-endif
-
-ifeq (yes,$(build-static-nss))
-otherlibs += $(nssobjdir)/libnss_files.a $(resolvobjdir)/libnss_dns.a \
-             $(resolvobjdir)/libresolv.a
-endif
+
+.include <bsd.lib.mk>
+
+.if defined(LINUXTHREADS_WRAP_API)
+.c.o:
+	${CC} ${CFLAGS} -c ${.IMPSRC} -o ${.TARGET}
+	@${LD} ${LDFLAGS} -o ${.TARGET}.tmp -x -r ${.TARGET}
+	@mv ${.TARGET}.tmp ${.TARGET}
+ 
+.c.po:
+	${CC} -pg ${CFLAGS} -c ${.IMPSRC} -o ${.TARGET}
+	@${LD} ${LDFLAGS} -o ${.TARGET}.tmp -X -r ${.TARGET}
+	@mv ${.TARGET}.tmp ${.TARGET}
+ 
+.c.So:
+	${CC} ${PICFLAG} -DPIC ${CFLAGS} -c ${.IMPSRC} -o ${.TARGET}
+	@${LD} ${LDFLAGS} -o ${.TARGET}.tmp -x -r ${.TARGET}
+	@mv ${.TARGET}.tmp ${.TARGET}
+.endif
+ 
diff -ru ../../work/linuxthreads-2.2.3/attr.c ./attr.c
--- ../../work/linuxthreads-2.2.3/attr.c	Tue Mar 27 04:52:55 2001
+++ ./attr.c	Thu Jun  7 22:59:29 2001
@@ -18,11 +18,14 @@
 #include <string.h>
 #include <unistd.h>
 #include <sys/param.h>
+#include <sys/time.h>
 #include <sys/resource.h>
 #include "pthread.h"
 #include "internals.h"
+#if 0
 #include <shlib-compat.h>
 #include <stackinfo.h>
+#endif
 
 int __pthread_attr_init_2_1(pthread_attr_t *attr)
 {
@@ -30,7 +33,7 @@
 
   attr->__detachstate = PTHREAD_CREATE_JOINABLE;
   attr->__schedpolicy = SCHED_OTHER;
-  attr->__schedparam.sched_priority = 0;
+  attr->__schedparam.sched_priority = DEFAULT_PRIORITY;
   attr->__inheritsched = PTHREAD_EXPLICIT_SCHED;
   attr->__scope = PTHREAD_SCOPE_SYSTEM;
   attr->__guardsize = ps;
diff -ru ../../work/linuxthreads-2.2.3/cancel.c ./cancel.c
--- ../../work/linuxthreads-2.2.3/cancel.c	Thu Apr 12 23:10:53 2001
+++ ./cancel.c	Thu Jun  7 22:59:29 2001
@@ -20,8 +20,10 @@
 #include "internals.h"
 #include "spinlock.h"
 #include "restart.h"
-#include <stackinfo.h>
 
+#if 1
+#define FRAME_LEFT(frame, other) 0
+#else
 #ifdef _STACK_GROWS_DOWN
 # define FRAME_LEFT(frame, other) ((char *) frame >= (char *) other)
 #elif _STACK_GROWS_UP
@@ -29,6 +31,7 @@
 #else
 # error "Define either _STACK_GROWS_DOWN or _STACK_GROWS_UP"
 #endif
+#endif
 
 
 int pthread_setcancelstate(int state, int * oldstate)
@@ -202,9 +201,11 @@
 	break;
     }
 
+#if 0
   /* And the TSD which needs special help.  */
   if (THREAD_GETMEM(self, p_libc_specific[_LIBC_TSD_KEY_RPC_VARS]) != NULL)
     __rpc_thread_destroy ();
+#endif
 }
 
 #ifndef SHARED
diff -ru ../../work/linuxthreads-2.2.3/errno.c ./errno.c
--- ../../work/linuxthreads-2.2.3/errno.c	Sat Dec  4 20:31:49 1999
+++ ./errno.c	Thu Jun  7 22:59:29 2001
@@ -18,14 +18,17 @@
 #include <netdb.h>
 #include "pthread.h"
 #include "internals.h"
+#include <osreldate.h>
 
-int * __errno_location()
+int * __error()
 {
   pthread_descr self = thread_self();
   return THREAD_GETMEM (self, p_errnop);
 }
 
-int * __h_errno_location()
+#if __FreeBSD_version < 502104
+
+int * __h_error()
 {
   pthread_descr self = thread_self();
   return THREAD_GETMEM (self, p_h_errnop);
@@ -37,3 +40,5 @@
   pthread_descr self = thread_self();
   return THREAD_GETMEM (self, p_resp);
 }
+
+#endif /* #if __FreeBSD_version < 502104 */
diff -ru ../../work/linuxthreads-2.2.3/internals.h ./internals.h
--- ../../work/linuxthreads-2.2.3/internals.h	Wed Apr 25 21:50:59 2001
+++ ./internals.h	Thu Jun  7 22:59:29 2001
@@ -20,6 +20,7 @@
 /* Includes */
 
 #include <limits.h>
+#include <netinet/in.h>
 #include <resolv.h>
 #include <setjmp.h>
 #include <signal.h>
@@ -31,9 +32,8 @@
 extern int __compare_and_swap (long int *p, long int oldval, long int newval);
 
 #include "pt-machine.h"
+#include "freebsd-compat.h"
 #include "semaphore.h"
-#include "../linuxthreads_db/thread_dbP.h"
-#include <hp-timing.h>
 
 #ifndef THREAD_GETMEM
 # define THREAD_GETMEM(descr, member) descr->member
@@ -161,13 +161,18 @@
   char p_sigwaiting;            /* true if a sigwait() is in progress */
   struct pthread_start_args p_start_args; /* arguments for thread creation */
   void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE]; /* thread-specific data */
+  TAILQ_ENTRY(_pthread_descr_struct) qe;
+  char time_buf[26];
+  struct tm local_tm;
   void * p_libc_specific[_LIBC_TSD_KEY_N]; /* thread-specific data for libc */
   int p_userstack;		/* nonzero if the user provided the stack */
   void *p_guardaddr;		/* address of guard area or NULL */
   size_t p_guardsize;		/* size of guard area */
   int p_nr;                     /* Index of descriptor in __pthread_handles */
+#if 0
   int p_report_events;		/* Nonzero if events must be reported.  */
   td_eventbuf_t p_eventbuf;     /* Data for event.  */
+#endif
   struct pthread_atomic p_resume_count; /* number of times restart() was
 					   called on thread */
   char p_woken_by_cancel;       /* cancellation performed wakeup */
@@ -293,11 +298,13 @@
 
 extern volatile int __pthread_threads_debug;
 
+#if 0
 /* Globally enabled events.  */
 extern volatile td_thr_events_t __pthread_threads_events;
 
 /* Pointer to descriptor of thread with last event.  */
 extern volatile pthread_descr __pthread_last_event;
+#endif
 
 /* Flag which tells whether we are executing on SMP kernel. */
 extern int __pthread_smp_kernel;
@@ -510,8 +517,10 @@
 extern int __pthread_spin_init (pthread_spinlock_t *__lock, int __pshared);
 extern int __pthread_spin_destroy (pthread_spinlock_t *__lock);
 
+#if 0
 extern int __pthread_clock_gettime (hp_timing_t freq, struct timespec *tp);
 extern void __pthread_clock_settime (hp_timing_t offset);
+#endif
 
 
 /* Global pointers to old or new suspend functions */
@@ -545,7 +555,7 @@
 /* Prototypes for compatibility functions.  */
 extern int __pthread_attr_init_2_1 (pthread_attr_t *__attr);
 extern int __pthread_attr_init_2_0 (pthread_attr_t *__attr);
-extern int __pthread_create_2_1 (pthread_t *__restrict __thread,
+extern int __pthread_create_2_1 (pthread_t *__restrict __xthread,
 				 const pthread_attr_t *__attr,
 				 void *(*__start_routine) (void *),
 				 void *__restrict __arg);
diff -ru ../../work/linuxthreads-2.2.3/join.c ./join.c
--- ../../work/linuxthreads-2.2.3/join.c	Thu Apr 12 21:02:02 2001
+++ ./join.c	Thu Jun  7 22:59:29 2001
@@ -43,6 +43,7 @@
   /* Store return value */
   __pthread_lock(THREAD_GETMEM(self, p_lock), self);
   THREAD_SETMEM(self, p_retval, retval);
+#if 0
   /* See whether we have to signal the death.  */
   if (THREAD_GETMEM(self, p_report_events))
     {
@@ -64,6 +65,7 @@
 	  __linuxthreads_death_event();
 	}
     }
+#endif
   /* Say that we've terminated */
   THREAD_SETMEM(self, p_terminated, 1);
   /* See if someone is joining on us */
diff -ru ../../work/linuxthreads-2.2.3/manager.c ./manager.c
--- ../../work/linuxthreads-2.2.3/manager.c	Wed Apr 25 21:50:59 2001
+++ ./manager.c	Thu Jun  7 22:59:29 2001
@@ -54,8 +54,10 @@
    (set to 1 by gdb) */
 volatile int __pthread_threads_debug;
 
+#if 0
 /* Globally enabled events.  */
 volatile td_thr_events_t __pthread_threads_events;
+#endif
 
 /* Pointer to thread descriptor with last event.  */
 volatile pthread_descr __pthread_last_event;
@@ -92,9 +94,9 @@
 
 static int pthread_handle_create(pthread_t *thread, const pthread_attr_t *attr,
                                  void * (*start_routine)(void *), void *arg,
-                                 sigset_t *mask, int father_pid,
+                                 sigset_t *mask, int father_pid/*,
 				 int report_events,
-				 td_thr_events_t *event_maskp);
+				 td_thr_events_t *event_maskp*/);
 static void pthread_handle_free(pthread_t th_id);
 static void pthread_handle_exit(pthread_descr issuing_thread, int exitcode)
      __attribute__ ((noreturn));
@@ -160,9 +162,9 @@
                                 request.req_args.create.fn,
                                 request.req_args.create.arg,
                                 &request.req_args.create.mask,
-                                request.req_thread->p_pid,
+                                request.req_thread->p_pid/*,
 				request.req_thread->p_report_events,
-				&request.req_thread->p_eventbuf.eventmask);
+				&request.req_thread->p_eventbuf.eventmask*/);
         restart(request.req_thread);
         break;
       case REQ_FREE:
@@ -277,6 +279,7 @@
   __pthread_do_exit(outcome, CURRENT_STACK_FRAME);
 }
 
+#if 0
 static int
 __attribute__ ((noreturn))
 pthread_start_thread_event(void *arg)
@@ -297,6 +300,7 @@
   /* Continue with the real function.  */
   pthread_start_thread (arg);
 }
+#endif
 
 static int pthread_allocate_stack(const pthread_attr_t *attr,
                                   pthread_descr default_new_thread,
@@ -476,9 +480,9 @@
 
 static int pthread_handle_create(pthread_t *thread, const pthread_attr_t *attr,
 				 void * (*start_routine)(void *), void *arg,
-				 sigset_t * mask, int father_pid,
+				 sigset_t * mask, int father_pid/*,
 				 int report_events,
-				 td_thr_events_t *event_maskp)
+				 td_thr_events_t *event_maskp*/)
 {
   size_t sseg;
   int pid;
@@ -549,6 +553,12 @@
     }
     new_thread->p_priority =
       new_thread->p_start_args.schedparam.sched_priority;
+  } else {
+    new_thread->p_detached = PTHREAD_CREATE_JOINABLE;
+    new_thread->p_userstack = 0;
+    new_thread->p_start_args.schedpolicy = SCHED_OTHER;
+    new_thread->p_start_args.schedparam.sched_priority = DEFAULT_PRIORITY;
+    new_thread->p_priority = DEFAULT_PRIORITY;
   }
   /* Finish setting up arguments to pthread_start_thread */
   new_thread->p_start_args.start_routine = start_routine;
@@ -563,6 +573,7 @@
   /* Do the cloning.  We have to use two different functions depending
      on whether we are debugging or not.  */
   pid = 0;	/* Note that the thread never can have PID zero.  */
+#if 0
   if (report_events)
     {
       /* See whether the TD_CREATE event bit is set in any of the
@@ -619,6 +630,7 @@
 	    }
 	}
     }
+#endif
   if (pid == 0)
     {
 #ifdef NEED_SEPARATE_REGISTER_STACK
@@ -628,9 +640,18 @@
 		     CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
 		     __pthread_sig_cancel, new_thread);
 #else
+      /* Block all signals during thread creation to avoid new thread
+       * overwriting thread manager stack. 
+       */
+      sigset_t allblock_mask;
+      sigset_t oldmask;
+
+      sigfillset(&allblock_mask);
+      sigprocmask(SIG_SETMASK, &allblock_mask, &oldmask);
       pid = __clone(pthread_start_thread, (void **) new_thread,
 		    CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
 		    __pthread_sig_cancel, new_thread);
+      sigprocmask(SIG_SETMASK, &oldmask, NULL);
 #endif /* !NEED_SEPARATE_REGISTER_STACK */
     }
   /* Check if cloning succeeded */
@@ -738,6 +759,7 @@
       /* Mark thread as exited, and if detached, free its resources */
       __pthread_lock(th->p_lock, NULL);
       th->p_exited = 1;
+#if 0
       /* If we have to signal this event do it now.  */
       if (th->p_report_events)
 	{
@@ -757,6 +779,7 @@
 	      __linuxthreads_reap_event();
 	    }
 	}
+#endif
       detached = th->p_detached;
       __pthread_unlock(th->p_lock);
       if (detached)
@@ -834,10 +857,20 @@
 
 /* Process-wide exit() */
 
+#ifdef LINUXTHREADS_DETECT_UNSAFE_EXIT
+extern int __pthread_exit_requested_bymainthread;
+extern int __pthread_exit_alone;
+#endif
+
 static void pthread_handle_exit(pthread_descr issuing_thread, int exitcode)
 {
   pthread_descr th;
   __pthread_exit_requested = 1;
+#ifdef LINUXTHREADS_DETECT_UNSAFE_EXIT
+  __pthread_exit_alone = 1;
+  if (issuing_thread == __pthread_main_thread)
+    __pthread_exit_requested_bymainthread = 1;
+#endif
   __pthread_exit_code = exitcode;
   /* Send the CANCEL signal to all running threads, including the main
      thread, but excluding the thread from which the exit request originated
@@ -846,6 +875,13 @@
   for (th = issuing_thread->p_nextlive;
        th != issuing_thread;
        th = th->p_nextlive) {
+#ifdef LINUXTHREADS_DETECT_UNSAFE_EXIT
+    /* Cancelled thread might have been in critical region unless terminated */
+    if (th->p_terminated == 0) {
+      __pthread_exit_alone = 0;
+      __pthread_exit_code = 1;
+    }
+#endif
     kill(th->p_pid, __pthread_sig_cancel);
   }
   /* Now, wait for all these threads, so that they don't become zombies
diff -ru ../../work/linuxthreads-2.2.3/ptfork.c ./ptfork.c
--- ../../work/linuxthreads-2.2.3/ptfork.c	Sun Jan  7 04:35:20 2001
+++ ./ptfork.c	Thu Jun  7 22:59:29 2001
@@ -84,7 +84,6 @@
 
   pthread_call_handlers(pthread_atfork_prepare);
   __pthread_once_fork_prepare();
-  __flockfilelist();
 
   pid = __libc_fork();
 
@@ -97,7 +96,6 @@
 
     pthread_mutex_init(&pthread_atfork_lock, NULL);
   } else {
-    __funlockfilelist();
     __pthread_once_fork_parent();
     pthread_call_handlers(pthread_atfork_parent);
 
diff -ru ../../work/linuxthreads-2.2.3/pthread.c ./pthread.c
--- ../../work/linuxthreads-2.2.3/pthread.c	Wed Apr 25 21:50:59 2001
+++ ./pthread.c	Thu Jun  7 22:59:29 2001
@@ -15,17 +15,19 @@
 
 /* Thread creation, initialization, and basic low-level routines */
 
+#include <sys/types.h>
+#include <sys/time.h>
 #include <errno.h>
 #include <stddef.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <signal.h>
 #include <fcntl.h>
 #include <sys/wait.h>
 #include <sys/resource.h>
 #include <sys/sysctl.h>
-#include <shlib-compat.h>
 #include "pthread.h"
 #include "internals.h"
 #include "spinlock.h"
@@ -43,7 +43,7 @@
 #endif
 
 /* These variables are used by the setup code.  */
-extern int _errno;
+extern int _errno __asm__("errno");
 extern int _h_errno;
 
 /* Descriptor of the initial thread */
@@ -60,7 +60,7 @@
   NULL,			      /* pthread_descr p_nextlock */
   PTHREAD_THREADS_MAX,        /* pthread_t p_tid */
   0,                          /* int p_pid */
-  0,                          /* int p_priority */
+  DEFAULT_PRIORITY,           /* int p_priority */
   &__pthread_handles[0].h_lock, /* struct _pthread_fastlock * p_lock */
   0,                          /* int p_signal */
   NULL,                       /* sigjmp_buf * p_signal_buf */
@@ -84,13 +84,18 @@
   PTHREAD_START_ARGS_INITIALIZER(NULL),
                               /* struct pthread_start_args p_start_args */
   {NULL},                     /* void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE] */
+  {NULL, NULL},               /* TAILQ_ENTRY(_pthread_descr_struct) qe */
+  {NULL},                     /* char timebuf[26] */
+  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL}, /* struct tm local_tm */
   {NULL},                     /* void * p_libc_specific[_LIBC_TSD_KEY_N] */
   1,                          /* int p_userstack */
   NULL,                       /* void * p_guardaddr */
   0,                          /* size_t p_guardsize */
   0,                          /* Always index 0 */
+#if 0
   0,                          /* int p_report_events */
   {{{0, }}, 0, NULL},         /* td_eventbuf_t p_eventbuf */
+#endif
   __ATOMIC_INITIALIZER,       /* struct pthread_atomic p_resume_count */
   0,                          /* char p_woken_by_cancel */
   0,                          /* char p_condvar_avail */
@@ -117,7 +122,7 @@
   NULL,			      /* pthread_descr p_nextlock */
   0,                          /* int p_tid */
   0,                          /* int p_pid */
-  0,                          /* int p_priority */
+  DEFAULT_PRIORITY,           /* int p_priority */
   &__pthread_handles[1].h_lock, /* struct _pthread_fastlock * p_lock */
   0,                          /* int p_signal */
   NULL,                       /* sigjmp_buf * p_signal_buf */
@@ -141,13 +146,18 @@
   PTHREAD_START_ARGS_INITIALIZER(__pthread_manager),
                               /* struct pthread_start_args p_start_args */
   {NULL},                     /* void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE] */
+  {NULL, NULL},               /* TAILQ_ENTRY(_pthread_descr_struct) qe */
+  {NULL},                     /* char timebuf[26] */
+  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL}, /* struct tm local_tm */
   {NULL},                     /* void * p_libc_specific[_LIBC_TSD_KEY_N] */
   0,                          /* int p_userstack */
   NULL,                       /* void * p_guardaddr */
   0,                          /* size_t p_guardsize */
   1,                          /* Always index 1 */
+#if 0
   0,                          /* int p_report_events */
   {{{0, }}, 0, NULL},         /* td_eventbuf_t p_eventbuf */
+#endif
   __ATOMIC_INITIALIZER,       /* struct pthread_atomic p_resume_count */
   0,                          /* char p_woken_by_cancel */
   0,                          /* char p_condvar_avail */
@@ -185,6 +195,10 @@
 /* For process-wide exit() */
 
 int __pthread_exit_requested;
+#ifdef LINUXTHREADS_DETECT_UNSAFE_EXIT
+int __pthread_exit_requested_bymainthread = 0;
+int __pthread_exit_alone = 1;
+#endif
 int __pthread_exit_code;
 
 /* Maximum stack size.  */
@@ -216,11 +228,7 @@
 
 /* Forward declarations */
 
-static void pthread_onexit_process(int retcode, void *arg);
-#ifndef HAVE_Z_NODELETE
-static void pthread_atexit_process(void *arg, int retcode);
-static void pthread_atexit_retcode(void *arg, int retcode);
-#endif
+static void pthread_onexit_process(void);
 static void pthread_handle_sigcancel(int sig);
 static void pthread_handle_sigrestart(int sig);
 static void pthread_handle_sigdebug(int sig);
@@ -238,8 +246,12 @@
 #ifndef __SIGRTMIN
 static int current_rtmin = -1;
 static int current_rtmax = -1;
-int __pthread_sig_restart = SIGUSR1;
-int __pthread_sig_cancel = SIGUSR2;
+#ifdef LINUXTHREADS_ALT_RESTARTSIG
+int __pthread_sig_restart = LINUXTHREADS_ALT_RESTARTSIG;
+#else
+int __pthread_sig_restart = SIGUSR2;
+#endif
+int __pthread_sig_cancel = SIGUSR1;
 int __pthread_sig_debug;
 #else
 static int current_rtmin;
@@ -250,8 +258,8 @@
 int __pthread_sig_cancel = __SIGRTMIN + 1;
 int __pthread_sig_debug = __SIGRTMIN + 2;
 #else
-int __pthread_sig_restart = SIGUSR1;
-int __pthread_sig_cancel = SIGUSR2;
+int __pthread_sig_restart = SIGUSR2;
+int __pthread_sig_cancel = SIGUSR1;
 int __pthread_sig_debug;
 #endif
 
@@ -348,26 +356,17 @@
 static int
 is_smp_system (void)
 {
-  static const int sysctl_args[] = { CTL_KERN, KERN_VERSION };
-  char buf[512];
+  static const int sysctl_args[] = { CTL_HW, HW_NCPU };
+  int buf;
   size_t reslen = sizeof (buf);
 
-  /* Try reading the number using `sysctl' first.  */
-  if (__sysctl ((int *) sysctl_args,
-		sizeof (sysctl_args) / sizeof (sysctl_args[0]),
-		buf, &reslen, NULL, 0) < 0)
-    {
-      /* This was not successful.  Now try reading the /proc filesystem.  */
-      int fd = __open ("/proc/sys/kernel/version", O_RDONLY);
-      if (__builtin_expect (fd, 0) == -1
-	  || (reslen = __read (fd, buf, sizeof (buf))) <= 0)
-	/* This also didn't work.  We give up and say it's a UP machine.  */
-	buf[0] = '\0';
-
-      __close (fd);
-    }
-
-  return strstr (buf, "SMP") != NULL;
+  buf = 1;
+  if (sysctl ((int *) sysctl_args,
+	      sizeof (sysctl_args) / sizeof (sysctl_args[0]),
+	      &buf, &reslen, NULL, 0) < 0)
+	  return 0;
+  
+  return buf > 1;
 }
 
 
@@ -448,13 +447,7 @@
   /* Register an exit function to kill all other threads. */
   /* Do it early so that user-registered atexit functions are called
      before pthread_*exit_process. */
-#ifndef HAVE_Z_NODELETE
-  if (__builtin_expect (&__dso_handle != NULL, 1))
-    __cxa_atexit ((void (*) (void *)) pthread_atexit_process, NULL,
-		  __dso_handle);
-  else
-#endif
-    __on_exit (pthread_onexit_process, NULL);
+  atexit(pthread_onexit_process);
   /* How many processors.  */
   __pthread_smp_kernel = is_smp_system ();
 }
@@ -502,12 +495,6 @@
   int pid;
   struct pthread_request request;
 
-#ifndef HAVE_Z_NODELETE
-  if (__builtin_expect (&__dso_handle != NULL, 1))
-    __cxa_atexit ((void (*) (void *)) pthread_atexit_retcode, NULL,
-		  __dso_handle);
-#endif
-
   if (__pthread_max_stacksize == 0)
     __pthread_init_max_stacksize ();
   /* If basic initialization not done yet (e.g. we're called from a
@@ -525,6 +512,7 @@
   }
   /* Start the thread manager */
   pid = 0;
+#if 0
   if (__builtin_expect (__pthread_initial_thread.p_report_events, 0))
     {
       /* It's a bit more complicated.  We have to report the creation of
@@ -572,17 +560,20 @@
 	  __pthread_unlock(__pthread_manager_thread.p_lock);
 	}
     }
+#endif
 
   if (__builtin_expect (pid, 0) == 0)
     {
 #ifdef NEED_SEPARATE_REGISTER_STACK
       pid = __clone2(__pthread_manager, (void **) __pthread_manager_thread_bos,
 		     THREAD_MANAGER_STACK_SIZE,
-		     CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND,
+		     CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
+		     __pthread_sig_cancel,
 		     (void *)(long)manager_pipe[0]);
 #else
       pid = __clone(__pthread_manager, (void **) __pthread_manager_thread_tos,
-		    CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND,
+		    CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
+		    __pthread_sig_cancel,
 		    (void *)(long)manager_pipe[0]);
 #endif
     }
@@ -715,7 +706,7 @@
     __pthread_unlock(&handle->h_lock);
     return errno;
   }
-  th->p_priority = policy == SCHED_OTHER ? 0 : param->sched_priority;
+  th->p_priority = param->sched_priority;
   __pthread_unlock(&handle->h_lock);
   if (__pthread_manager_request >= 0)
     __pthread_manager_adjust_prio(th->p_priority);
@@ -751,7 +742,7 @@
 
 /* Process-wide exit() request */
 
-static void pthread_onexit_process(int retcode, void *arg)
+static void pthread_onexit_process(void)
 {
   if (__builtin_expect (__pthread_manager_request, 0) >= 0) {
     struct pthread_request request;
@@ -759,7 +750,7 @@
 
     request.req_thread = self;
     request.req_kind = REQ_PROCESS_EXIT;
-    request.req_args.exit.code = retcode;
+    request.req_args.exit.code = 0;
     __libc_write(__pthread_manager_request,
 		 (char *) &request, sizeof(request));
     suspend(self);
@@ -768,25 +759,34 @@
     if (self == __pthread_main_thread)
       {
 	waitpid(__pthread_manager_thread.p_pid, NULL, __WCLONE);
+#ifdef LINUXTHREADS_DETECT_UNSAFE_EXIT
+	/*
+	 * If other threads have been canceled then proper cleanup
+	 * cannot be performed since a canceled thread might have
+	 * been inside a critical region of code with a spinlock
+	 * held, a system mutex held, or a mutex partially held.
+	 */
+	if (__pthread_exit_alone == 0)
+	  _exit(1);
+#endif
 	free (__pthread_manager_thread_bos);
 	__pthread_manager_thread_bos = __pthread_manager_thread_tos = NULL;
       }
+#ifdef LINUXTHREADS_DETECT_UNSAFE_EXIT
+    /*
+     * If other threads have been canceled then proper cleanup
+     * cannot be performed since a canceled thread might have
+     * been inside a critical region of code with a spinlock
+     * held, a system mutex held, or a mutex partially held.
+     */
+    if (__pthread_exit_alone == 0) {
+      __pthread_exit_code = 1;
+      _exit(1);
+    }
+#endif
   }
 }
 
-#ifndef HAVE_Z_NODELETE
-static int __pthread_atexit_retcode;
-
-static void pthread_atexit_process(void *arg, int retcode)
-{
-  pthread_onexit_process (retcode ?: __pthread_atexit_retcode, arg);
-}
-
-static void pthread_atexit_retcode(void *arg, int retcode)
-{
-  __pthread_atexit_retcode = retcode;
-}
-#endif
 
 /* The handler for the RESTART signal just records the signal received
    in the thread descriptor, and optionally performs a siglongjmp
@@ -818,6 +812,11 @@
   if (__builtin_expect (__pthread_exit_requested, 0)) {
     /* Main thread should accumulate times for thread manager and its
        children, so that timings for main thread account for all threads. */
+#ifdef LINUXTHREADS_DETECT_UNSAFE_EXIT
+    if (self == __pthread_main_thread &&
+	__pthread_exit_requested_bymainthread != 0)
+	    return;
+#endif
     if (self == __pthread_main_thread)
       waitpid(__pthread_manager_thread.p_pid, NULL, __WCLONE);
     _exit(__pthread_exit_code);
@@ -894,7 +891,7 @@
 {
   struct sigaction sa;
   /* Terminate all other threads and thread manager */
-  pthread_onexit_process(0, NULL);
+  pthread_onexit_process();
   /* Make current thread the main thread in case the calling thread
      changes its mind, does not exec(), and creates new threads instead. */
   __pthread_reset_main_thread();
@@ -967,7 +964,7 @@
 __pthread_timedsuspend_old(pthread_descr self, const struct timespec *abstime)
 {
   sigset_t unblock, initial_mask;
-  int was_signalled = 0;
+  int was_signalled = 1;
   sigjmp_buf jmpbuf;
 
   if (atomic_decrement(&self->p_resume_count) == 0) {
@@ -1131,3 +1128,17 @@
 static const int *const __pthread_require_wrappers =
   &__pthread_provide_wrappers;
 #endif
+
+/* Force our version of uthreads stub functions to be linked in */
+extern int _pthread_mutex_init(pthread_mutex_t **mutex, const pthread_mutexattr_t *mattr);
+static int (*unusedref)(pthread_mutex_t **mutex, const pthread_mutexattr_t *mattr) __attribute__ ((unused)) = _pthread_mutex_init;
+
+extern void _flockfile(FILE *fp);
+static void (*unusedref2)(FILE *fp) __attribute__ ((unused)) = _flockfile;
+
+extern int *__error(void);
+static int *(*unusedref3)(void) __attribute__ ((unused)) = __error;
+
+static
+struct tm *(*unusedref4)(const time_t *) __attribute__ ((unused)) = localtime;
+
diff -ru ../../work/linuxthreads-2.2.3/ptlongjmp.c ./ptlongjmp.c
--- ../../work/linuxthreads-2.2.3/ptlongjmp.c	Thu Apr 12 21:02:02 2001
+++ ./ptlongjmp.c	Thu Jun  7 22:59:29 2001
@@ -18,14 +18,15 @@
 #include <setjmp.h>
 #include "pthread.h"
 #include "internals.h"
-#include <stackinfo.h>
 
+#if 0
 /* These functions are not declared anywhere since they shouldn't be
    used at another place but here.  */
 extern void __libc_siglongjmp (sigjmp_buf env, int val)
      __attribute__ ((noreturn));
 extern void __libc_longjmp (sigjmp_buf env, int val)
      __attribute__ ((noreturn));
+#endif
 
 
 static void pthread_cleanup_upto(__jmp_buf target)
@@ -63,12 +64,12 @@
 
 void siglongjmp(sigjmp_buf env, int val)
 {
-  pthread_cleanup_upto(env->__jmpbuf);
+  pthread_cleanup_upto((void *) env);
   __libc_siglongjmp(env, val);
 }
 
 void longjmp(jmp_buf env, int val)
 {
-  pthread_cleanup_upto(env->__jmpbuf);
+  pthread_cleanup_upto((void *) env);
   __libc_longjmp(env, val);
 }
diff -ru ../../work/linuxthreads-2.2.3/restart.h ./restart.h
--- ../../work/linuxthreads-2.2.3/restart.h	Mon Apr 17 17:18:55 2000
+++ ./restart.h	Thu Jun  7 22:59:29 2001
@@ -13,7 +13,6 @@
 /* GNU Library General Public License for more details.                 */
 
 #include <signal.h>
-#include <kernel-features.h>
 
 /* Primitives for controlling thread execution */
 
diff -ru ../../work/linuxthreads-2.2.3/semaphore.c ./semaphore.c
--- ../../work/linuxthreads-2.2.3/semaphore.c	Thu Apr 12 21:02:02 2001
+++ ./semaphore.c	Thu Jun  7 22:59:29 2001
@@ -21,7 +21,6 @@
 #include "spinlock.h"
 #include "restart.h"
 #include "queue.h"
-#include <shlib-compat.h>
 
 int __new_sem_init(sem_t *sem, int pshared, unsigned int value)
 {
diff -ru ../../work/linuxthreads-2.2.3/semaphore.h ./semaphore.h
--- ../../work/linuxthreads-2.2.3/semaphore.h	Fri Feb  9 18:04:08 2001
+++ ./semaphore.h	Thu Jun  7 22:59:29 2001
@@ -15,7 +15,6 @@
 #ifndef _SEMAPHORE_H
 #define _SEMAPHORE_H    1
 
-#include <features.h>
 #include <sys/types.h>
 #ifdef __USE_XOPEN2K
 # define __need_timespec
diff -ru ../../work/linuxthreads-2.2.3/signals.c ./signals.c
--- ../../work/linuxthreads-2.2.3/signals.c	Tue Apr 17 15:17:16 2001
+++ ./signals.c	Thu Jun  7 22:59:29 2001
@@ -20,7 +20,6 @@
 #include "internals.h"
 #include "spinlock.h"
 #include <ucontext.h>
-#include <sigcontextinfo.h>
 
 int pthread_sigmask(int how, const sigset_t * newmask, sigset_t * oldmask)
 {
@@ -69,15 +68,15 @@
 }
 
 /* User-provided signal handlers */
-typedef void (*arch_sighandler_t) (int, SIGCONTEXT);
+typedef void (*arch_sighandler_t) (int, int, SIGCONTEXT);
 static union
 {
   arch_sighandler_t old;
-  void (*rt) (int, struct siginfo *, struct ucontext *);
+  void (*rt) (int, siginfo_t *, ucontext_t *);
 } sighandler[NSIG];
 
 /* The wrapper around user-provided signal handlers */
-static void pthread_sighandler(int signo, SIGCONTEXT ctx)
+static void pthread_sighandler(int signo, int code, SIGCONTEXT ctx)
 {
   pthread_descr self;
   char * in_sighandler;
@@ -94,14 +93,14 @@
   in_sighandler = THREAD_GETMEM(self, p_in_sighandler);
   if (in_sighandler == NULL)
     THREAD_SETMEM(self, p_in_sighandler, CURRENT_STACK_FRAME);
-  CALL_SIGHANDLER(sighandler[signo].old, signo, ctx);
+  sighandler[signo].old(signo, code, ctx);
   if (in_sighandler == NULL)
     THREAD_SETMEM(self, p_in_sighandler, NULL);
 }
 
 /* The same, this time for real-time signals.  */
-static void pthread_sighandler_rt(int signo, struct siginfo *si,
-				  struct ucontext *uc)
+static void pthread_sighandler_rt(int signo, siginfo_t *si,
+				  ucontext_t *uc)
 {
   pthread_descr self;
   char * in_sighandler;
@@ -130,6 +129,7 @@
 {
   struct sigaction newact;
   struct sigaction *newactp;
+  arch_sighandler_t user_oact;
 
   if (sig == __pthread_sig_restart ||
       sig == __pthread_sig_cancel ||
@@ -145,20 +145,34 @@
 	  && sig > 0 && sig < NSIG)
 	{
 	  if (act->sa_flags & SA_SIGINFO)
-	    newact.sa_handler = (__sighandler_t) pthread_sighandler_rt;
+	    newact.sa_handler = (__sighandler_t *) pthread_sighandler_rt;
 	  else
-	    newact.sa_handler = (__sighandler_t) pthread_sighandler;
+	    newact.sa_handler = (__sighandler_t *) pthread_sighandler;
 	}
       newactp = &newact;
     }
   else
     newactp = NULL;
+  if (sig > 0 && sig < NSIG)
+    {
+      user_oact = sighandler[sig].old;
+      if (act &&
+	  ((__sighandler_t *) user_oact == SIG_IGN ||
+	   (__sighandler_t *) user_oact == SIG_DFL))
+	/* For the assignment is does not matter whether it's a normal
+	   or real-time signal.  */
+	sighandler[sig].old = (arch_sighandler_t) act->sa_handler;
+    }
   if (__libc_sigaction(sig, newactp, oact) == -1)
-    return -1;
+    {
+      if (act && sig > 0 && sig < NSIG)
+	sighandler[sig].old = user_oact;
+      return -1;
+    }
   if (sig > 0 && sig < NSIG)
     {
       if (oact != NULL)
-	oact->sa_handler = (__sighandler_t) sighandler[sig].old;
+	oact->sa_handler = (__sighandler_t *) user_oact;
       if (act)
 	/* For the assignment is does not matter whether it's a normal
 	   or real-time signal.  */
diff -ru ../../work/linuxthreads-2.2.3/spinlock.c ./spinlock.c
--- ../../work/linuxthreads-2.2.3/spinlock.c	Tue Mar 27 04:52:56 2001
+++ ./spinlock.c	Thu Jun  7 22:59:29 2001
@@ -24,10 +24,6 @@
 #include "spinlock.h"
 #include "restart.h"
 
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-static void __pthread_acquire(int * spinlock);
-#endif
-
 
 /* The status field of a spinlock is a pointer whose least significant
    bit is a locked flag.
@@ -701,7 +697,7 @@
    - When nanosleep() returns, we try again, doing MAX_SPIN_COUNT
      sched_yield(), then sleeping again if needed. */
 
-static void __pthread_acquire(int * spinlock)
+void __pthread_acquire(int * spinlock)
 {
   int cnt = 0;
   struct timespec tm;
diff -ru ../../work/linuxthreads-2.2.3/spinlock.h ./spinlock.h
--- ../../work/linuxthreads-2.2.3/spinlock.h	Fri Feb  9 18:04:08 2001
+++ ./spinlock.h	Thu Jun  7 22:59:29 2001
@@ -180,6 +180,8 @@
 #endif
 }
 
+void __pthread_acquire(int * spinlock);
+
 /* Operations on pthread_atomic, which is defined in internals.h */
 
 static inline long atomic_increment(struct pthread_atomic *pa)
diff -ru ../../work/linuxthreads-2.2.3/sysdeps/pthread/bits/pthreadtypes.h ./sysdeps/pthread/bits/pthreadtypes.h
--- ../../work/linuxthreads-2.2.3/sysdeps/pthread/bits/pthreadtypes.h	Fri Feb  9 18:04:09 2001
+++ ./sysdeps/pthread/bits/pthreadtypes.h	Thu Jun  7 22:59:29 2001
@@ -20,7 +20,6 @@
 #define _BITS_PTHREADTYPES_H	1
 
 #define __need_schedparam
-#include <bits/sched.h>
 
 /* Fast locks (not abstract because mutexes and conditions aren't abstract). */
 struct _pthread_fastlock
@@ -42,7 +41,7 @@
 {
   int __detachstate;
   int __schedpolicy;
-  struct __sched_param __schedparam;
+  struct sched_param __schedparam;
   int __inheritsched;
   int __scope;
   size_t __guardsize;
diff -ru ../../work/linuxthreads-2.2.3/sysdeps/pthread/pthread.h ./sysdeps/pthread/pthread.h
--- ../../work/linuxthreads-2.2.3/sysdeps/pthread/pthread.h	Tue Mar 27 04:52:56 2001
+++ ./sysdeps/pthread/pthread.h	Thu Jun  7 22:59:29 2001
@@ -15,7 +15,9 @@
 #ifndef _PTHREAD_H
 #define _PTHREAD_H	1
 
-#include <features.h>
+#ifndef __THROW
+#define __THROW
+#endif
 
 #include <sched.h>
 #include <time.h>
@@ -160,7 +162,7 @@
 /* Create a thread with given attributes ATTR (or default attributes
    if ATTR is NULL), and call function START_ROUTINE with given
    arguments ARG.  */
-extern int pthread_create (pthread_t *__restrict __thread,
+extern int pthread_create (pthread_t *__restrict __xthread,
 			   __const pthread_attr_t *__restrict __attr,
 			   void *(*__start_routine) (void *),
 			   void *__restrict __arg) __THROW;
@@ -588,7 +590,7 @@
 extern int pthread_setcanceltype (int __type, int *__oldtype) __THROW;
 
 /* Cancel THREAD immediately or at the next possibility.  */
-extern int pthread_cancel (pthread_t __thread) __THROW;
+extern int pthread_cancel (pthread_t __xthread) __THROW;
 
 /* Test for pending cancellation for the current thread and terminate
    the thread as per pthread_exit(PTHREAD_CANCELED) if it has been
diff -ru ../../work/linuxthreads-2.2.3/sysdeps/unix/sysv/linux/bits/local_lim.h ./sysdeps/unix/sysv/linux/bits/local_lim.h
--- ../../work/linuxthreads-2.2.3/sysdeps/unix/sysv/linux/bits/local_lim.h	Fri Jun  9 19:17:35 2000
+++ ./sysdeps/unix/sysv/linux/bits/local_lim.h	Thu Jun  7 22:59:29 2001
@@ -33,7 +33,7 @@
 #endif
 
 /* The kernel sources contain a file with all the needed information.  */
-#include <linux/limits.h>
+#include <limits.h>
 
 /* Have to remove NR_OPEN?  */
 #ifdef __undef_NR_OPEN
@@ -64,7 +64,9 @@
 /* The number of threads per process.  */
 #define _POSIX_THREAD_THREADS_MAX	64
 /* This is the value this implementation supports.  */
+#ifndef PTHREAD_THREADS_MAX
 #define PTHREAD_THREADS_MAX	1024
+#endif
 
 /* Maximum amount by which a process can descrease its asynchronous I/O
    priority level.  */
diff -ru ../../work/linuxthreads-2.2.3/sysdeps/unix/sysv/linux/bits/sigthread.h ./sysdeps/unix/sysv/linux/bits/sigthread.h
--- ../../work/linuxthreads-2.2.3/sysdeps/unix/sysv/linux/bits/sigthread.h	Thu Aug 31 21:45:04 2000
+++ ./sysdeps/unix/sysv/linux/bits/sigthread.h	Thu Jun  7 22:59:29 2001
@@ -29,10 +29,10 @@
 /* Modify the signal mask for the calling thread.  The arguments have
    the same meaning as for sigprocmask(2). */
 extern int pthread_sigmask (int __how,
-			    __const __sigset_t *__restrict __newmask,
-			    __sigset_t *__restrict __oldmask)__THROW;
+			    __const sigset_t *__restrict __newmask,
+			    sigset_t *__restrict __oldmask)__THROW;
 
 /* Send signal SIGNO to the given thread. */
-extern int pthread_kill (pthread_t __thread, int __signo) __THROW;
+extern int pthread_kill (pthread_t __xthread, int __signo) __THROW;
 
 #endif	/* bits/sigthread.h */
diff -ru ../../work/linuxthreads-2.2.3/wrapsyscall.c ./wrapsyscall.c
--- ../../work/linuxthreads-2.2.3/wrapsyscall.c	Wed Apr 25 21:50:59 2001
+++ ./wrapsyscall.c	Thu Jun  7 22:59:29 2001
@@ -18,6 +18,8 @@
    write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.  */
 
+#include <sys/types.h>
+#include <sys/time.h>
 #include <fcntl.h>
 #include <sys/mman.h>
 #include <pthread.h>
@@ -29,6 +29,7 @@
 #include <sys/resource.h>
 #include <sys/wait.h>
 #include <sys/socket.h>
+#include "internals.h"
 
 
 #ifndef SHARED
@@ -85,15 +86,19 @@
 CANCELABLE_SYSCALL (int, fsync, (int fd), (fd))
 
 
+#if 0
 /* lseek(2).  */
 CANCELABLE_SYSCALL (off_t, lseek, (int fd, off_t offset, int whence),
 		    (fd, offset, whence))
 strong_alias (lseek, __lseek)
+#endif
 
 
+#if 0
 /* lseek64(2).  */
 CANCELABLE_SYSCALL (off64_t, lseek64, (int fd, off64_t offset, int whence),
 		    (fd, offset, whence))
+#endif
 
 
 /* msync(2).  */
@@ -109,44 +114,54 @@
 
 /* open(2).  */
 CANCELABLE_SYSCALL_VA (int, open, (const char *pathname, int flags, ...),
-		       (pathname, flags, va_arg (ap, mode_t)), flags)
+		       (pathname, flags, va_arg (ap, int)), flags)
 strong_alias (open, __open)
 
 
+#if 0
 /* open64(3).  */
 CANCELABLE_SYSCALL_VA (int, open64, (const char *pathname, int flags, ...),
 		       (pathname, flags, va_arg (ap, mode_t)), flags)
 strong_alias (open64, __open64)
+#endif
 
 
 /* pause(2).  */
 CANCELABLE_SYSCALL (int, pause, (void), ())
 
 
+#if 0
 /* pread(3).  */
 CANCELABLE_SYSCALL (ssize_t, pread, (int fd, void *buf, size_t count,
 				     off_t offset),
 		    (fd, buf, count, offset))
+#endif
 
 
+#if 0
 /* pread64(3).  */
 CANCELABLE_SYSCALL (ssize_t, pread64, (int fd, void *buf, size_t count,
 				       off64_t offset),
 		    (fd, buf, count, offset))
 strong_alias (pread64, __pread64)
+#endif
 
 
+#if 0
 /* pwrite(3).  */
 CANCELABLE_SYSCALL (ssize_t, pwrite, (int fd, const void *buf, size_t n,
 				      off_t offset),
 		    (fd, buf, n, offset))
+#endif
 
 
+#if 0
 /* pwrite64(3).  */
 CANCELABLE_SYSCALL (ssize_t, pwrite64, (int fd, const void *buf, size_t n,
 					off64_t offset),
 		    (fd, buf, n, offset))
 strong_alias (pwrite64, __pwrite64)
+#endif
 
 
 /* read(2).  */
@@ -165,7 +180,9 @@
 
 /* wait(2).  */
 CANCELABLE_SYSCALL (__pid_t, wait, (__WAIT_STATUS_DEFN stat_loc), (stat_loc))
+#if 0
 strong_alias (wait, __wait)
+#endif
 
 
 /* waitpid(2).  */
@@ -194,9 +211,11 @@
 		    (fd, addr, len))
 strong_alias (connect, __connect)
 
+#if 0
 /* recv(2).  */
 CANCELABLE_SYSCALL (ssize_t, recv, (int fd, __ptr_t buf, size_t n, int flags),
 		    (fd, buf, n, flags))
+#endif
 
 /* recvfrom(2).  */
 CANCELABLE_SYSCALL (ssize_t, recvfrom, (int fd, __ptr_t buf, size_t n, int flags,
@@ -207,11 +226,13 @@
 CANCELABLE_SYSCALL (ssize_t, recvmsg, (int fd, struct msghdr *message, int flags),
 		    (fd, message, flags))
 
+#if 0
 /* send(2).  */
 CANCELABLE_SYSCALL (ssize_t, send, (int fd, const __ptr_t buf, size_t n,
 				    int flags),
 		    (fd, buf, n, flags))
 strong_alias (send, __send)
+#endif
 
 /* sendmsg(2).  */
 CANCELABLE_SYSCALL (ssize_t, sendmsg, (int fd, const struct msghdr *message,
