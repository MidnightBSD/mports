diff --git a/widget/src/gtk2/Makefile.in b/widget/src/gtk2/Makefile.in
index 0df722e..39654b1 100644
--- widget/src/gtk2/Makefile.in
+++ widget/src/gtk2/Makefile.in
@@ -78,7 +78,6 @@ endif
 
 CSRCS		= \
 		mozcontainer.c \
-		mozdrawingarea.c \
 		keysym2ucs.c \
 		nsPrintdGTK.c \
 		$(NULL)
@@ -152,7 +151,6 @@ endif
 EXPORTS		= \
                 nsGTKToolkit.h \
 		nsIImageToPixbuf.h \
-		mozdrawingarea.h \
 		mozcontainer.h \
 		$(NULL)
 
diff --git a/widget/src/gtk2/mozcontainer.c b/widget/src/gtk2/mozcontainer.c
index 71b425f..89731a3 100644
--- widget/src/gtk2/mozcontainer.c
+++ widget/src/gtk2/mozcontainer.c
@@ -294,8 +294,15 @@ moz_container_realize (GtkWidget *widget)
 
     /* create the shell window */
 
-    attributes.event_mask = gtk_widget_get_events (widget);
-    attributes.event_mask |=  (GDK_EXPOSURE_MASK | GDK_STRUCTURE_MASK);
+    attributes.event_mask = (gtk_widget_get_events (widget) |
+                             GDK_EXPOSURE_MASK | GDK_STRUCTURE_MASK |
+                             GDK_VISIBILITY_NOTIFY_MASK |
+                             GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK |
+                             GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
+#ifdef HAVE_GTK_MOTION_HINTS
+                             GDK_POINTER_MOTION_HINT_MASK |
+#endif
+                             GDK_POINTER_MOTION_MASK);
     attributes.x = widget->allocation.x;
     attributes.y = widget->allocation.y;
     attributes.width = widget->allocation.width;
diff --git a/widget/src/gtk2/mozcontainer.h b/widget/src/gtk2/mozcontainer.h
index 8f1d2f0..51850ea 100644
--- widget/src/gtk2/mozcontainer.h
+++ widget/src/gtk2/mozcontainer.h
@@ -40,6 +40,7 @@
 #define __MOZ_CONTAINER_H__
 
 #include <gtk/gtkcontainer.h>
+#include <gtk/gtkversion.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -83,6 +84,11 @@ extern "C" {
 #define IS_MOZ_CONTAINER_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), MOZ_CONTAINER_TYPE))
 #define MOZ_CONAINTER_GET_CLASS(obj)  (GTK_CHECK_GET_CLASS ((obj), MOZ_CONTAINER_TYPE, MozContainerClass))
 
+#if (GTK_CHECK_VERSION(2, 12, 0) || \
+    (GTK_CHECK_VERSION(2, 10, 0) && defined(MOZ_PLATFORM_HILDON)))
+#define HAVE_GTK_MOTION_HINTS
+#endif
+
 typedef struct _MozContainer      MozContainer;
 typedef struct _MozContainerClass MozContainerClass;
 
diff --git a/widget/src/gtk2/mozdrawingarea.c b/widget/src/gtk2/mozdrawingarea.c
deleted file mode 100644
index 5b7cf99..0000000
--- widget/src/gtk2/mozdrawingarea.c
+++ /dev/null
@@ -1,241 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
-/* vim:expandtab:shiftwidth=4:tabstop=4:
- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is Christopher Blizzard
- * <blizzard@mozilla.org>.  Portions created by the Initial Developer
- * are Copyright (C) 2001 the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozdrawingarea.h"
-
-/* init methods */
-static void moz_drawingarea_class_init          (MozDrawingareaClass *klass);
-static void moz_drawingarea_init                (MozDrawingarea *drawingarea);
-
-/* static methods */
-static void moz_drawingarea_create_windows      (MozDrawingarea *drawingarea,
-                                                 GdkWindow *parent,
-                                                 GtkWidget *widget,
-                                                 GdkVisual *visual);
-
-static void moz_drawingarea_finalize            (GObject *object);
-
-static GObjectClass *parent_class = NULL;
-
-GtkType
-moz_drawingarea_get_type(void)
-{
-    static GtkType moz_drawingarea_type = 0;
-
-   if (!moz_drawingarea_type) {
-       static GTypeInfo moz_drawingarea_info = {
-           sizeof(MozDrawingareaClass), /* class size */
-           NULL, /* base_init */
-           NULL, /* base_finalize */
-           (GClassInitFunc) moz_drawingarea_class_init, /* class_init */
-           NULL, /* class_destroy */
-           NULL, /* class_data */
-           sizeof(MozDrawingarea), /* instance_size */
-           0, /* n_preallocs */
-           (GInstanceInitFunc) moz_drawingarea_init, /* instance_init */
-           NULL, /* value_table */
-       };
-       moz_drawingarea_type =
-           g_type_register_static (G_TYPE_OBJECT,
-                                   "MozDrawingarea",
-                                   &moz_drawingarea_info, 0);
-   }
-
-   return moz_drawingarea_type;
-}
-
-MozDrawingarea *
-moz_drawingarea_new (MozDrawingarea *parent, MozContainer *widget_parent,
-                     GdkVisual *visual)
-{
-    MozDrawingarea *drawingarea;
-
-    drawingarea = g_object_new(MOZ_DRAWINGAREA_TYPE, NULL);
-
-    if (!parent)
-        moz_drawingarea_create_windows(drawingarea,
-                                       GTK_WIDGET(widget_parent)->window,
-                                       GTK_WIDGET(widget_parent),
-                                       visual);
-    else
-        moz_drawingarea_create_windows(drawingarea,
-                                       parent->inner_window, 
-                                       GTK_WIDGET(widget_parent),
-                                       visual);
-
-    return drawingarea;
-}
-
-void
-moz_drawingarea_class_init (MozDrawingareaClass *klass)
-{
-    GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-    object_class->finalize = moz_drawingarea_finalize;
-
-    parent_class = g_type_class_peek_parent(klass);
-}
-
-void
-moz_drawingarea_init (MozDrawingarea *drawingarea)
-{
-
-}
-
-void
-moz_drawingarea_reparent (MozDrawingarea *drawingarea, GdkWindow *aNewParent)
-{
-    gdk_window_reparent(drawingarea->clip_window,
-                        aNewParent, 0, 0);
-}
-
-void
-moz_drawingarea_create_windows (MozDrawingarea *drawingarea, GdkWindow *parent,
-                                GtkWidget *widget, GdkVisual *visual)
-{
-    GdkWindowAttr attributes;
-    gint          attributes_mask = 0;
-
-    /* create the clipping window */
-    attributes.event_mask = 0;
-    attributes.x = 0;
-    attributes.y = 0;
-    attributes.width = 1;
-    attributes.height = 1;
-    attributes.wclass = GDK_INPUT_OUTPUT;
-    attributes.window_type = GDK_WINDOW_CHILD;
-    if (!visual) {
-        attributes.visual = gtk_widget_get_visual (widget);
-        attributes.colormap = gtk_widget_get_colormap (widget);
-    } else {
-        attributes.visual = visual;
-        attributes.colormap = gdk_colormap_new(visual, 0);
-    }
-
-    attributes_mask |= GDK_WA_VISUAL | GDK_WA_COLORMAP |
-        GDK_WA_X | GDK_WA_Y;
-
-    drawingarea->clip_window = gdk_window_new (parent, &attributes,
-                                               attributes_mask);
-    gdk_window_set_user_data(drawingarea->clip_window, widget);
-
-    /* set the default pixmap to None so that you don't end up with the
-       gtk default which is BlackPixel. */
-    gdk_window_set_back_pixmap(drawingarea->clip_window, NULL, FALSE);
-
-    attributes.event_mask = (GDK_EXPOSURE_MASK | GDK_STRUCTURE_MASK |
-                             GDK_VISIBILITY_NOTIFY_MASK |
-                             GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK |
-                             GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
-#ifdef HAVE_GTK_MOTION_HINTS
-                             GDK_POINTER_MOTION_HINT_MASK |
-#endif
-                             GDK_POINTER_MOTION_MASK);
-    /* create the inner window */
-    drawingarea->inner_window = gdk_window_new (drawingarea->clip_window,
-                                                &attributes, attributes_mask);
-    gdk_window_set_user_data(drawingarea->inner_window, widget);
-
-    /* set the default pixmap to None so that you don't end up with the
-       gtk default which is BlackPixel. */
-    gdk_window_set_back_pixmap(drawingarea->inner_window, NULL, FALSE);
-
-    if (visual) {
-        g_object_unref(attributes.colormap);
-    }
-}
-
-void
-moz_drawingarea_finalize (GObject *object)
-{
-    MozDrawingarea *drawingarea;
-    gpointer user_data;
-
-    g_return_if_fail(IS_MOZ_DRAWINGAREA(object));
-
-    drawingarea = MOZ_DRAWINGAREA(object);
-
-    gdk_window_destroy(drawingarea->inner_window);
-    gdk_window_destroy(drawingarea->clip_window);
-
-    (* parent_class->finalize) (object);
-}
-
-void
-moz_drawingarea_move (MozDrawingarea *drawingarea,
-                      gint x, gint y)
-{
-    gdk_window_move(drawingarea->clip_window, x, y);
-}
-
-void
-moz_drawingarea_resize (MozDrawingarea *drawingarea,
-                        gint width, gint height)
-{
-    gdk_window_resize(drawingarea->clip_window, width, height);
-    gdk_window_resize(drawingarea->inner_window, width, height);
-}
-
-void
-moz_drawingarea_move_resize (MozDrawingarea *drawingarea,
-                             gint x, gint y, gint width, gint height)
-{
-    gdk_window_resize(drawingarea->inner_window, width, height);
-    gdk_window_move_resize(drawingarea->clip_window, x, y, width, height);
-}
-
-void
-moz_drawingarea_set_visibility (MozDrawingarea *drawingarea,
-                                gboolean visibility)
-{
-    if (visibility) {
-        gdk_window_show_unraised(drawingarea->inner_window);
-        gdk_window_show_unraised(drawingarea->clip_window);
-    }
-    else    {
-        gdk_window_hide(drawingarea->clip_window);
-        gdk_window_hide(drawingarea->inner_window);
-    }
-}
-
-void
-moz_drawingarea_scroll (MozDrawingarea *drawingarea,
-                        gint x, gint y)
-{
-    gdk_window_scroll(drawingarea->inner_window, x, y);
-}
diff --git a/widget/src/gtk2/mozdrawingarea.h b/widget/src/gtk2/mozdrawingarea.h
deleted file mode 100644
index bdcc6d3..0000000
--- widget/src/gtk2/mozdrawingarea.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
-/* vim:expandtab:shiftwidth=4:tabstop=4:
- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is Christopher Blizzard
- * <blizzard@mozilla.org>.  Portions created by the Initial Developer
- * are Copyright (C) 2001 the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#ifndef __MOZ_DRAWINGAREA_H__
-#define __MOZ_DRAWINGAREA_H__
-
-#include <gdk/gdkwindow.h>
-#include <gtk/gtkversion.h>
-#include "mozcontainer.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-#define MOZ_DRAWINGAREA_TYPE            (moz_drawingarea_get_type())
-#define MOZ_DRAWINGAREA(obj)            (GTK_CHECK_CAST((obj), MOZ_DRAWINGAREA_TYPE, MozDrawingarea))
-#define MOZ_DRAWINGAREA_CLASS(klass)    (GTK_CHECK_CLASS_CAST((klass), MOZ_DRAWINGAREA_TYPE, MozDrawingareaClass))
-#define IS_MOZ_DRAWINGAREA(obj)         (GTK_CHECK_TYPE((obj), MOZ_DRAWINGAREA_TYPE))
-#define IS_MOZ_DRAWINGAREA_CLASS(klass) (GTK_CHECK_CLASS_TYPE((klass), MOZ_DRAWINGAREA_TYPE))
-#define MOZ_DRAWINGAREA_GET_CLASS(obj)  (GTK_CHECK_GET_CLASS((obj), MOZ_DRAWINGAREA_TYPE, MozDrawingareaClass))
-
-#if (GTK_CHECK_VERSION(2, 12, 0) || \
-    (GTK_CHECK_VERSION(2, 10, 0) && defined(MOZ_PLATFORM_HILDON)))
-#define HAVE_GTK_MOTION_HINTS
-#endif
-
-typedef struct _MozDrawingarea      MozDrawingarea;
-typedef struct _MozDrawingareaClass MozDrawingareaClass;
-
-struct _MozDrawingarea
-{
-    GObject         parent_instance;
-    /* AFAIK this clip_window (and thus this whole class) exists solely to
-     * make gdk_window_scroll() smooth for nsIWidget::Scroll(). */
-    GdkWindow      *clip_window;
-    GdkWindow      *inner_window;
-};
-
-struct _MozDrawingareaClass
-{
-    GObjectClass parent_class;
-};
-
-GtkType         moz_drawingarea_get_type       (void);
-MozDrawingarea *moz_drawingarea_new            (MozDrawingarea *parent,
-                                                MozContainer *widget_parent,
-                                                GdkVisual *visual);
-void            moz_drawingarea_reparent       (MozDrawingarea *drawingarea,
-                                                GdkWindow *aNewParent);
-void            moz_drawingarea_move           (MozDrawingarea *drawingarea,
-                                                gint x, gint y);
-void            moz_drawingarea_resize         (MozDrawingarea *drawingarea,
-                                                gint width, gint height);
-void            moz_drawingarea_move_resize    (MozDrawingarea *drawingarea,
-                                                gint x, gint y,
-                                                gint width, gint height);
-void            moz_drawingarea_set_visibility (MozDrawingarea *drawingarea,
-                                                gboolean visibility);
-void            moz_drawingarea_scroll         (MozDrawingarea *drawingarea,
-                                                gint x, gint y);
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* __MOZ_DRAWINGAREA_H__ */
diff --git a/widget/src/gtk2/nsWindow.cpp b/widget/src/gtk2/nsWindow.cpp
index b9cca02..b00bcdf 100644
--- widget/src/gtk2/nsWindow.cpp
+++ widget/src/gtk2/nsWindow.cpp
@@ -368,7 +368,7 @@ nsWindow::nsWindow()
     mPreferredWidth   = 0;
     mPreferredHeight  = 0;
     mContainer           = nsnull;
-    mDrawingarea         = nsnull;
+    mGdkWindow           = nsnull;
     mShell               = nsnull;
     mWindowGroup         = nsnull;
     mContainerGotFocus   = PR_FALSE;
@@ -673,9 +673,7 @@ CheckDestroyInvisibleContainer()
 
 // Change the containing GtkWidget on a sub-hierarchy of GdkWindows belonging
 // to aOldWidget and rooted at aWindow, and reparent any child GtkWidgets of
-// the GdkWindow hierarchy.  If aNewWidget is NULL, the reference to
-// aOldWidget is removed from its GdkWindows, and child GtkWidgets are
-// destroyed.
+// the GdkWindow hierarchy to aNewWidget.
 static void
 SetWidgetForHierarchy(GdkWindow *aWindow,
                       GtkWidget *aOldWidget,
@@ -694,13 +692,7 @@ SetWidgetForHierarchy(GdkWindow *aWindow,
 
         // This window belongs to a child widget, which will no longer be a
         // child of aOldWidget.
-        if (aNewWidget) {
-            gtk_widget_reparent(widget, aNewWidget);
-        } else {
-            // aNewWidget == NULL indicates that the window is about to be
-            // destroyed.
-            gtk_widget_destroy(widget);
-        }
+        gtk_widget_reparent(widget, aNewWidget);
 
         return;
     }
@@ -714,6 +706,30 @@ SetWidgetForHierarchy(GdkWindow *aWindow,
     gdk_window_set_user_data(aWindow, aNewWidget);
 }
 
+// Walk the list of child windows and call destroy on them.
+void
+nsWindow::DestroyChildWindows()
+{
+    if (!mGdkWindow)
+        return;
+
+    while (GList *children = gdk_window_peek_children(mGdkWindow)) {
+        GdkWindow *child = GDK_WINDOW(children->data);
+        nsWindow *kid = get_window_for_gdk_window(child);
+        if (kid) {
+            kid->Destroy();
+        } else {
+            // This child is not an nsWindow.
+            // Destroy the child GtkWidget.
+            gpointer data;
+            gdk_window_get_user_data(child, &data);
+            if (GTK_IS_WIDGET(data)) {
+                gtk_widget_destroy(static_cast<GtkWidget*>(data));
+            }
+        }
+    }
+}
+
 NS_IMETHODIMP
 nsWindow::Destroy(void)
 {
@@ -751,15 +767,6 @@ nsWindow::Destroy(void)
 
     NativeShow(PR_FALSE);
 
-    // walk the list of children and call destroy on them.  Have to be
-    // careful, though -- calling destroy on a kid may actually remove
-    // it from our child list, losing its sibling links.
-    for (nsIWidget* kid = mFirstChild; kid; ) {
-        nsIWidget* next = kid->GetNextSibling();
-        kid->Destroy();
-        kid = next;
-    }
-
 #ifdef USE_XIM
     IMEDestroyContext();
 #endif
@@ -796,35 +803,26 @@ nsWindow::Destroy(void)
         gtk_widget_destroy(mShell);
         mShell = nsnull;
         mContainer = nsnull;
+        NS_ABORT_IF_FALSE(!mGdkWindow,
+                          "mGdkWindow should be NULL when mContainer is destroyed");
     }
     else if (mContainer) {
         gtk_widget_destroy(GTK_WIDGET(mContainer));
         mContainer = nsnull;
+        NS_ABORT_IF_FALSE(!mGdkWindow,
+                          "mGdkWindow should be NULL when mContainer is destroyed");
     }
-    else if (owningWidget) {
-        // Remove references from GdkWindows back to their container
-        // widget while the GdkWindow hierarchy is still available.
-        // (OnContainerUnrealize does this when the MozContainer widget is
-        // destroyed.)
-        SetWidgetForHierarchy(mDrawingarea->clip_window, owningWidget, NULL);
-    }
-
-    if (mDrawingarea) {
-        g_object_set_data(G_OBJECT(mDrawingarea->clip_window),
-                          "nsWindow", NULL);
-        g_object_set_data(G_OBJECT(mDrawingarea->inner_window),
-                          "nsWindow", NULL);
-
-        g_object_set_data(G_OBJECT(mDrawingarea->clip_window),
-                          "mozdrawingarea", NULL);
-        g_object_set_data(G_OBJECT(mDrawingarea->inner_window),
-                          "mozdrawingarea", NULL);
-
-        NS_ASSERTION(!get_gtk_widget_for_gdk_window(mDrawingarea->inner_window),
-                     "widget reference not removed");
+    else if (mGdkWindow) {
+        // Destroy child windows to ensure that their mThebesSurfaces are
+        // released and to remove references from GdkWindows back to their
+        // container widget.  (OnContainerUnrealize() does this when the
+        // MozContainer widget is destroyed.)
+        DestroyChildWindows();
 
-        g_object_unref(mDrawingarea);
-        mDrawingarea = nsnull;
+        gdk_window_set_user_data(mGdkWindow, NULL);
+        g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", NULL);
+        gdk_window_destroy(mGdkWindow);
+        mGdkWindow = nsnull;
     }
 
     if (gInvisibleContainer && owningWidget == gInvisibleContainer) {
@@ -851,7 +849,7 @@ nsWindow::GetParent(void)
 NS_IMETHODIMP
 nsWindow::SetParent(nsIWidget *aNewParent)
 {
-    if (mContainer || !mDrawingarea || !mParent) {
+    if (mContainer || !mGdkWindow || !mParent) {
         NS_NOTREACHED("nsWindow::SetParent - reparenting a non-child window");
         return NS_ERROR_NOT_IMPLEMENTED;
     }
@@ -866,12 +864,12 @@ nsWindow::SetParent(nsIWidget *aNewParent)
     if (!oldContainer) {
         // The GdkWindows have been destroyed so there is nothing else to
         // reparent.
-        NS_ABORT_IF_FALSE(GDK_WINDOW_OBJECT(mDrawingarea->inner_window)->destroyed,
+        NS_ABORT_IF_FALSE(GDK_WINDOW_OBJECT(mGdkWindow)->destroyed,
                           "live GdkWindow with no widget");
         return NS_OK;
     }
 
-    NS_ABORT_IF_FALSE(!GDK_WINDOW_OBJECT(mDrawingarea->inner_window)->destroyed,
+    NS_ABORT_IF_FALSE(!GDK_WINDOW_OBJECT(mGdkWindow)->destroyed,
                       "destroyed GdkWindow with widget");
 
     GdkWindow* newParentWindow = NULL;
@@ -901,11 +899,10 @@ nsWindow::SetParent(nsIWidget *aNewParent)
         if (newContainer != oldContainer) {
             NS_ABORT_IF_FALSE(!GDK_WINDOW_OBJECT(newParentWindow)->destroyed,
                               "destroyed GdkWindow with widget");
-            SetWidgetForHierarchy(mDrawingarea->clip_window, oldContainer,
-                                  newContainer);
+            SetWidgetForHierarchy(mGdkWindow, oldContainer, newContainer);
         }
 
-        moz_drawingarea_reparent(mDrawingarea, newParentWindow);
+        gdk_window_reparent(mGdkWindow, newParentWindow, 0, 0);
     }
 
     return NS_OK;
@@ -1216,8 +1213,8 @@ nsWindow::Move(PRInt32 aX, PRInt32 aY)
     if (mIsTopLevel) {
         gtk_window_move(GTK_WINDOW(mShell), aX, aY);
     }
-    else if (mDrawingarea) {
-        moz_drawingarea_move(mDrawingarea, aX, aY);
+    else if (mGdkWindow) {
+        gdk_window_move(mGdkWindow, aX, aY);
     }
 
     return NS_OK;
@@ -1244,19 +1241,19 @@ nsWindow::SetZIndex(PRInt32 aZIndex)
 
     NS_ASSERTION(!mContainer, "Expected Mozilla child widget");
 
-    // We skip the nsWindows that don't have mDrawingareas.
+    // We skip the nsWindows that don't have mGdkWindows.
     // These are probably in the process of being destroyed.
 
     if (!GetNextSibling()) {
         // We're to be on top.
-        if (mDrawingarea)
-            gdk_window_raise(mDrawingarea->clip_window);
+        if (mGdkWindow)
+            gdk_window_raise(mGdkWindow);
     } else {
         // All the siblings before us need to be below our widget. 
         for (nsWindow* w = this; w;
              w = static_cast<nsWindow*>(w->GetPrevSibling())) {
-            if (w->mDrawingarea)
-                gdk_window_lower(w->mDrawingarea->clip_window);
+            if (w->mGdkWindow)
+                gdk_window_lower(w->mGdkWindow);
         }
     }
     return NS_OK;
@@ -1500,7 +1497,7 @@ nsWindow::SetCursor(nsCursor aCursor)
 {
     // if we're not the toplevel window pass up the cursor request to
     // the toplevel window to handle it.
-    if (!mContainer && mDrawingarea) {
+    if (!mContainer && mGdkWindow) {
         nsWindow *window = GetContainerWindow();
         if (!window)
             return NS_ERROR_FAILURE;
@@ -1583,7 +1580,7 @@ nsWindow::SetCursor(imgIContainer* aCursor,
 {
     // if we're not the toplevel window pass up the cursor request to
     // the toplevel window to handle it.
-    if (!mContainer && mDrawingarea) {
+    if (!mContainer && mGdkWindow) {
         nsWindow *window = GetContainerWindow();
         if (!window)
             return NS_ERROR_FAILURE;
@@ -1710,10 +1707,10 @@ nsWindow::Validate()
 {
     // Get the update for this window and, well, just drop it on the
     // floor.
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return NS_OK;
 
-    GdkRegion *region = gdk_window_get_update_area(mDrawingarea->inner_window);
+    GdkRegion *region = gdk_window_get_update_area(mGdkWindow);
 
     if (region)
         gdk_region_destroy(region);
@@ -1724,6 +1721,9 @@ nsWindow::Validate()
 NS_IMETHODIMP
 nsWindow::Invalidate(PRBool aIsSynchronous)
 {
+    if (!mGdkWindow)
+        return NS_OK;
+
     GdkRectangle rect;
 
     rect.x = mBounds.x;
@@ -1734,13 +1734,9 @@ nsWindow::Invalidate(PRBool aIsSynchronous)
     LOGDRAW(("Invalidate (all) [%p]: %d %d %d %d\n", (void *)this,
              rect.x, rect.y, rect.width, rect.height));
 
-    if (!mDrawingarea)
-        return NS_OK;
-
-    gdk_window_invalidate_rect(mDrawingarea->inner_window,
-                               &rect, FALSE);
+    gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
     if (aIsSynchronous)
-        gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
+        gdk_window_process_updates(mGdkWindow, FALSE);
 
     return NS_OK;
 }
@@ -1749,6 +1745,9 @@ NS_IMETHODIMP
 nsWindow::Invalidate(const nsRect &aRect,
                      PRBool        aIsSynchronous)
 {
+    if (!mGdkWindow)
+        return NS_OK;
+
     GdkRectangle rect;
 
     rect.x = aRect.x;
@@ -1759,13 +1758,9 @@ nsWindow::Invalidate(const nsRect &aRect,
     LOGDRAW(("Invalidate (rect) [%p]: %d %d %d %d (sync: %d)\n", (void *)this,
              rect.x, rect.y, rect.width, rect.height, aIsSynchronous));
 
-    if (!mDrawingarea)
-        return NS_OK;
-
-    gdk_window_invalidate_rect(mDrawingarea->inner_window,
-                               &rect, FALSE);
+    gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
     if (aIsSynchronous)
-        gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
+        gdk_window_process_updates(mGdkWindow, FALSE);
 
     return NS_OK;
 }
@@ -1777,7 +1772,7 @@ nsWindow::InvalidateRegion(const nsIRegion* aRegion,
     GdkRegion *region = nsnull;
     aRegion->GetNativeRegion((void *&)region);
 
-    if (region && mDrawingarea) {
+    if (region && mGdkWindow) {
         GdkRectangle rect;
         gdk_region_get_clipbox(region, &rect);
 
@@ -1785,7 +1780,7 @@ nsWindow::InvalidateRegion(const nsIRegion* aRegion,
                  (void *)this,
                  rect.x, rect.y, rect.width, rect.height, aIsSynchronous));
 
-        gdk_window_invalidate_region(mDrawingarea->inner_window,
+        gdk_window_invalidate_region(mGdkWindow,
                                      region, FALSE);
     }
     else {
@@ -1799,10 +1794,10 @@ nsWindow::InvalidateRegion(const nsIRegion* aRegion,
 NS_IMETHODIMP
 nsWindow::Update()
 {
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return NS_OK;
 
-    gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
+    gdk_window_process_updates(mGdkWindow, FALSE);
     return NS_OK;
 }
 
@@ -1817,7 +1812,7 @@ nsWindow::Scroll(PRInt32  aDx,
                  PRInt32  aDy,
                  nsRect  *aClipRect)
 {
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return NS_OK;
 
     D_DEBUG_AT( ns_Window, "%s( %4d,%4d )\n", __FUNCTION__, aDx, aDy );
@@ -1827,7 +1822,7 @@ nsWindow::Scroll(PRInt32  aDx,
                      aClipRect->x, aClipRect->y, aClipRect->width, aClipRect->height );
     }
 
-    moz_drawingarea_scroll(mDrawingarea, aDx, aDy);
+    gdk_window_scroll(mGdkWindow, aDx, aDy);
 
     // Update bounds on our child windows
     for (nsIWidget* kid = mFirstChild; kid; kid = kid->GetNextSibling()) {
@@ -1847,10 +1842,10 @@ NS_IMETHODIMP
 nsWindow::ScrollWidgets(PRInt32 aDx,
                         PRInt32 aDy)
 {
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return NS_OK;
 
-    moz_drawingarea_scroll(mDrawingarea, aDx, aDy);
+    gdk_window_scroll(mGdkWindow, aDx, aDy);
     return NS_OK;
 }
 
@@ -1868,10 +1863,10 @@ nsWindow::GetNativeData(PRUint32 aDataType)
     switch (aDataType) {
     case NS_NATIVE_WINDOW:
     case NS_NATIVE_WIDGET: {
-        if (!mDrawingarea)
+        if (!mGdkWindow)
             return nsnull;
 
-        return mDrawingarea->inner_window;
+        return mGdkWindow;
         break;
     }
 
@@ -1991,8 +1986,8 @@ nsWindow::WidgetToScreen(const nsRect& aOldRect, nsRect& aNewRect)
                                    &x, &y);
         LOG(("WidgetToScreen (container) %d %d\n", x, y));
     }
-    else if (mDrawingarea) {
-        gdk_window_get_origin(mDrawingarea->inner_window, &x, &y);
+    else if (mGdkWindow) {
+        gdk_window_get_origin(mGdkWindow, &x, &y);
         LOG(("WidgetToScreen (drawing) %d %d\n", x, y));
     }
 
@@ -2013,8 +2008,8 @@ nsWindow::ScreenToWidget(const nsRect& aOldRect, nsRect& aNewRect)
         gdk_window_get_root_origin(GTK_WIDGET(mContainer)->window,
                                    &x, &y);
     }
-    else if (mDrawingarea) {
-        gdk_window_get_origin(mDrawingarea->inner_window, &x, &y);
+    else if (mGdkWindow) {
+        gdk_window_get_origin(mGdkWindow, &x, &y);
     }
 
     aNewRect.x = aOldRect.x - x;
@@ -2065,7 +2060,7 @@ nsWindow::CaptureMouse(PRBool aCapture)
 {
     LOG(("CaptureMouse %p\n", (void *)this));
 
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return NS_OK;
 
     GtkWidget *widget = GetMozContainerWidget();
@@ -2089,7 +2084,7 @@ nsWindow::CaptureRollupEvents(nsIRollupListener *aListener,
                               PRBool             aDoCapture,
                               PRBool             aConsumeRollupEvent)
 {
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return NS_OK;
 
     GtkWidget *widget = GetMozContainerWidget();
@@ -2271,11 +2266,7 @@ nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
         return FALSE;
     }
 
-    if (!mDrawingarea)
-        return FALSE;
-
-    // handle exposes for the inner window only
-    if (aEvent->window != mDrawingarea->inner_window)
+    if (!mGdkWindow)
         return FALSE;
 
     static NS_DEFINE_CID(kRegionCID, NS_REGION_CID);
@@ -2320,7 +2311,7 @@ nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
     nsRefPtr<gfxContext> ctx = rc->ThebesContext();
 
     gfxPlatformGtk::GetPlatform()->SetGdkDrawable(ctx->OriginalSurface(),
-                                                  GDK_DRAWABLE(mDrawingarea->inner_window));
+                                                  GDK_DRAWABLE(mGdkWindow));
 
     // clip to the update region
     ctx->Save();
@@ -2381,7 +2372,7 @@ nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
         if (gForce24bpp) {
             depth = 24; // 24 always
         } else {
-            depth = gdk_drawable_get_depth(GDK_DRAWABLE(mDrawingarea->inner_window));
+            depth = gdk_drawable_get_depth(GDK_DRAWABLE(mGdkWindow));
         }
 
         if (!gUseBufferPixmap ||
@@ -2390,7 +2381,7 @@ nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
         {
             // create a one-off always if we're not using the global pixmap
             // if gUseBufferPixmap == TRUE, who's redrawing an area bigger than the screen?
-            bufferPixmap = gdk_pixmap_new(GDK_DRAWABLE(mDrawingarea->inner_window),
+            bufferPixmap = gdk_pixmap_new(GDK_DRAWABLE(mGdkWindow),
                                           boundsRect.width, boundsRect.height,
                                           depth);
             bufferPixmapSize.width = boundsRect.width;
@@ -2405,7 +2396,7 @@ nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
             gBufferPixmapSize.width = PR_MAX(gBufferPixmapSize.width, boundsRect.width);
             gBufferPixmapSize.height = PR_MAX(gBufferPixmapSize.height, boundsRect.height);
 
-            gBufferPixmap = gdk_pixmap_new(GDK_DRAWABLE(mDrawingarea->inner_window),
+            gBufferPixmap = gdk_pixmap_new(GDK_DRAWABLE(mGdkWindow),
                                            gBufferPixmapSize.width, gBufferPixmapSize.height,
                                            depth);
 
@@ -2575,8 +2566,11 @@ nsWindow::OnContainerUnrealize(GtkWidget *aWidget)
     NS_ASSERTION(mContainer == MOZ_CONTAINER(aWidget),
                  "unexpected \"unrealize\" signal");
 
-    if (mDrawingarea) {
-        SetWidgetForHierarchy(mDrawingarea->clip_window, aWidget, NULL);
+    if (mGdkWindow) {
+        DestroyChildWindows();
+
+        g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", NULL);
+        mGdkWindow = NULL;
     }
 }
 
@@ -2595,11 +2589,9 @@ nsWindow::OnSizeAllocate(GtkWidget *aWidget, GtkAllocation *aAllocation)
     mBounds.width = rect.width;
     mBounds.height = rect.height;
 
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return;
 
-    moz_drawingarea_resize (mDrawingarea, rect.width, rect.height);
-
     if (mTransparencyBitmap) {
       ApplyTransparencyBitmap();
     }
@@ -2668,7 +2660,7 @@ nsWindow::OnLeaveNotifyEvent(GtkWidget *aWidget, GdkEventCrossing *aEvent)
 
     event.time = aEvent->time;
 
-    event.exit = is_top_level_mouse_exit(mDrawingarea->inner_window, aEvent)
+    event.exit = is_top_level_mouse_exit(mGdkWindow, aEvent)
         ? nsMouseEvent::eTopLevel : nsMouseEvent::eChild;
 
     LOG(("OnLeaveNotify: %p\n", (void *)this));
@@ -2797,7 +2789,7 @@ nsWindow::OnMotionNotifyEvent(GtkWidget *aWidget, GdkEventMotion *aEvent)
     }
     else {
         // XXX see OnScrollEvent()
-        if (aEvent->window == mDrawingarea->inner_window) {
+        if (aEvent->window == mGdkWindow) {
             event.refPoint.x = nscoord(aEvent->x);
             event.refPoint.y = nscoord(aEvent->y);
         } else {
@@ -2828,7 +2820,7 @@ nsWindow::InitButtonEvent(nsMouseEvent &aEvent,
                           GdkEventButton *aGdkEvent)
 {
     // XXX see OnScrollEvent()
-    if (aGdkEvent->window == mDrawingarea->inner_window) {
+    if (aGdkEvent->window == mGdkWindow) {
         aEvent.refPoint.x = nscoord(aGdkEvent->x);
         aEvent.refPoint.y = nscoord(aGdkEvent->y);
     } else {
@@ -3373,7 +3365,7 @@ nsWindow::OnScrollEvent(GtkWidget *aWidget, GdkEventScroll *aEvent)
         break;
     }
 
-    if (aEvent->window == mDrawingarea->inner_window) {
+    if (aEvent->window == mGdkWindow) {
         // we are the window that the event happened on so no need for expensive ScreenToWidget
         event.refPoint.x = nscoord(aEvent->x);
         event.refPoint.y = nscoord(aEvent->y);
@@ -3469,12 +3461,12 @@ nsWindow::ThemeChanged()
     nsEventStatus status = nsEventStatus_eIgnore;
     DispatchEvent(&event, status);
 
-    if (!mDrawingarea || NS_UNLIKELY(mIsDestroyed))
+    if (!mGdkWindow || NS_UNLIKELY(mIsDestroyed))
         return;
 
     // Dispatch NS_THEMECHANGED to all child windows
     GList *children =
-        gdk_window_peek_children(mDrawingarea->inner_window);
+        gdk_window_peek_children(mGdkWindow);
     while (children) {
         GdkWindow *gdkWin = GDK_WINDOW(children->data);
 
@@ -3823,6 +3815,38 @@ GetBrandName(nsXPIDLString& brandName)
         brandName.Assign(NS_LITERAL_STRING("Mozilla"));
 }
 
+static GdkWindow *
+CreateGdkWindow(GdkWindow *parent, GtkWidget *widget)
+{
+    GdkWindowAttr attributes;
+    gint          attributes_mask = GDK_WA_VISUAL | GDK_WA_COLORMAP;
+
+    attributes.event_mask = (GDK_EXPOSURE_MASK | GDK_STRUCTURE_MASK |
+                             GDK_VISIBILITY_NOTIFY_MASK |
+                             GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK |
+                             GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
+#ifdef HAVE_GTK_MOTION_HINTS
+                             GDK_POINTER_MOTION_HINT_MASK |
+#endif
+                             GDK_POINTER_MOTION_MASK);
+
+    attributes.width = 1;
+    attributes.height = 1;
+    attributes.wclass = GDK_INPUT_OUTPUT;
+    attributes.visual = gtk_widget_get_visual(widget);
+    attributes.colormap = gtk_widget_get_colormap(widget);
+    attributes.window_type = GDK_WINDOW_CHILD;
+
+    GdkWindow *window = gdk_window_new(parent, &attributes, attributes_mask);
+    gdk_window_set_user_data(window, widget);
+
+    /* set the default pixmap to None so that you don't end up with the
+       gtk default which is BlackPixel. */
+    gdk_window_set_back_pixmap(window, NULL, FALSE);
+
+    return window;
+}
+
 nsresult
 nsWindow::NativeCreate(nsIWidget        *aParent,
                        nsNativeWidget    aNativeParent,
@@ -3866,8 +3890,7 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
     }
 
     // figure out our parent window
-    MozDrawingarea *parentArea = nsnull;
-    MozContainer   *parentMozContainer = nsnull;
+    GtkWidget      *parentMozContainer = nsnull;
     GtkContainer   *parentGtkContainer = nsnull;
     GdkWindow      *parentGdkWindow = nsnull;
     GtkWindow      *topLevelParent = nsnull;
@@ -3880,28 +3903,10 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
         parentGtkContainer = GTK_CONTAINER(aNativeParent);
 
     if (parentGdkWindow) {
-        // find the mozarea on that window
-        gpointer user_data = nsnull;
-        user_data = g_object_get_data(G_OBJECT(parentGdkWindow),
-                                      "mozdrawingarea");
-        parentArea = MOZ_DRAWINGAREA(user_data);
-
-        NS_ASSERTION(parentArea, "no drawingarea for parent widget!\n");
-        if (!parentArea)
-            return NS_ERROR_FAILURE;
-
-        // get the user data for the widget - it should be a container
-        user_data = nsnull;
-        gdk_window_get_user_data(parentArea->inner_window, &user_data);
-        NS_ASSERTION(user_data, "no user data for parentArea\n");
-        if (!user_data)
-            return NS_ERROR_FAILURE;
+        // get the widget for the window - it should be a moz container
+        parentMozContainer = get_gtk_widget_for_gdk_window(parentGdkWindow);
 
-        // Get the parent moz container
-        parentMozContainer = MOZ_CONTAINER(user_data);
-        NS_ASSERTION(parentMozContainer,
-                     "owning widget is not a mozcontainer!\n");
-        if (!parentMozContainer)
+        if (!IS_MOZ_CONTAINER(parentMozContainer))
             return NS_ERROR_FAILURE;
 
         // get the toplevel window just in case someone needs to use it
@@ -3910,8 +3915,6 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
             GTK_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(parentMozContainer)));
     }
 
-    GdkVisual* visual = nsnull;
-
     // ok, create our windows
     switch (mWindowType) {
     case eWindowType_dialog:
@@ -3939,11 +3942,11 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
                 GdkWindow* dialoglead = mShell->window;
                 gdk_window_set_group(dialoglead, dialoglead);
             }
-            if (parentArea) {
+            if (parentGdkWindow) {
                 nsWindow *parentnsWindow =
-                    get_window_for_gdk_window(parentArea->inner_window);
+                    get_window_for_gdk_window(parentGdkWindow);
                 NS_ASSERTION(parentnsWindow,
-                             "no nsWindow for parentArea!");
+                             "no nsWindow for parentGdkWindow!");
                 if (parentnsWindow && parentnsWindow->mWindowGroup) {
                     gtk_window_group_add_window(parentnsWindow->mWindowGroup,
                                                 GTK_WINDOW(mShell));
@@ -4009,15 +4012,16 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
         }
 
         // create our container
-        mContainer = MOZ_CONTAINER(moz_container_new());
-        gtk_container_add(GTK_CONTAINER(mShell), GTK_WIDGET(mContainer));
-        gtk_widget_realize(GTK_WIDGET(mContainer));
+        GtkWidget *container = moz_container_new();
+        mContainer = MOZ_CONTAINER(container);
+        gtk_container_add(GTK_CONTAINER(mShell), container);
+        gtk_widget_realize(container);
 
         // make sure this is the focus widget in the container
-        gtk_window_set_focus(GTK_WINDOW(mShell), GTK_WIDGET(mContainer));
+        gtk_window_set_focus(GTK_WINDOW(mShell), container);
 
         // and the drawing area
-        mDrawingarea = moz_drawingarea_new(nsnull, mContainer, visual);
+        mGdkWindow = container->window;
 
         if (mWindowType == eWindowType_popup) {
             // gdk does not automatically set the cursor for "temporary"
@@ -4033,14 +4037,15 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
         break;
     case eWindowType_child: {
         if (parentMozContainer) {
-            mDrawingarea = moz_drawingarea_new(parentArea, parentMozContainer, visual);
+            mGdkWindow = CreateGdkWindow(parentGdkWindow, parentMozContainer);
         }
         else if (parentGtkContainer) {
-            mContainer = MOZ_CONTAINER(moz_container_new());
-            gtk_container_add(parentGtkContainer, GTK_WIDGET(mContainer));
-            gtk_widget_realize(GTK_WIDGET(mContainer));
+            GtkWidget *container = moz_container_new();
+            mContainer = MOZ_CONTAINER(container);
+            gtk_container_add(parentGtkContainer, container);
+            gtk_widget_realize(container);
 
-            mDrawingarea = moz_drawingarea_new(nsnull, mContainer, visual);
+            mGdkWindow = container->window;
         }
         else {
             NS_WARNING("Warning: tried to create a new child widget with no parent!");
@@ -4061,17 +4066,8 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
         gtk_widget_set_double_buffered (GTK_WIDGET(mContainer),FALSE);
 #endif
 
-    // label the drawing area with this object so we can find our way
-    // home
-    g_object_set_data(G_OBJECT(mDrawingarea->clip_window), "nsWindow",
-                      this);
-    g_object_set_data(G_OBJECT(mDrawingarea->inner_window), "nsWindow",
-                      this);
-
-    g_object_set_data(G_OBJECT(mDrawingarea->clip_window), "mozdrawingarea",
-                      mDrawingarea);
-    g_object_set_data(G_OBJECT(mDrawingarea->inner_window), "mozdrawingarea",
-                      mDrawingarea);
+    // label the drawing window with this object so we can find our way home
+    g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", this);
 
     if (mContainer)
         g_object_set_data(G_OBJECT(mContainer), "nsWindow", this);
@@ -4161,13 +4157,9 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
              (void *)GTK_WIDGET(mContainer)->window,
              GDK_WINDOW_XWINDOW(GTK_WIDGET(mContainer)->window)));
     }
-
-    if (mDrawingarea) {
-        LOG(("\tmDrawingarea %p %p %p %lx %lx\n", (void *)mDrawingarea,
-             (void *)mDrawingarea->clip_window,
-             (void *)mDrawingarea->inner_window,
-             GDK_WINDOW_XWINDOW(mDrawingarea->clip_window),
-             GDK_WINDOW_XWINDOW(mDrawingarea->inner_window)));
+    else if (mGdkWindow) {
+        LOG(("\tmGdkWindow %p %lx\n", (void *)mGdkWindow,
+             GDK_WINDOW_XWINDOW(mGdkWindow)));
     }
 
     // resize so that everything is set to the right dimensions
@@ -4325,16 +4317,16 @@ nsWindow::NativeResize(PRInt32 aWidth, PRInt32 aHeight, PRBool  aRepaint)
         gtk_window_resize(GTK_WINDOW(mShell), aWidth, aHeight);
     }
     else if (mContainer) {
+        GtkWidget *widget = GTK_WIDGET(mContainer);
         GtkAllocation allocation;
-        allocation.x = 0;
-        allocation.y = 0;
+        allocation.x = widget->allocation.x;
+        allocation.y = widget->allocation.y;
         allocation.width = aWidth;
         allocation.height = aHeight;
-        gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
+        gtk_widget_size_allocate(widget, &allocation);
     }
-
-    if (mDrawingarea) {
-        moz_drawingarea_resize (mDrawingarea, aWidth, aHeight);
+    else if (mGdkWindow) {
+        gdk_window_resize(mGdkWindow, aWidth, aHeight);
     }
 }
 
@@ -4360,19 +4352,18 @@ nsWindow::NativeResize(PRInt32 aX, PRInt32 aY,
             gtk_window_move(GTK_WINDOW(mShell), aX, aY);
 
         gtk_window_resize(GTK_WINDOW(mShell), aWidth, aHeight);
-        moz_drawingarea_resize(mDrawingarea, aWidth, aHeight);
+        gdk_window_resize(mGdkWindow, aWidth, aHeight);
     }
     else if (mContainer) {
         GtkAllocation allocation;
-        allocation.x = 0;
-        allocation.y = 0;
+        allocation.x = aX;
+        allocation.y = aY;
         allocation.width = aWidth;
         allocation.height = aHeight;
         gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
-        moz_drawingarea_move_resize(mDrawingarea, aX, aY, aWidth, aHeight);
     }
-    else if (mDrawingarea) {
-        moz_drawingarea_move_resize(mDrawingarea, aX, aY, aWidth, aHeight);
+    else if (mGdkWindow) {
+        gdk_window_move_resize(mGdkWindow, aX, aY, aWidth, aHeight);
     }
 }
 
@@ -4401,16 +4392,14 @@ nsWindow::NativeShow (PRBool  aAction)
                 SetUserTimeAndStartupIDForActivatedWindow(mShell);
             }
 
-            moz_drawingarea_set_visibility(mDrawingarea, aAction);
             gtk_widget_show(GTK_WIDGET(mContainer));
             gtk_widget_show(mShell);
         }
         else if (mContainer) {
-            moz_drawingarea_set_visibility(mDrawingarea, TRUE);
             gtk_widget_show(GTK_WIDGET(mContainer));
         }
-        else if (mDrawingarea) {
-            moz_drawingarea_set_visibility(mDrawingarea, TRUE);
+        else if (mGdkWindow) {
+            gdk_window_show_unraised(mGdkWindow);
         }
     }
     else {
@@ -4420,10 +4409,9 @@ nsWindow::NativeShow (PRBool  aAction)
         }
         else if (mContainer) {
             gtk_widget_hide(GTK_WIDGET(mContainer));
-            moz_drawingarea_set_visibility(mDrawingarea, FALSE);
         }
-        if (mDrawingarea) {
-            moz_drawingarea_set_visibility(mDrawingarea, FALSE);
+        else if (mGdkWindow) {
+            gdk_window_hide(mGdkWindow);
         }
     }
 }
@@ -4684,11 +4672,11 @@ nsWindow::GrabPointer(void)
         return;
     }
 
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return;
 
     gint retval;
-    retval = gdk_pointer_grab(mDrawingarea->inner_window, TRUE,
+    retval = gdk_pointer_grab(mGdkWindow, TRUE,
                               (GdkEventMask)(GDK_BUTTON_PRESS_MASK |
                                              GDK_BUTTON_RELEASE_MASK |
                                              GDK_ENTER_NOTIFY_MASK |
@@ -4730,8 +4718,8 @@ nsWindow::GrabKeyboard(void)
 
     if (mTransientParent)
         grabWindow = GTK_WIDGET(mTransientParent)->window;
-    else if (mDrawingarea)
-        grabWindow = mDrawingarea->inner_window;
+    else if (mGdkWindow)
+        grabWindow = mGdkWindow;
     else
         return;
 
@@ -4777,11 +4765,11 @@ nsWindow::GetToplevelWidget(GtkWidget **aWidget)
 GtkWidget *
 nsWindow::GetMozContainerWidget()
 {
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return NULL;
 
     GtkWidget *owningWidget =
-        get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
+        get_gtk_widget_for_gdk_window(mGdkWindow);
     return owningWidget;
 }
 
@@ -4821,10 +4809,10 @@ nsWindow::SetUrgencyHint(GtkWidget *top_window, PRBool state)
 void *
 nsWindow::SetupPluginPort(void)
 {
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return nsnull;
 
-    if (GDK_WINDOW_OBJECT(mDrawingarea->inner_window)->destroyed == TRUE)
+    if (GDK_WINDOW_OBJECT(mGdkWindow)->destroyed == TRUE)
         return nsnull;
 
     // we have to flush the X queue here so that any plugins that
@@ -4832,22 +4820,19 @@ nsWindow::SetupPluginPort(void)
     // this window in case it was just created
 #ifdef MOZ_X11
     XWindowAttributes xattrs;
-    XGetWindowAttributes(GDK_DISPLAY (),
-                         GDK_WINDOW_XWINDOW(mDrawingarea->inner_window),
+    XGetWindowAttributes(GDK_DISPLAY(), GDK_WINDOW_XWINDOW(mGdkWindow),
                          &xattrs);
     XSelectInput (GDK_DISPLAY (),
-                  GDK_WINDOW_XWINDOW(mDrawingarea->inner_window),
+                  GDK_WINDOW_XWINDOW(mGdkWindow),
                   xattrs.your_event_mask |
                   SubstructureNotifyMask);
 
-    gdk_window_add_filter(mDrawingarea->inner_window,
-                          plugin_window_filter_func,
-                          this);
+    gdk_window_add_filter(mGdkWindow, plugin_window_filter_func, this);
 
     XSync(GDK_DISPLAY(), False);
 #endif /* MOZ_X11 */
 
-    return (void *)GDK_WINDOW_XWINDOW(mDrawingarea->inner_window);
+    return (void *)GDK_WINDOW_XWINDOW(mGdkWindow);
 }
 
 nsresult
@@ -4907,14 +4892,13 @@ nsWindow::SetNonXEmbedPluginFocus()
     Window curFocusWindow;
     int focusState;
 
-    XGetInputFocus(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
+    XGetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
                    &curFocusWindow,
                    &focusState);
 
     LOGFOCUS(("\t curFocusWindow=%p\n", curFocusWindow));
 
-    GdkWindow* toplevel = gdk_window_get_toplevel
-                                (mDrawingarea->inner_window);
+    GdkWindow* toplevel = gdk_window_get_toplevel(mGdkWindow);
     GdkWindow *gdkfocuswin = gdk_window_lookup(curFocusWindow);
 
     // lookup with the focus proxy window is supposed to get the
@@ -4926,11 +4910,11 @@ nsWindow::SetNonXEmbedPluginFocus()
 
     // switch the focus from the focus proxy to the plugin window
     mOldFocusWindow = curFocusWindow;
-    XRaiseWindow(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
-                 GDK_WINDOW_XWINDOW(mDrawingarea->inner_window));
+    XRaiseWindow(GDK_WINDOW_XDISPLAY(mGdkWindow),
+                 GDK_WINDOW_XWINDOW(mGdkWindow));
     gdk_error_trap_push();
-    XSetInputFocus(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
-                   GDK_WINDOW_XWINDOW(mDrawingarea->inner_window),
+    XSetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
+                   GDK_WINDOW_XWINDOW(mGdkWindow),
                    RevertToNone,
                    CurrentTime);
     gdk_flush();
@@ -4939,8 +4923,7 @@ nsWindow::SetNonXEmbedPluginFocus()
     gdk_window_add_filter(NULL, plugin_client_message_filter, this);
 
     LOGFOCUS(("nsWindow::SetNonXEmbedPluginFocus oldfocus=%p new=%p\n",
-                mOldFocusWindow,
-                GDK_WINDOW_XWINDOW(mDrawingarea->inner_window)));
+              mOldFocusWindow, GDK_WINDOW_XWINDOW(mGdkWindow)));
 }
 
 void
@@ -4957,7 +4940,7 @@ nsWindow::LoseNonXEmbedPluginFocus()
     Window curFocusWindow;
     int focusState;
 
-    XGetInputFocus(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
+    XGetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
                    &curFocusWindow,
                    &focusState);
 
@@ -4966,12 +4949,12 @@ nsWindow::LoseNonXEmbedPluginFocus()
     // event filter that blocks the WM_TAKE_FOCUS is enough. WM and gtk2
     // will take care of the focus later.
     if (!curFocusWindow ||
-        curFocusWindow == GDK_WINDOW_XWINDOW(mDrawingarea->inner_window)) {
+        curFocusWindow == GDK_WINDOW_XWINDOW(mGdkWindow)) {
 
         gdk_error_trap_push();
-        XRaiseWindow(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
+        XRaiseWindow(GDK_WINDOW_XDISPLAY(mGdkWindow),
                      mOldFocusWindow);
-        XSetInputFocus(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
+        XSetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
                        mOldFocusWindow,
                        RevertToParent,
                        CurrentTime);
@@ -6655,13 +6638,11 @@ nsWindow::IMESetCursorPosition(const nsTextEventReply& aReply)
 
     // Get the position of the refWindow in screen.
     gint refX, refY;
-    gdk_window_get_origin(refWindow->mDrawingarea->inner_window,
-                          &refX, &refY);
+    gdk_window_get_origin(refWindow->mGdkWindow, &refX, &refY);
 
     // Get the position of IM context owner window in screen.
     gint ownerX, ownerY;
-    gdk_window_get_origin(ownerWindow->mDrawingarea->inner_window,
-                          &ownerX, &ownerY);
+    gdk_window_get_origin(ownerWindow->mGdkWindow, &ownerX, &ownerY);
 
     // Compute the caret position in the IM owner window.
     GdkRectangle area;
@@ -6807,7 +6788,7 @@ nsWindow::GetToggledKeyState(PRUint32 aKeyCode, PRBool* aLEDState)
     GdkModifierType modifiers = gdk_keyboard_get_modifiers();
     PRUint32 capsLockMask, numLockMask, scrollLockMask;
     PRBool foundMasks = gdk_keyboard_get_modmap_masks(
-                          GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
+                          GDK_WINDOW_XDISPLAY(mGdkWindow),
                           &capsLockMask, &numLockMask, &scrollLockMask);
     if (!foundMasks)
         return NS_ERROR_NOT_IMPLEMENTED;
@@ -7138,10 +7119,12 @@ nsWindow::GetSurfaceForGdkDrawable(GdkDrawable* aDrawable,
 gfxASurface*
 nsWindow::GetThebesSurface()
 {
+    if (!mGdkWindow)
+        return nsnull;
+
     GdkDrawable* d;
     gint x_offset, y_offset;
-    gdk_window_get_internal_paint_info(mDrawingarea->inner_window,
-                                       &d, &x_offset, &y_offset);
+    gdk_window_get_internal_paint_info(mGdkWindow, &d, &x_offset, &y_offset);
 
 #ifdef MOZ_X11
     gint width, height;
@@ -7217,7 +7200,7 @@ nsWindow::BeginResizeDrag(nsGUIEvent* aEvent, PRInt32 aHorizontal, PRInt32 aVert
     }
 
     // get the gdk window for this widget
-    GdkWindow* gdk_window = mDrawingarea->inner_window;
+    GdkWindow* gdk_window = mGdkWindow;
     if (!GDK_IS_WINDOW(gdk_window)) {
       return NS_ERROR_FAILURE;
     }
diff --git a/widget/src/gtk2/nsWindow.h b/widget/src/gtk2/nsWindow.h
index 23aa482..277c82c 100644
--- widget/src/gtk2/nsWindow.h
+++ widget/src/gtk2/nsWindow.h
@@ -43,7 +43,6 @@
 #include "nsAutoPtr.h"
 
 #include "mozcontainer.h"
-#include "mozdrawingarea.h"
 #include "nsWeakReference.h"
 
 #include "nsIDragService.h"
@@ -480,6 +479,7 @@ protected:
     PRUint32            mPreferredHeight;
 
 private:
+    void               DestroyChildWindows();
     void               GetToplevelWidget(GtkWidget **aWidget);
     GtkWidget         *GetMozContainerWidget();
     nsWindow          *GetContainerWindow();
@@ -492,7 +492,7 @@ private:
 
     GtkWidget          *mShell;
     MozContainer       *mContainer;
-    MozDrawingarea     *mDrawingarea;
+    GdkWindow          *mGdkWindow;
 
     GtkWindowGroup     *mWindowGroup;
 
