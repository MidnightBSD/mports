=== modified file 'include/my_pthread.h'
--- include/my_pthread.h	2008-12-14 11:36:15 +0000
+++ include/my_pthread.h	2009-01-26 15:56:07 +0000
@@ -621,6 +621,7 @@ extern pthread_mutexattr_t my_errorcheck
 
 typedef ulong my_thread_id;
 
+extern my_bool my_threadattr_global_init(void);
 extern my_bool my_thread_global_init(void);
 extern void my_thread_global_end(void);
 extern my_bool my_thread_init(void);

=== modified file 'mysys/my_init.c'
--- mysys/my_init.c	2009-01-16 11:49:33 +0000
+++ mysys/my_init.c	2009-01-26 15:56:07 +0000
@@ -84,11 +84,14 @@ my_bool my_init(void)
   if (my_progname)
     my_progname_short= my_progname + dirname_length(my_progname);
 
-#if defined(THREAD) && defined(SAFE_MUTEX)
+#if defined(THREAD)
+  if (my_threadattr_global_init())
+    return 1;
+#  if defined(SAFE_MUTEX)
   safe_mutex_global_init();		/* Must be called early */
-#endif
-#if defined(THREAD) && defined(MY_PTHREAD_FASTMUTEX) && !defined(SAFE_MUTEX)
+#  elif defined(MY_PTHREAD_FASTMUTEX)
   fastmutex_global_init();              /* Must be called early */
+#  endif
 #endif
   netware_init();
 #ifdef THREAD

=== modified file 'mysys/my_thr_init.c'
--- mysys/my_thr_init.c	2008-12-13 16:34:25 +0000
+++ mysys/my_thr_init.c	2009-01-26 15:56:07 +0000
@@ -68,6 +68,47 @@ nptl_pthread_exit_hack_handler(void *arg
 #endif /* TARGET_OS_LINUX */
 
 
+
+/*
+  initialize thread attributes
+
+  SYNOPSIS
+    my_threadattr_global_init()
+
+  RETURN  is error?
+    FALSE  ok
+    TRUE   error
+*/
+
+my_bool my_threadattr_global_init(void)
+{
+#ifdef PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
+  /*
+    Set mutex type to "fast" a.k.a "adaptive"
+
+    In this case the thread may steal the mutex from some other thread
+    that is waiting for the same mutex.  This will save us some
+    context switches but may cause a thread to 'starve forever' while
+    waiting for the mutex (not likely if the code within the mutex is
+    short).
+  */
+  pthread_mutexattr_init(&my_fast_mutexattr);  /* ?= MY_MUTEX_INIT_FAST */
+  pthread_mutexattr_settype(&my_fast_mutexattr,
+                            PTHREAD_MUTEX_ADAPTIVE_NP);
+#endif
+#ifdef PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
+  /*
+    Set mutex type to "errorcheck"
+  */
+  pthread_mutexattr_init(&my_errorcheck_mutexattr);
+  pthread_mutexattr_settype(&my_errorcheck_mutexattr,
+                            PTHREAD_MUTEX_ERRORCHECK);
+#endif
+
+  return FALSE;
+}
+
+
 static uint get_thread_lib(void);
 
 /*
@@ -127,28 +168,6 @@ my_bool my_thread_global_init(void)
   if (my_thread_init())
     return 1;
 
-#ifdef PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
-  /*
-    Set mutex type to "fast" a.k.a "adaptive"
-
-    In this case the thread may steal the mutex from some other thread
-    that is waiting for the same mutex.  This will save us some
-    context switches but may cause a thread to 'starve forever' while
-    waiting for the mutex (not likely if the code within the mutex is
-    short).
-  */
-  pthread_mutexattr_init(&my_fast_mutexattr);
-  pthread_mutexattr_settype(&my_fast_mutexattr,
-                            PTHREAD_MUTEX_ADAPTIVE_NP);
-#endif
-#ifdef PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
-  /*
-    Set mutex type to "errorcheck"
-  */
-  pthread_mutexattr_init(&my_errorcheck_mutexattr);
-  pthread_mutexattr_settype(&my_errorcheck_mutexattr,
-                            PTHREAD_MUTEX_ERRORCHECK);
-#endif
 
   /* Mutex uses by mysys */
   pthread_mutex_init(&THR_LOCK_open,MY_MUTEX_INIT_FAST);

